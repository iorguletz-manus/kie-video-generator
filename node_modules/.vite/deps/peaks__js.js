import "./chunk-PLDDJCW6.js";

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Global.js
var PI_OVER_180 = Math.PI / 180;
function detectBrowser() {
  return typeof window !== "undefined" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
}
var glob = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : {};
var Konva = {
  _global: glob,
  version: "10.0.11",
  isBrowser: detectBrowser(),
  isUnminified: /param/.test((function(param) {
  }).toString()),
  dblClickWindow: 400,
  getAngle(angle) {
    return Konva.angleDeg ? angle * PI_OVER_180 : angle;
  },
  enableTrace: false,
  pointerEventsEnabled: true,
  autoDrawEnabled: true,
  hitOnDragEnabled: false,
  capturePointerEventsEnabled: false,
  _mouseListenClick: false,
  _touchListenClick: false,
  _pointerListenClick: false,
  _mouseInDblClickWindow: false,
  _touchInDblClickWindow: false,
  _pointerInDblClickWindow: false,
  _mouseDblClickPointerId: null,
  _touchDblClickPointerId: null,
  _pointerDblClickPointerId: null,
  _renderBackend: "web",
  legacyTextRendering: false,
  pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
  dragDistance: 3,
  angleDeg: true,
  showWarnings: true,
  dragButtons: [0, 1],
  isDragging() {
    return Konva["DD"].isDragging;
  },
  isTransforming() {
    var _a, _b;
    return (_b = (_a = Konva["Transformer"]) === null || _a === void 0 ? void 0 : _a.isTransforming()) !== null && _b !== void 0 ? _b : false;
  },
  isDragReady() {
    return !!Konva["DD"].node;
  },
  releaseCanvasOnDestroy: true,
  document: glob.document,
  _injectGlobal(Konva3) {
    if (typeof glob.Konva !== "undefined") {
      console.error("Several Konva instances detected. It is not recommended to use multiple Konva instances in the same environment.");
    }
    glob.Konva = Konva3;
  }
};
var _registerNode = (NodeClass) => {
  Konva[NodeClass.prototype.getClassName()] = NodeClass;
};
Konva._injectGlobal(Konva);

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Util.js
var NODE_ERROR = `Konva.js unsupported environment.

Looks like you are trying to use Konva.js in Node.js environment. because "document" object is undefined.

To use Konva.js in Node.js environment, you need to use the "canvas-backend" or "skia-backend" module.

bash: npm install canvas
js: import "konva/canvas-backend";

or

bash: npm install skia-canvas
js: import "konva/skia-backend";
`;
var ensureBrowser = () => {
  if (typeof document === "undefined") {
    throw new Error(NODE_ERROR);
  }
};
var Transform = class _Transform {
  constructor(m = [1, 0, 0, 1, 0, 0]) {
    this.dirty = false;
    this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
  }
  reset() {
    this.m[0] = 1;
    this.m[1] = 0;
    this.m[2] = 0;
    this.m[3] = 1;
    this.m[4] = 0;
    this.m[5] = 0;
  }
  copy() {
    return new _Transform(this.m);
  }
  copyInto(tr) {
    tr.m[0] = this.m[0];
    tr.m[1] = this.m[1];
    tr.m[2] = this.m[2];
    tr.m[3] = this.m[3];
    tr.m[4] = this.m[4];
    tr.m[5] = this.m[5];
  }
  point(point) {
    const m = this.m;
    return {
      x: m[0] * point.x + m[2] * point.y + m[4],
      y: m[1] * point.x + m[3] * point.y + m[5]
    };
  }
  translate(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
    return this;
  }
  scale(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
    return this;
  }
  rotate(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const m11 = this.m[0] * c + this.m[2] * s;
    const m12 = this.m[1] * c + this.m[3] * s;
    const m21 = this.m[0] * -s + this.m[2] * c;
    const m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    return this;
  }
  getTranslation() {
    return {
      x: this.m[4],
      y: this.m[5]
    };
  }
  skew(sx, sy) {
    const m11 = this.m[0] + this.m[2] * sy;
    const m12 = this.m[1] + this.m[3] * sy;
    const m21 = this.m[2] + this.m[0] * sx;
    const m22 = this.m[3] + this.m[1] * sx;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    return this;
  }
  multiply(matrix) {
    const m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
    const m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
    const m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
    const m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
    const dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
    const dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
    return this;
  }
  invert() {
    const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
    const m0 = this.m[3] * d;
    const m1 = -this.m[1] * d;
    const m2 = -this.m[2] * d;
    const m3 = this.m[0] * d;
    const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
    const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
    return this;
  }
  getMatrix() {
    return this.m;
  }
  decompose() {
    const a = this.m[0];
    const b = this.m[1];
    const c = this.m[2];
    const d = this.m[3];
    const e = this.m[4];
    const f = this.m[5];
    const delta = a * d - b * c;
    const result = {
      x: e,
      y: f,
      rotation: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (a != 0 || b != 0) {
      const r = Math.sqrt(a * a + b * b);
      result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
      result.scaleX = r;
      result.scaleY = delta / r;
      result.skewX = (a * c + b * d) / delta;
      result.skewY = 0;
    } else if (c != 0 || d != 0) {
      const s = Math.sqrt(c * c + d * d);
      result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
      result.scaleX = delta / s;
      result.scaleY = s;
      result.skewX = 0;
      result.skewY = (a * c + b * d) / delta;
    } else {
    }
    result.rotation = Util._getRotation(result.rotation);
    return result;
  }
};
var OBJECT_ARRAY = "[object Array]";
var OBJECT_NUMBER = "[object Number]";
var OBJECT_STRING = "[object String]";
var OBJECT_BOOLEAN = "[object Boolean]";
var PI_OVER_DEG180 = Math.PI / 180;
var DEG180_OVER_PI = 180 / Math.PI;
var HASH = "#";
var EMPTY_STRING = "";
var ZERO = "0";
var KONVA_WARNING = "Konva warning: ";
var KONVA_ERROR = "Konva error: ";
var RGB_PAREN = "rgb(";
var COLORS = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 132, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 255, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [119, 128, 144],
  slategrey: [119, 128, 144],
  snow: [255, 255, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 5]
};
var RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
var animQueue = [];
var _isCanvasFarblingActive = null;
var req = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || function(f) {
  setTimeout(f, 60);
};
var Util = {
  _isElement(obj) {
    return !!(obj && obj.nodeType == 1);
  },
  _isFunction(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  },
  _isPlainObject(obj) {
    return !!obj && obj.constructor === Object;
  },
  _isArray(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
  },
  _isNumber(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
  },
  _isString(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_STRING;
  },
  _isBoolean(obj) {
    return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
  },
  isObject(val) {
    return val instanceof Object;
  },
  isValidSelector(selector) {
    if (typeof selector !== "string") {
      return false;
    }
    const firstChar = selector[0];
    return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
  },
  _sign(number) {
    if (number === 0) {
      return 1;
    }
    if (number > 0) {
      return 1;
    } else {
      return -1;
    }
  },
  requestAnimFrame(callback) {
    animQueue.push(callback);
    if (animQueue.length === 1) {
      req(function() {
        const queue = animQueue;
        animQueue = [];
        queue.forEach(function(cb) {
          cb();
        });
      });
    }
  },
  createCanvasElement() {
    ensureBrowser();
    const canvas = document.createElement("canvas");
    try {
      canvas.style = canvas.style || {};
    } catch (e) {
    }
    return canvas;
  },
  createImageElement() {
    ensureBrowser();
    return document.createElement("img");
  },
  _isInDocument(el) {
    while (el = el.parentNode) {
      if (el == document) {
        return true;
      }
    }
    return false;
  },
  _urlToImage(url, callback) {
    const imageObj = Util.createImageElement();
    imageObj.onload = function() {
      callback(imageObj);
    };
    imageObj.src = url;
  },
  _rgbToHex(r, g, b) {
    return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  },
  _hexToRgb(hex) {
    hex = hex.replace(HASH, EMPTY_STRING);
    const bigint = parseInt(hex, 16);
    return {
      r: bigint >> 16 & 255,
      g: bigint >> 8 & 255,
      b: bigint & 255
    };
  },
  getRandomColor() {
    let randColor = (Math.random() * 16777215 << 0).toString(16);
    while (randColor.length < 6) {
      randColor = ZERO + randColor;
    }
    return HASH + randColor;
  },
  isCanvasFarblingActive() {
    if (_isCanvasFarblingActive !== null) {
      return _isCanvasFarblingActive;
    }
    if (typeof document === "undefined") {
      _isCanvasFarblingActive = false;
      return false;
    }
    const c = this.createCanvasElement();
    c.width = 1;
    c.height = 1;
    const ctx = c.getContext("2d", {
      willReadFrequently: true
    });
    ctx.clearRect(0, 0, 1, 1);
    ctx.fillStyle = "rgba(255,0,255,1)";
    ctx.fillRect(0, 0, 1, 1);
    const d = ctx.getImageData(0, 0, 1, 1).data;
    const exact = d[0] === 255 && d[1] === 0 && d[2] === 255 && d[3] === 255;
    _isCanvasFarblingActive = !exact;
    this.releaseCanvas(c);
    return _isCanvasFarblingActive;
  },
  getHitColor() {
    const color = this.getRandomColor();
    return this.isCanvasFarblingActive() ? this.getSnappedHexColor(color) : color;
  },
  getHitColorKey(r, g, b) {
    if (this.isCanvasFarblingActive()) {
      r = Math.round(r / 5) * 5;
      g = Math.round(g / 5) * 5;
      b = Math.round(b / 5) * 5;
    }
    return HASH + this._rgbToHex(r, g, b);
  },
  getSnappedHexColor(hex) {
    const rgb = this._hexToRgb(hex);
    return HASH + this._rgbToHex(Math.round(rgb.r / 5) * 5, Math.round(rgb.g / 5) * 5, Math.round(rgb.b / 5) * 5);
  },
  getRGB(color) {
    let rgb;
    if (color in COLORS) {
      rgb = COLORS[color];
      return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2]
      };
    } else if (color[0] === HASH) {
      return this._hexToRgb(color.substring(1));
    } else if (color.substr(0, 4) === RGB_PAREN) {
      rgb = RGB_REGEX.exec(color.replace(/ /g, ""));
      return {
        r: parseInt(rgb[1], 10),
        g: parseInt(rgb[2], 10),
        b: parseInt(rgb[3], 10)
      };
    } else {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
  },
  colorToRGBA(str) {
    str = str || "black";
    return Util._namedColorToRBA(str) || Util._hex3ColorToRGBA(str) || Util._hex4ColorToRGBA(str) || Util._hex6ColorToRGBA(str) || Util._hex8ColorToRGBA(str) || Util._rgbColorToRGBA(str) || Util._rgbaColorToRGBA(str) || Util._hslColorToRGBA(str);
  },
  _namedColorToRBA(str) {
    const c = COLORS[str.toLowerCase()];
    if (!c) {
      return null;
    }
    return {
      r: c[0],
      g: c[1],
      b: c[2],
      a: 1
    };
  },
  _rgbColorToRGBA(str) {
    if (str.indexOf("rgb(") === 0) {
      str = str.match(/rgb\(([^)]+)\)/)[1];
      const parts = str.split(/ *, */).map(Number);
      return {
        r: parts[0],
        g: parts[1],
        b: parts[2],
        a: 1
      };
    }
  },
  _rgbaColorToRGBA(str) {
    if (str.indexOf("rgba(") === 0) {
      str = str.match(/rgba\(([^)]+)\)/)[1];
      const parts = str.split(/ *, */).map((n, index) => {
        if (n.slice(-1) === "%") {
          return index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255;
        }
        return Number(n);
      });
      return {
        r: parts[0],
        g: parts[1],
        b: parts[2],
        a: parts[3]
      };
    }
  },
  _hex8ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 9) {
      return {
        r: parseInt(str.slice(1, 3), 16),
        g: parseInt(str.slice(3, 5), 16),
        b: parseInt(str.slice(5, 7), 16),
        a: parseInt(str.slice(7, 9), 16) / 255
      };
    }
  },
  _hex6ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 7) {
      return {
        r: parseInt(str.slice(1, 3), 16),
        g: parseInt(str.slice(3, 5), 16),
        b: parseInt(str.slice(5, 7), 16),
        a: 1
      };
    }
  },
  _hex4ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 5) {
      return {
        r: parseInt(str[1] + str[1], 16),
        g: parseInt(str[2] + str[2], 16),
        b: parseInt(str[3] + str[3], 16),
        a: parseInt(str[4] + str[4], 16) / 255
      };
    }
  },
  _hex3ColorToRGBA(str) {
    if (str[0] === "#" && str.length === 4) {
      return {
        r: parseInt(str[1] + str[1], 16),
        g: parseInt(str[2] + str[2], 16),
        b: parseInt(str[3] + str[3], 16),
        a: 1
      };
    }
  },
  _hslColorToRGBA(str) {
    if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
      const [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str);
      const h = Number(hsl[0]) / 360;
      const s = Number(hsl[1]) / 100;
      const l = Number(hsl[2]) / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return {
          r: Math.round(val),
          g: Math.round(val),
          b: Math.round(val),
          a: 1
        };
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return {
        r: Math.round(rgb[0]),
        g: Math.round(rgb[1]),
        b: Math.round(rgb[2]),
        a: 1
      };
    }
  },
  haveIntersection(r1, r2) {
    return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
  },
  cloneObject(obj) {
    const retObj = {};
    for (const key in obj) {
      if (this._isPlainObject(obj[key])) {
        retObj[key] = this.cloneObject(obj[key]);
      } else if (this._isArray(obj[key])) {
        retObj[key] = this.cloneArray(obj[key]);
      } else {
        retObj[key] = obj[key];
      }
    }
    return retObj;
  },
  cloneArray(arr) {
    return arr.slice(0);
  },
  degToRad(deg) {
    return deg * PI_OVER_DEG180;
  },
  radToDeg(rad) {
    return rad * DEG180_OVER_PI;
  },
  _degToRad(deg) {
    Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead.");
    return Util.degToRad(deg);
  },
  _radToDeg(rad) {
    Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead.");
    return Util.radToDeg(rad);
  },
  _getRotation(radians) {
    return Konva.angleDeg ? Util.radToDeg(radians) : radians;
  },
  _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  },
  throw(str) {
    throw new Error(KONVA_ERROR + str);
  },
  error(str) {
    console.error(KONVA_ERROR + str);
  },
  warn(str) {
    if (!Konva.showWarnings) {
      return;
    }
    console.warn(KONVA_WARNING + str);
  },
  each(obj, func) {
    for (const key in obj) {
      func(key, obj[key]);
    }
  },
  _inRange(val, left, right) {
    return left <= val && val < right;
  },
  _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
    let x, y, dist;
    const pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (pd2 == 0) {
      x = x1;
      y = y1;
      dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
    } else {
      const u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
      if (u < 0) {
        x = x1;
        y = y1;
        dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
      } else if (u > 1) {
        x = x2;
        y = y2;
        dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
      } else {
        x = x1 + u * (x2 - x1);
        y = y1 + u * (y2 - y1);
        dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
      }
    }
    return [x, y, dist];
  },
  _getProjectionToLine(pt, line, isClosed) {
    const pc = Util.cloneObject(pt);
    let dist = Number.MAX_VALUE;
    line.forEach(function(p1, i) {
      if (!isClosed && i === line.length - 1) {
        return;
      }
      const p2 = line[(i + 1) % line.length];
      const proj = Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
      const px = proj[0], py = proj[1], pdist = proj[2];
      if (pdist < dist) {
        pc.x = px;
        pc.y = py;
        dist = pdist;
      }
    });
    return pc;
  },
  _prepareArrayForTween(startArray, endArray, isClosed) {
    const start = [], end = [];
    if (startArray.length > endArray.length) {
      const temp = endArray;
      endArray = startArray;
      startArray = temp;
    }
    for (let n = 0; n < startArray.length; n += 2) {
      start.push({
        x: startArray[n],
        y: startArray[n + 1]
      });
    }
    for (let n = 0; n < endArray.length; n += 2) {
      end.push({
        x: endArray[n],
        y: endArray[n + 1]
      });
    }
    const newStart = [];
    end.forEach(function(point) {
      const pr = Util._getProjectionToLine(point, start, isClosed);
      newStart.push(pr.x);
      newStart.push(pr.y);
    });
    return newStart;
  },
  _prepareToStringify(obj) {
    let desc;
    obj.visitedByCircularReferenceRemoval = true;
    for (const key in obj) {
      if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
        continue;
      }
      desc = Object.getOwnPropertyDescriptor(obj, key);
      if (obj[key].visitedByCircularReferenceRemoval || Util._isElement(obj[key])) {
        if (desc.configurable) {
          delete obj[key];
        } else {
          return null;
        }
      } else if (Util._prepareToStringify(obj[key]) === null) {
        if (desc.configurable) {
          delete obj[key];
        } else {
          return null;
        }
      }
    }
    delete obj.visitedByCircularReferenceRemoval;
    return obj;
  },
  _assign(target, source) {
    for (const key in source) {
      target[key] = source[key];
    }
    return target;
  },
  _getFirstPointerId(evt) {
    if (!evt.touches) {
      return evt.pointerId || 999;
    } else {
      return evt.changedTouches[0].identifier;
    }
  },
  releaseCanvas(...canvases) {
    if (!Konva.releaseCanvasOnDestroy)
      return;
    canvases.forEach((c) => {
      c.width = 0;
      c.height = 0;
    });
  },
  drawRoundedRectPath(context, width, height, cornerRadius) {
    let xOrigin = width < 0 ? width : 0;
    let yOrigin = height < 0 ? height : 0;
    width = Math.abs(width);
    height = Math.abs(height);
    let topLeft = 0;
    let topRight = 0;
    let bottomLeft = 0;
    let bottomRight = 0;
    if (typeof cornerRadius === "number") {
      topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
    } else {
      topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
      topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
      bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
      bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
    }
    context.moveTo(xOrigin + topLeft, yOrigin);
    context.lineTo(xOrigin + width - topRight, yOrigin);
    context.arc(xOrigin + width - topRight, yOrigin + topRight, topRight, Math.PI * 3 / 2, 0, false);
    context.lineTo(xOrigin + width, yOrigin + height - bottomRight);
    context.arc(xOrigin + width - bottomRight, yOrigin + height - bottomRight, bottomRight, 0, Math.PI / 2, false);
    context.lineTo(xOrigin + bottomLeft, yOrigin + height);
    context.arc(xOrigin + bottomLeft, yOrigin + height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
    context.lineTo(xOrigin, yOrigin + topLeft);
    context.arc(xOrigin + topLeft, yOrigin + topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
  },
  drawRoundedPolygonPath(context, points, sides, radius, cornerRadius) {
    radius = Math.abs(radius);
    for (let i = 0; i < sides; i++) {
      const prev = points[(i - 1 + sides) % sides];
      const curr = points[i];
      const next = points[(i + 1) % sides];
      const vec1 = { x: curr.x - prev.x, y: curr.y - prev.y };
      const vec2 = { x: next.x - curr.x, y: next.y - curr.y };
      const len1 = Math.hypot(vec1.x, vec1.y);
      const len2 = Math.hypot(vec2.x, vec2.y);
      let currCornerRadius;
      if (typeof cornerRadius === "number") {
        currCornerRadius = cornerRadius;
      } else {
        currCornerRadius = i < cornerRadius.length ? cornerRadius[i] : 0;
      }
      const maxCornerRadius = radius * Math.cos(Math.PI / sides);
      currCornerRadius = maxCornerRadius * Math.min(1, currCornerRadius / radius * 2);
      const normalVec1 = { x: vec1.x / len1, y: vec1.y / len1 };
      const normalVec2 = { x: vec2.x / len2, y: vec2.y / len2 };
      const p1 = {
        x: curr.x - normalVec1.x * currCornerRadius,
        y: curr.y - normalVec1.y * currCornerRadius
      };
      const p2 = {
        x: curr.x + normalVec2.x * currCornerRadius,
        y: curr.y + normalVec2.y * currCornerRadius
      };
      if (i === 0) {
        context.moveTo(p1.x, p1.y);
      } else {
        context.lineTo(p1.x, p1.y);
      }
      context.arcTo(curr.x, curr.y, p2.x, p2.y, currCornerRadius);
    }
  }
};

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Context.js
function simplifyArray(arr) {
  const retArr = [], len = arr.length, util = Util;
  for (let n = 0; n < len; n++) {
    let val = arr[n];
    if (util._isNumber(val)) {
      val = Math.round(val * 1e3) / 1e3;
    } else if (!util._isString(val)) {
      val = val + "";
    }
    retArr.push(val);
  }
  return retArr;
}
var COMMA = ",";
var OPEN_PAREN = "(";
var CLOSE_PAREN = ")";
var OPEN_PAREN_BRACKET = "([";
var CLOSE_BRACKET_PAREN = "])";
var SEMICOLON = ";";
var DOUBLE_PAREN = "()";
var EQUALS = "=";
var CONTEXT_METHODS = [
  "arc",
  "arcTo",
  "beginPath",
  "bezierCurveTo",
  "clearRect",
  "clip",
  "closePath",
  "createLinearGradient",
  "createPattern",
  "createRadialGradient",
  "drawImage",
  "ellipse",
  "fill",
  "fillText",
  "getImageData",
  "createImageData",
  "lineTo",
  "moveTo",
  "putImageData",
  "quadraticCurveTo",
  "rect",
  "roundRect",
  "restore",
  "rotate",
  "save",
  "scale",
  "setLineDash",
  "setTransform",
  "stroke",
  "strokeText",
  "transform",
  "translate"
];
var CONTEXT_PROPERTIES = [
  "fillStyle",
  "strokeStyle",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "letterSpacing",
  "lineCap",
  "lineDashOffset",
  "lineJoin",
  "lineWidth",
  "miterLimit",
  "direction",
  "font",
  "textAlign",
  "textBaseline",
  "globalAlpha",
  "globalCompositeOperation",
  "imageSmoothingEnabled",
  "filter"
];
var traceArrMax = 100;
var _cssFiltersSupported = null;
function isCSSFiltersSupported() {
  if (_cssFiltersSupported !== null) {
    return _cssFiltersSupported;
  }
  try {
    const canvas = Util.createCanvasElement();
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      _cssFiltersSupported = false;
      return false;
    }
    return !!ctx && "filter" in ctx;
  } catch (e) {
    _cssFiltersSupported = false;
    return false;
  }
}
var Context = class {
  constructor(canvas) {
    this.canvas = canvas;
    if (Konva.enableTrace) {
      this.traceArr = [];
      this._enableTrace();
    }
  }
  fillShape(shape) {
    if (shape.fillEnabled()) {
      this._fill(shape);
    }
  }
  _fill(shape) {
  }
  strokeShape(shape) {
    if (shape.hasStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {
  }
  fillStrokeShape(shape) {
    if (shape.attrs.fillAfterStrokeEnabled) {
      this.strokeShape(shape);
      this.fillShape(shape);
    } else {
      this.fillShape(shape);
      this.strokeShape(shape);
    }
  }
  getTrace(relaxed, rounded) {
    let traceArr = this.traceArr, len = traceArr.length, str = "", n, trace, method, args;
    for (n = 0; n < len; n++) {
      trace = traceArr[n];
      method = trace.method;
      if (method) {
        args = trace.args;
        str += method;
        if (relaxed) {
          str += DOUBLE_PAREN;
        } else {
          if (Util._isArray(args[0])) {
            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
          } else {
            if (rounded) {
              args = args.map((a) => typeof a === "number" ? Math.floor(a) : a);
            }
            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
          }
        }
      } else {
        str += trace.property;
        if (!relaxed) {
          str += EQUALS + trace.val;
        }
      }
      str += SEMICOLON;
    }
    return str;
  }
  clearTrace() {
    this.traceArr = [];
  }
  _trace(str) {
    let traceArr = this.traceArr, len;
    traceArr.push(str);
    len = traceArr.length;
    if (len >= traceArrMax) {
      traceArr.shift();
    }
  }
  reset() {
    const pixelRatio = this.getCanvas().getPixelRatio();
    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  clear(bounds) {
    const canvas = this.getCanvas();
    if (bounds) {
      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
    } else {
      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
    }
  }
  _applyLineCap(shape) {
    const lineCap = shape.attrs.lineCap;
    if (lineCap) {
      this.setAttr("lineCap", lineCap);
    }
  }
  _applyOpacity(shape) {
    const absOpacity = shape.getAbsoluteOpacity();
    if (absOpacity !== 1) {
      this.setAttr("globalAlpha", absOpacity);
    }
  }
  _applyLineJoin(shape) {
    const lineJoin = shape.attrs.lineJoin;
    if (lineJoin) {
      this.setAttr("lineJoin", lineJoin);
    }
  }
  _applyMiterLimit(shape) {
    const miterLimit = shape.attrs.miterLimit;
    if (miterLimit != null) {
      this.setAttr("miterLimit", miterLimit);
    }
  }
  setAttr(attr, val) {
    this._context[attr] = val;
  }
  arc(x, y, radius, startAngle, endAngle, counterClockwise) {
    this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._context.arcTo(x1, y1, x2, y2, radius);
  }
  beginPath() {
    this._context.beginPath();
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  clearRect(x, y, width, height) {
    this._context.clearRect(x, y, width, height);
  }
  clip(...args) {
    this._context.clip.apply(this._context, args);
  }
  closePath() {
    this._context.closePath();
  }
  createImageData(width, height) {
    const a = arguments;
    if (a.length === 2) {
      return this._context.createImageData(width, height);
    } else if (a.length === 1) {
      return this._context.createImageData(width);
    }
  }
  createLinearGradient(x0, y0, x1, y1) {
    return this._context.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return this._context.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    const a = arguments, _context = this._context;
    if (a.length === 3) {
      _context.drawImage(image, sx, sy);
    } else if (a.length === 5) {
      _context.drawImage(image, sx, sy, sWidth, sHeight);
    } else if (a.length === 9) {
      _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    }
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
  }
  isPointInPath(x, y, path, fillRule) {
    if (path) {
      return this._context.isPointInPath(path, x, y, fillRule);
    }
    return this._context.isPointInPath(x, y, fillRule);
  }
  fill(...args) {
    this._context.fill.apply(this._context, args);
  }
  fillRect(x, y, width, height) {
    this._context.fillRect(x, y, width, height);
  }
  strokeRect(x, y, width, height) {
    this._context.strokeRect(x, y, width, height);
  }
  fillText(text, x, y, maxWidth) {
    if (maxWidth) {
      this._context.fillText(text, x, y, maxWidth);
    } else {
      this._context.fillText(text, x, y);
    }
  }
  measureText(text) {
    return this._context.measureText(text);
  }
  getImageData(sx, sy, sw, sh) {
    return this._context.getImageData(sx, sy, sw, sh);
  }
  lineTo(x, y) {
    this._context.lineTo(x, y);
  }
  moveTo(x, y) {
    this._context.moveTo(x, y);
  }
  rect(x, y, width, height) {
    this._context.rect(x, y, width, height);
  }
  roundRect(x, y, width, height, radii) {
    this._context.roundRect(x, y, width, height, radii);
  }
  putImageData(imageData, dx, dy) {
    this._context.putImageData(imageData, dx, dy);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this._context.quadraticCurveTo(cpx, cpy, x, y);
  }
  restore() {
    this._context.restore();
  }
  rotate(angle) {
    this._context.rotate(angle);
  }
  save() {
    this._context.save();
  }
  scale(x, y) {
    this._context.scale(x, y);
  }
  setLineDash(segments) {
    if (this._context.setLineDash) {
      this._context.setLineDash(segments);
    } else if ("mozDash" in this._context) {
      this._context["mozDash"] = segments;
    } else if ("webkitLineDash" in this._context) {
      this._context["webkitLineDash"] = segments;
    }
  }
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(a, b, c, d, e, f) {
    this._context.setTransform(a, b, c, d, e, f);
  }
  stroke(path2d) {
    if (path2d) {
      this._context.stroke(path2d);
    } else {
      this._context.stroke();
    }
  }
  strokeText(text, x, y, maxWidth) {
    this._context.strokeText(text, x, y, maxWidth);
  }
  transform(a, b, c, d, e, f) {
    this._context.transform(a, b, c, d, e, f);
  }
  translate(x, y) {
    this._context.translate(x, y);
  }
  _enableTrace() {
    let that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;
    const func = function(methodName) {
      let origMethod = that[methodName], ret;
      that[methodName] = function() {
        args = simplifyArray(Array.prototype.slice.call(arguments, 0));
        ret = origMethod.apply(that, arguments);
        that._trace({
          method: methodName,
          args
        });
        return ret;
      };
    };
    for (n = 0; n < len; n++) {
      func(CONTEXT_METHODS[n]);
    }
    that.setAttr = function() {
      origSetter.apply(that, arguments);
      const prop = arguments[0];
      let val = arguments[1];
      if (prop === "shadowOffsetX" || prop === "shadowOffsetY" || prop === "shadowBlur") {
        val = val / this.canvas.getPixelRatio();
      }
      that._trace({
        property: prop,
        val
      });
    };
  }
  _applyGlobalCompositeOperation(node) {
    const op = node.attrs.globalCompositeOperation;
    const def = !op || op === "source-over";
    if (!def) {
      this.setAttr("globalCompositeOperation", op);
    }
  }
};
CONTEXT_PROPERTIES.forEach(function(prop) {
  Object.defineProperty(Context.prototype, prop, {
    get() {
      return this._context[prop];
    },
    set(val) {
      this._context[prop] = val;
    }
  });
});
var SceneContext = class extends Context {
  constructor(canvas, { willReadFrequently = false } = {}) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently
    });
  }
  _fillColor(shape) {
    const fill = shape.fill();
    this.setAttr("fillStyle", fill);
    shape._fillFunc(this);
  }
  _fillPattern(shape) {
    this.setAttr("fillStyle", shape._getFillPattern());
    shape._fillFunc(this);
  }
  _fillLinearGradient(shape) {
    const grd = shape._getLinearGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fillRadialGradient(shape) {
    const grd = shape._getRadialGradient();
    if (grd) {
      this.setAttr("fillStyle", grd);
      shape._fillFunc(this);
    }
  }
  _fill(shape) {
    const hasColor = shape.fill(), fillPriority = shape.getFillPriority();
    if (hasColor && fillPriority === "color") {
      this._fillColor(shape);
      return;
    }
    const hasPattern = shape.getFillPatternImage();
    if (hasPattern && fillPriority === "pattern") {
      this._fillPattern(shape);
      return;
    }
    const hasLinearGradient = shape.getFillLinearGradientColorStops();
    if (hasLinearGradient && fillPriority === "linear-gradient") {
      this._fillLinearGradient(shape);
      return;
    }
    const hasRadialGradient = shape.getFillRadialGradientColorStops();
    if (hasRadialGradient && fillPriority === "radial-gradient") {
      this._fillRadialGradient(shape);
      return;
    }
    if (hasColor) {
      this._fillColor(shape);
    } else if (hasPattern) {
      this._fillPattern(shape);
    } else if (hasLinearGradient) {
      this._fillLinearGradient(shape);
    } else if (hasRadialGradient) {
      this._fillRadialGradient(shape);
    }
  }
  _strokeLinearGradient(shape) {
    const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
    if (colorStops) {
      for (let n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr("strokeStyle", grd);
    }
  }
  _stroke(shape) {
    const dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
    if (shape.hasStroke()) {
      if (!strokeScaleEnabled) {
        this.save();
        const pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      if (dash && shape.dashEnabled()) {
        this.setLineDash(dash);
        this.setAttr("lineDashOffset", shape.dashOffset());
      }
      this.setAttr("lineWidth", shape.strokeWidth());
      if (!shape.getShadowForStrokeEnabled()) {
        this.setAttr("shadowColor", "rgba(0,0,0,0)");
      }
      const hasLinearGradient = shape.getStrokeLinearGradientColorStops();
      if (hasLinearGradient) {
        this._strokeLinearGradient(shape);
      } else {
        this.setAttr("strokeStyle", shape.stroke());
      }
      shape._strokeFunc(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
  _applyShadow(shape) {
    var _a, _b, _c;
    const color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
      x: 0,
      y: 0
    }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
    this.setAttr("shadowColor", color);
    this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
    this.setAttr("shadowOffsetX", offset.x * scaleX);
    this.setAttr("shadowOffsetY", offset.y * scaleY);
  }
};
var HitContext = class extends Context {
  constructor(canvas) {
    super(canvas);
    this._context = canvas._canvas.getContext("2d", {
      willReadFrequently: true
    });
  }
  _fill(shape) {
    this.save();
    this.setAttr("fillStyle", shape.colorKey);
    shape._fillFuncHit(this);
    this.restore();
  }
  strokeShape(shape) {
    if (shape.hasHitStroke()) {
      this._stroke(shape);
    }
  }
  _stroke(shape) {
    if (shape.hasHitStroke()) {
      const strokeScaleEnabled = shape.getStrokeScaleEnabled();
      if (!strokeScaleEnabled) {
        this.save();
        const pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      }
      this._applyLineCap(shape);
      const hitStrokeWidth = shape.hitStrokeWidth();
      const strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
      this.setAttr("lineWidth", strokeWidth);
      this.setAttr("strokeStyle", shape.colorKey);
      shape._strokeFuncHit(this);
      if (!strokeScaleEnabled) {
        this.restore();
      }
    }
  }
};

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Canvas.js
var _pixelRatio;
function getDevicePixelRatio() {
  if (_pixelRatio) {
    return _pixelRatio;
  }
  const canvas = Util.createCanvasElement();
  const context = canvas.getContext("2d");
  _pixelRatio = (function() {
    const devicePixelRatio = Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio / backingStoreRatio;
  })();
  Util.releaseCanvas(canvas);
  return _pixelRatio;
}
var Canvas = class {
  constructor(config) {
    this.pixelRatio = 1;
    this.width = 0;
    this.height = 0;
    this.isCache = false;
    const conf = config || {};
    const pixelRatio = conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();
    this.pixelRatio = pixelRatio;
    this._canvas = Util.createCanvasElement();
    this._canvas.style.padding = "0";
    this._canvas.style.margin = "0";
    this._canvas.style.border = "0";
    this._canvas.style.background = "transparent";
    this._canvas.style.position = "absolute";
    this._canvas.style.top = "0";
    this._canvas.style.left = "0";
  }
  getContext() {
    return this.context;
  }
  getPixelRatio() {
    return this.pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    const previousRatio = this.pixelRatio;
    this.pixelRatio = pixelRatio;
    this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
  }
  setWidth(width) {
    this.width = this._canvas.width = width * this.pixelRatio;
    this._canvas.style.width = width + "px";
    const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  setHeight(height) {
    this.height = this._canvas.height = height * this.pixelRatio;
    this._canvas.style.height = height + "px";
    const pixelRatio = this.pixelRatio, _context = this.getContext()._context;
    _context.scale(pixelRatio, pixelRatio);
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setSize(width, height) {
    this.setWidth(width || 0);
    this.setHeight(height || 0);
  }
  toDataURL(mimeType, quality) {
    try {
      return this._canvas.toDataURL(mimeType, quality);
    } catch (e) {
      try {
        return this._canvas.toDataURL();
      } catch (err) {
        Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        return "";
      }
    }
  }
};
var SceneCanvas = class extends Canvas {
  constructor(config = { width: 0, height: 0, willReadFrequently: false }) {
    super(config);
    this.context = new SceneContext(this, {
      willReadFrequently: config.willReadFrequently
    });
    this.setSize(config.width, config.height);
  }
};
var HitCanvas = class extends Canvas {
  constructor(config = { width: 0, height: 0 }) {
    super(config);
    this.hitCanvas = true;
    this.context = new HitContext(this);
    this.setSize(config.width, config.height);
  }
};

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/DragAndDrop.js
var DD = {
  get isDragging() {
    let flag = false;
    DD._dragElements.forEach((elem) => {
      if (elem.dragStatus === "dragging") {
        flag = true;
      }
    });
    return flag;
  },
  justDragged: false,
  get node() {
    let node;
    DD._dragElements.forEach((elem) => {
      node = elem.node;
    });
    return node;
  },
  _dragElements: /* @__PURE__ */ new Map(),
  _drag(evt) {
    const nodesToFireEvents = [];
    DD._dragElements.forEach((elem, key) => {
      const { node } = elem;
      const stage = node.getStage();
      stage.setPointersPositions(evt);
      if (elem.pointerId === void 0) {
        elem.pointerId = Util._getFirstPointerId(evt);
      }
      const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
      if (!pos) {
        return;
      }
      if (elem.dragStatus !== "dragging") {
        const dragDistance = node.dragDistance();
        const distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
        if (distance < dragDistance) {
          return;
        }
        node.startDrag({ evt });
        if (!node.isDragging()) {
          return;
        }
      }
      node._setDragPosition(evt, elem);
      nodesToFireEvents.push(node);
    });
    nodesToFireEvents.forEach((node) => {
      node.fire("dragmove", {
        type: "dragmove",
        target: node,
        evt
      }, true);
    });
  },
  _endDragBefore(evt) {
    const drawNodes = [];
    DD._dragElements.forEach((elem) => {
      const { node } = elem;
      const stage = node.getStage();
      if (evt) {
        stage.setPointersPositions(evt);
      }
      const pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
      if (!pos) {
        return;
      }
      if (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") {
        DD.justDragged = true;
        Konva._mouseListenClick = false;
        Konva._touchListenClick = false;
        Konva._pointerListenClick = false;
        elem.dragStatus = "stopped";
      }
      const drawNode = elem.node.getLayer() || elem.node instanceof Konva["Stage"] && elem.node;
      if (drawNode && drawNodes.indexOf(drawNode) === -1) {
        drawNodes.push(drawNode);
      }
    });
    drawNodes.forEach((drawNode) => {
      drawNode.draw();
    });
  },
  _endDragAfter(evt) {
    DD._dragElements.forEach((elem, key) => {
      if (elem.dragStatus === "stopped") {
        elem.node.fire("dragend", {
          type: "dragend",
          target: elem.node,
          evt
        }, true);
      }
      if (elem.dragStatus !== "dragging") {
        DD._dragElements.delete(key);
      }
    });
  }
};
if (Konva.isBrowser) {
  window.addEventListener("mouseup", DD._endDragBefore, true);
  window.addEventListener("touchend", DD._endDragBefore, true);
  window.addEventListener("touchcancel", DD._endDragBefore, true);
  window.addEventListener("mousemove", DD._drag);
  window.addEventListener("touchmove", DD._drag);
  window.addEventListener("mouseup", DD._endDragAfter, false);
  window.addEventListener("touchend", DD._endDragAfter, false);
  window.addEventListener("touchcancel", DD._endDragAfter, false);
}

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Validators.js
function _formatValue(val) {
  if (Util._isString(val)) {
    return '"' + val + '"';
  }
  if (Object.prototype.toString.call(val) === "[object Number]") {
    return val;
  }
  if (Util._isBoolean(val)) {
    return val;
  }
  return Object.prototype.toString.call(val);
}
function getNumberValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (!Util._isNumber(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.');
      }
      return val;
    };
  }
}
function getNumberOrArrayOfNumbersValidator(noOfElements) {
  if (Konva.isUnminified) {
    return function(val, attr) {
      let isNumber2 = Util._isNumber(val);
      let isValidArray = Util._isArray(val) && val.length == noOfElements;
      if (!isNumber2 && !isValidArray) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")");
      }
      return val;
    };
  }
}
function getNumberOrAutoValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isNumber2 = Util._isNumber(val);
      const isAuto = val === "auto";
      if (!(isNumber2 || isAuto)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".');
      }
      return val;
    };
  }
}
function getStringValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (!Util._isString(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.');
      }
      return val;
    };
  }
}
function getStringOrGradientValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isString2 = Util._isString(val);
      const isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val["addColorStop"];
      if (!(isString2 || isGradient)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.');
      }
      return val;
    };
  }
}
function getNumberArrayValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
      if (TypedArray && val instanceof TypedArray) {
        return val;
      }
      if (!Util._isArray(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.');
      } else {
        val.forEach(function(item) {
          if (!Util._isNumber(item)) {
            Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
          }
        });
      }
      return val;
    };
  }
}
function getBooleanValidator() {
  if (Konva.isUnminified) {
    return function(val, attr) {
      const isBool = val === true || val === false;
      if (!isBool) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.');
      }
      return val;
    };
  }
}
function getComponentValidator(components) {
  if (Konva.isUnminified) {
    return function(val, attr) {
      if (val === void 0 || val === null) {
        return val;
      }
      if (!Util.isObject(val)) {
        Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components);
      }
      return val;
    };
  }
}

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Factory.js
var GET = "get";
var SET = "set";
var Factory = {
  addGetterSetter(constructor, attr, def, validator, after) {
    Factory.addGetter(constructor, attr, def);
    Factory.addSetter(constructor, attr, validator, after);
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  addGetter(constructor, attr, def) {
    const method = GET + Util._capitalize(attr);
    constructor.prototype[method] = constructor.prototype[method] || function() {
      const val = this.attrs[attr];
      return val === void 0 ? def : val;
    };
  },
  addSetter(constructor, attr, validator, after) {
    const method = SET + Util._capitalize(attr);
    if (!constructor.prototype[method]) {
      Factory.overWriteSetter(constructor, attr, validator, after);
    }
  },
  overWriteSetter(constructor, attr, validator, after) {
    const method = SET + Util._capitalize(attr);
    constructor.prototype[method] = function(val) {
      if (validator && val !== void 0 && val !== null) {
        val = validator.call(this, val, attr);
      }
      this._setAttr(attr, val);
      if (after) {
        after.call(this);
      }
      return this;
    };
  },
  addComponentsGetterSetter(constructor, attr, components, validator, after) {
    const len = components.length, capitalize = Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr);
    constructor.prototype[getter] = function() {
      const ret = {};
      for (let n = 0; n < len; n++) {
        const component = components[n];
        ret[component] = this.getAttr(attr + capitalize(component));
      }
      return ret;
    };
    const basicValidator = getComponentValidator(components);
    constructor.prototype[setter] = function(val) {
      const oldVal = this.attrs[attr];
      if (validator) {
        val = validator.call(this, val, attr);
      }
      if (basicValidator) {
        basicValidator.call(this, val, attr);
      }
      for (const key in val) {
        if (!val.hasOwnProperty(key)) {
          continue;
        }
        this._setAttr(attr + capitalize(key), val[key]);
      }
      if (!val) {
        components.forEach((component) => {
          this._setAttr(attr + capitalize(component), void 0);
        });
      }
      this._fireChangeEvent(attr, oldVal, val);
      if (after) {
        after.call(this);
      }
      return this;
    };
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  addOverloadedGetterSetter(constructor, attr) {
    const capitalizedAttr = Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
    constructor.prototype[attr] = function() {
      if (arguments.length) {
        this[setter](arguments[0]);
        return this;
      }
      return this[getter]();
    };
  },
  addDeprecatedGetterSetter(constructor, attr, def, validator) {
    Util.error("Adding deprecated " + attr);
    const method = GET + Util._capitalize(attr);
    const message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
    constructor.prototype[method] = function() {
      Util.error(message);
      const val = this.attrs[attr];
      return val === void 0 ? def : val;
    };
    Factory.addSetter(constructor, attr, validator, function() {
      Util.error(message);
    });
    Factory.addOverloadedGetterSetter(constructor, attr);
  },
  backCompat(constructor, methods) {
    Util.each(methods, function(oldMethodName, newMethodName) {
      const method = constructor.prototype[newMethodName];
      const oldGetter = GET + Util._capitalize(oldMethodName);
      const oldSetter = SET + Util._capitalize(oldMethodName);
      function deprecated() {
        method.apply(this, arguments);
        Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
      }
      constructor.prototype[oldMethodName] = deprecated;
      constructor.prototype[oldGetter] = deprecated;
      constructor.prototype[oldSetter] = deprecated;
    });
  },
  afterSetFilter() {
    this._filterUpToDate = false;
  }
};

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Node.js
function parseCSSFilters(cssFilter) {
  const filterRegex = /(\w+)\(([^)]+)\)/g;
  let match;
  while ((match = filterRegex.exec(cssFilter)) !== null) {
    const [, filterName, filterValue] = match;
    switch (filterName) {
      case "blur": {
        const blurRadius = parseFloat(filterValue.replace("px", ""));
        return function(imageData) {
          this.blurRadius(blurRadius * 0.5);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Blur) {
            KonvaFilters.Blur.call(this, imageData);
          }
        };
      }
      case "brightness": {
        const brightness = filterValue.includes("%") ? parseFloat(filterValue) / 100 : parseFloat(filterValue);
        return function(imageData) {
          this.brightness(brightness);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Brightness) {
            KonvaFilters.Brightness.call(this, imageData);
          }
        };
      }
      case "contrast": {
        const contrast = parseFloat(filterValue);
        return function(imageData) {
          const konvaContrast = 100 * (Math.sqrt(contrast) - 1);
          this.contrast(konvaContrast);
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Contrast) {
            KonvaFilters.Contrast.call(this, imageData);
          }
        };
      }
      case "grayscale": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Grayscale) {
            KonvaFilters.Grayscale.call(this, imageData);
          }
        };
      }
      case "sepia": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Sepia) {
            KonvaFilters.Sepia.call(this, imageData);
          }
        };
      }
      case "invert": {
        return function(imageData) {
          const KonvaFilters = Konva.Filters;
          if (KonvaFilters && KonvaFilters.Invert) {
            KonvaFilters.Invert.call(this, imageData);
          }
        };
      }
      default:
        Util.warn(`CSS filter "${filterName}" is not supported in fallback mode. Consider using function filters for better compatibility.`);
        break;
    }
  }
  return () => {
  };
}
var ABSOLUTE_OPACITY = "absoluteOpacity";
var ALL_LISTENERS = "allEventListeners";
var ABSOLUTE_TRANSFORM = "absoluteTransform";
var ABSOLUTE_SCALE = "absoluteScale";
var CANVAS = "canvas";
var CHANGE = "Change";
var CHILDREN = "children";
var KONVA = "konva";
var LISTENING = "listening";
var MOUSEENTER = "mouseenter";
var MOUSELEAVE = "mouseleave";
var POINTERENTER = "pointerenter";
var POINTERLEAVE = "pointerleave";
var TOUCHENTER = "touchenter";
var TOUCHLEAVE = "touchleave";
var SET2 = "set";
var SHAPE = "Shape";
var SPACE = " ";
var STAGE = "stage";
var TRANSFORM = "transform";
var UPPER_STAGE = "Stage";
var VISIBLE = "visible";
var TRANSFORM_CHANGE_STR = [
  "xChange.konva",
  "yChange.konva",
  "scaleXChange.konva",
  "scaleYChange.konva",
  "skewXChange.konva",
  "skewYChange.konva",
  "rotationChange.konva",
  "offsetXChange.konva",
  "offsetYChange.konva",
  "transformsEnabledChange.konva"
].join(SPACE);
var idCounter = 1;
var Node = class _Node {
  constructor(config) {
    this._id = idCounter++;
    this.eventListeners = {};
    this.attrs = {};
    this.index = 0;
    this._allEventListeners = null;
    this.parent = null;
    this._cache = /* @__PURE__ */ new Map();
    this._attachedDepsListeners = /* @__PURE__ */ new Map();
    this._lastPos = null;
    this._batchingTransformChange = false;
    this._needClearTransformCache = false;
    this._filterUpToDate = false;
    this._isUnderCache = false;
    this._dragEventId = null;
    this._shouldFireChangeEvents = false;
    this.setAttrs(config);
    this._shouldFireChangeEvents = true;
  }
  hasChildren() {
    return false;
  }
  _clearCache(attr) {
    if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr)) {
      this._cache.get(attr).dirty = true;
    } else if (attr) {
      this._cache.delete(attr);
    } else {
      this._cache.clear();
    }
  }
  _getCache(attr, privateGetter) {
    let cache = this._cache.get(attr);
    const isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
    const invalid = cache === void 0 || isTransform && cache.dirty === true;
    if (invalid) {
      cache = privateGetter.call(this);
      this._cache.set(attr, cache);
    }
    return cache;
  }
  _calculate(name, deps, getter) {
    if (!this._attachedDepsListeners.get(name)) {
      const depsString = deps.map((dep) => dep + "Change.konva").join(SPACE);
      this.on(depsString, () => {
        this._clearCache(name);
      });
      this._attachedDepsListeners.set(name, true);
    }
    return this._getCache(name, getter);
  }
  _getCanvasCache() {
    return this._cache.get(CANVAS);
  }
  _clearSelfAndDescendantCache(attr) {
    this._clearCache(attr);
    if (attr === ABSOLUTE_TRANSFORM) {
      this.fire("absoluteTransformChange");
    }
  }
  clearCache() {
    if (this._cache.has(CANVAS)) {
      const { scene, filter, hit, buffer } = this._cache.get(CANVAS);
      Util.releaseCanvas(scene, filter, hit, buffer);
      this._cache.delete(CANVAS);
    }
    this._clearSelfAndDescendantCache();
    this._requestDraw();
    return this;
  }
  cache(config) {
    const conf = config || {};
    let rect = {};
    if (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) {
      rect = this.getClientRect({
        skipTransform: true,
        relativeTo: this.getParent() || void 0
      });
    }
    let width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === void 0 ? Math.floor(rect.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
    if (!width || !height) {
      Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
      return;
    }
    const extraPaddingX = Math.abs(Math.round(rect.x) - x) > 0.5 ? 1 : 0;
    const extraPaddingY = Math.abs(Math.round(rect.y) - y) > 0.5 ? 1 : 0;
    width += offset * 2 + extraPaddingX;
    height += offset * 2 + extraPaddingY;
    x -= offset;
    y -= offset;
    const cachedSceneCanvas = new SceneCanvas({
      pixelRatio,
      width,
      height
    }), cachedFilterCanvas = new SceneCanvas({
      pixelRatio,
      width: 0,
      height: 0,
      willReadFrequently: true
    }), cachedHitCanvas = new HitCanvas({
      pixelRatio: hitCanvasPixelRatio,
      width,
      height
    }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
    const bufferCanvas = new SceneCanvas({
      width: cachedSceneCanvas.width / cachedSceneCanvas.pixelRatio + Math.abs(x),
      height: cachedSceneCanvas.height / cachedSceneCanvas.pixelRatio + Math.abs(y),
      pixelRatio: cachedSceneCanvas.pixelRatio
    }), bufferContext = bufferCanvas.getContext();
    cachedHitCanvas.isCache = true;
    cachedSceneCanvas.isCache = true;
    this._cache.delete(CANVAS);
    this._filterUpToDate = false;
    if (conf.imageSmoothingEnabled === false) {
      cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
      cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
    }
    sceneContext.save();
    hitContext.save();
    bufferContext.save();
    sceneContext.translate(-x, -y);
    hitContext.translate(-x, -y);
    bufferContext.translate(-x, -y);
    bufferCanvas.x = x;
    bufferCanvas.y = y;
    this._isUnderCache = true;
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this.drawScene(cachedSceneCanvas, this, bufferCanvas);
    this.drawHit(cachedHitCanvas, this);
    this._isUnderCache = false;
    sceneContext.restore();
    hitContext.restore();
    if (drawBorder) {
      sceneContext.save();
      sceneContext.beginPath();
      sceneContext.rect(0, 0, width, height);
      sceneContext.closePath();
      sceneContext.setAttr("strokeStyle", "red");
      sceneContext.setAttr("lineWidth", 5);
      sceneContext.stroke();
      sceneContext.restore();
    }
    this._cache.set(CANVAS, {
      scene: cachedSceneCanvas,
      filter: cachedFilterCanvas,
      hit: cachedHitCanvas,
      buffer: bufferCanvas,
      x,
      y
    });
    this._requestDraw();
    return this;
  }
  isCached() {
    return this._cache.has(CANVAS);
  }
  getClientRect(config) {
    throw new Error('abstract "getClientRect" method call');
  }
  _transformedRect(rect, top) {
    const points = [
      { x: rect.x, y: rect.y },
      { x: rect.x + rect.width, y: rect.y },
      { x: rect.x + rect.width, y: rect.y + rect.height },
      { x: rect.x, y: rect.y + rect.height }
    ];
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const trans = this.getAbsoluteTransform(top);
    points.forEach(function(point) {
      const transformed = trans.point(point);
      if (minX === void 0) {
        minX = maxX = transformed.x;
        minY = maxY = transformed.y;
      }
      minX = Math.min(minX, transformed.x);
      minY = Math.min(minY, transformed.y);
      maxX = Math.max(maxX, transformed.x);
      maxY = Math.max(maxY, transformed.y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  _drawCachedSceneCanvas(context) {
    context.save();
    context._applyOpacity(this);
    context._applyGlobalCompositeOperation(this);
    const canvasCache = this._getCanvasCache();
    context.translate(canvasCache.x, canvasCache.y);
    const cacheCanvas = this._getCachedSceneCanvas();
    const ratio = cacheCanvas.pixelRatio;
    context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
    context.restore();
  }
  _drawCachedHitCanvas(context) {
    const canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
    context.save();
    context.translate(canvasCache.x, canvasCache.y);
    context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio);
    context.restore();
  }
  _getCachedSceneCanvas() {
    let filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
    if (!filters || filters.length === 0) {
      return sceneCanvas;
    }
    if (this._filterUpToDate) {
      return filterCanvas;
    }
    let useNativeOnly = true;
    for (let i = 0; i < filters.length; i++) {
      const fallbackRequired = typeof filters[i] === "string" && !isCSSFiltersSupported();
      if (fallbackRequired) {
      }
      if (typeof filters[i] !== "string" || !isCSSFiltersSupported()) {
        useNativeOnly = false;
        break;
      }
    }
    const ratio = sceneCanvas.pixelRatio;
    filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
    if (useNativeOnly) {
      const finalFilter = filters.join(" ");
      filterContext.save();
      filterContext.setAttr("filter", finalFilter);
      filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
      filterContext.restore();
      this._filterUpToDate = true;
      return filterCanvas;
    }
    try {
      len = filters.length;
      filterContext.clear();
      filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
      imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
      for (n = 0; n < len; n++) {
        filter = filters[n];
        if (typeof filter === "string") {
          filter = parseCSSFilters(filter);
        }
        filter.call(this, imageData);
        filterContext.putImageData(imageData, 0, 0);
      }
    } catch (e) {
      Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
    }
    this._filterUpToDate = true;
    return filterCanvas;
  }
  on(evtStr, handler) {
    if (this._cache) {
      this._cache.delete(ALL_LISTENERS);
    }
    if (arguments.length === 3) {
      return this._delegate.apply(this, arguments);
    }
    const events2 = evtStr.split(SPACE);
    for (let n = 0; n < events2.length; n++) {
      const event = events2[n];
      const parts = event.split(".");
      const baseEvent = parts[0];
      const name = parts[1] || "";
      if (!this.eventListeners[baseEvent]) {
        this.eventListeners[baseEvent] = [];
      }
      this.eventListeners[baseEvent].push({ name, handler });
    }
    return this;
  }
  off(evtStr, callback) {
    let events2 = (evtStr || "").split(SPACE), len = events2.length, n, t, event, parts, baseEvent, name;
    this._cache && this._cache.delete(ALL_LISTENERS);
    if (!evtStr) {
      for (t in this.eventListeners) {
        this._off(t);
      }
    }
    for (n = 0; n < len; n++) {
      event = events2[n];
      parts = event.split(".");
      baseEvent = parts[0];
      name = parts[1];
      if (baseEvent) {
        if (this.eventListeners[baseEvent]) {
          this._off(baseEvent, name, callback);
        }
      } else {
        for (t in this.eventListeners) {
          this._off(t, name, callback);
        }
      }
    }
    return this;
  }
  dispatchEvent(evt) {
    const e = {
      target: this,
      type: evt.type,
      evt
    };
    this.fire(evt.type, e);
    return this;
  }
  addEventListener(type, handler) {
    this.on(type, function(evt) {
      handler.call(this, evt.evt);
    });
    return this;
  }
  removeEventListener(type) {
    this.off(type);
    return this;
  }
  _delegate(event, selector, handler) {
    const stopNode = this;
    this.on(event, function(evt) {
      const targets = evt.target.findAncestors(selector, true, stopNode);
      for (let i = 0; i < targets.length; i++) {
        evt = Util.cloneObject(evt);
        evt.currentTarget = targets[i];
        handler.call(targets[i], evt);
      }
    });
  }
  remove() {
    if (this.isDragging()) {
      this.stopDrag();
    }
    DD._dragElements.delete(this._id);
    this._remove();
    return this;
  }
  _clearCaches() {
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
    this._clearSelfAndDescendantCache(STAGE);
    this._clearSelfAndDescendantCache(VISIBLE);
    this._clearSelfAndDescendantCache(LISTENING);
  }
  _remove() {
    this._clearCaches();
    const parent = this.getParent();
    if (parent && parent.children) {
      parent.children.splice(this.index, 1);
      parent._setChildrenIndices();
      this.parent = null;
    }
  }
  destroy() {
    this.remove();
    this.clearCache();
    return this;
  }
  getAttr(attr) {
    const method = "get" + Util._capitalize(attr);
    if (Util._isFunction(this[method])) {
      return this[method]();
    }
    return this.attrs[attr];
  }
  getAncestors() {
    let parent = this.getParent(), ancestors = [];
    while (parent) {
      ancestors.push(parent);
      parent = parent.getParent();
    }
    return ancestors;
  }
  getAttrs() {
    return this.attrs || {};
  }
  setAttrs(config) {
    this._batchTransformChanges(() => {
      let key, method;
      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method = SET2 + Util._capitalize(key);
        if (Util._isFunction(this[method])) {
          this[method](config[key]);
        } else {
          this._setAttr(key, config[key]);
        }
      }
    });
    return this;
  }
  isListening() {
    return this._getCache(LISTENING, this._isListening);
  }
  _isListening(relativeTo) {
    const listening = this.listening();
    if (!listening) {
      return false;
    }
    const parent = this.getParent();
    if (parent && parent !== relativeTo && this !== relativeTo) {
      return parent._isListening(relativeTo);
    } else {
      return true;
    }
  }
  isVisible() {
    return this._getCache(VISIBLE, this._isVisible);
  }
  _isVisible(relativeTo) {
    const visible = this.visible();
    if (!visible) {
      return false;
    }
    const parent = this.getParent();
    if (parent && parent !== relativeTo && this !== relativeTo) {
      return parent._isVisible(relativeTo);
    } else {
      return true;
    }
  }
  shouldDrawHit(top, skipDragCheck = false) {
    if (top) {
      return this._isVisible(top) && this._isListening(top);
    }
    const layer = this.getLayer();
    let layerUnderDrag = false;
    DD._dragElements.forEach((elem) => {
      if (elem.dragStatus !== "dragging") {
        return;
      } else if (elem.node.nodeType === "Stage") {
        layerUnderDrag = true;
      } else if (elem.node.getLayer() === layer) {
        layerUnderDrag = true;
      }
    });
    const dragSkip = !skipDragCheck && !Konva.hitOnDragEnabled && (layerUnderDrag || Konva.isTransforming());
    return this.isListening() && this.isVisible() && !dragSkip;
  }
  show() {
    this.visible(true);
    return this;
  }
  hide() {
    this.visible(false);
    return this;
  }
  getZIndex() {
    return this.index || 0;
  }
  getAbsoluteZIndex() {
    let depth = this.getDepth(), that = this, index = 0, nodes2, len, n, child;
    function addChildren(children) {
      nodes2 = [];
      len = children.length;
      for (n = 0; n < len; n++) {
        child = children[n];
        index++;
        if (child.nodeType !== SHAPE) {
          nodes2 = nodes2.concat(child.getChildren().slice());
        }
        if (child._id === that._id) {
          n = len;
        }
      }
      if (nodes2.length > 0 && nodes2[0].getDepth() <= depth) {
        addChildren(nodes2);
      }
    }
    const stage = this.getStage();
    if (that.nodeType !== UPPER_STAGE && stage) {
      addChildren(stage.getChildren());
    }
    return index;
  }
  getDepth() {
    let depth = 0, parent = this.parent;
    while (parent) {
      depth++;
      parent = parent.parent;
    }
    return depth;
  }
  _batchTransformChanges(func) {
    this._batchingTransformChange = true;
    func();
    this._batchingTransformChange = false;
    if (this._needClearTransformCache) {
      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    }
    this._needClearTransformCache = false;
  }
  setPosition(pos) {
    this._batchTransformChanges(() => {
      this.x(pos.x);
      this.y(pos.y);
    });
    return this;
  }
  getPosition() {
    return {
      x: this.x(),
      y: this.y()
    };
  }
  getRelativePointerPosition() {
    const stage = this.getStage();
    if (!stage) {
      return null;
    }
    const pos = stage.getPointerPosition();
    if (!pos) {
      return null;
    }
    const transform = this.getAbsoluteTransform().copy();
    transform.invert();
    return transform.point(pos);
  }
  getAbsolutePosition(top) {
    let haveCachedParent = false;
    let parent = this.parent;
    while (parent) {
      if (parent.isCached()) {
        haveCachedParent = true;
        break;
      }
      parent = parent.parent;
    }
    if (haveCachedParent && !top) {
      top = true;
    }
    const absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Transform(), offset = this.offset();
    absoluteTransform.m = absoluteMatrix.slice();
    absoluteTransform.translate(offset.x, offset.y);
    return absoluteTransform.getTranslation();
  }
  setAbsolutePosition(pos) {
    const { x, y, ...origTrans } = this._clearTransform();
    this.attrs.x = x;
    this.attrs.y = y;
    this._clearCache(TRANSFORM);
    const it = this._getAbsoluteTransform().copy();
    it.invert();
    it.translate(pos.x, pos.y);
    pos = {
      x: this.attrs.x + it.getTranslation().x,
      y: this.attrs.y + it.getTranslation().y
    };
    this._setTransform(origTrans);
    this.setPosition({ x: pos.x, y: pos.y });
    this._clearCache(TRANSFORM);
    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    return this;
  }
  _setTransform(trans) {
    let key;
    for (key in trans) {
      this.attrs[key] = trans[key];
    }
  }
  _clearTransform() {
    const trans = {
      x: this.x(),
      y: this.y(),
      rotation: this.rotation(),
      scaleX: this.scaleX(),
      scaleY: this.scaleY(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY(),
      skewX: this.skewX(),
      skewY: this.skewY()
    };
    this.attrs.x = 0;
    this.attrs.y = 0;
    this.attrs.rotation = 0;
    this.attrs.scaleX = 1;
    this.attrs.scaleY = 1;
    this.attrs.offsetX = 0;
    this.attrs.offsetY = 0;
    this.attrs.skewX = 0;
    this.attrs.skewY = 0;
    return trans;
  }
  move(change) {
    let changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
    if (changeX !== void 0) {
      x += changeX;
    }
    if (changeY !== void 0) {
      y += changeY;
    }
    this.setPosition({ x, y });
    return this;
  }
  _eachAncestorReverse(func, top) {
    let family = [], parent = this.getParent(), len, n;
    if (top && top._id === this._id) {
      return;
    }
    family.unshift(this);
    while (parent && (!top || parent._id !== top._id)) {
      family.unshift(parent);
      parent = parent.parent;
    }
    len = family.length;
    for (n = 0; n < len; n++) {
      func(family[n]);
    }
  }
  rotate(theta) {
    this.rotation(this.rotation() + theta);
    return this;
  }
  moveToTop() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveToTop function is ignored.");
      return false;
    }
    const index = this.index, len = this.parent.getChildren().length;
    if (index < len - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveUp() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveUp function is ignored.");
      return false;
    }
    const index = this.index, len = this.parent.getChildren().length;
    if (index < len - 1) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index + 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveDown() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveDown function is ignored.");
      return false;
    }
    const index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.splice(index - 1, 0, this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (!this.parent) {
      Util.warn("Node has no parent. moveToBottom function is ignored.");
      return false;
    }
    const index = this.index;
    if (index > 0) {
      this.parent.children.splice(index, 1);
      this.parent.children.unshift(this);
      this.parent._setChildrenIndices();
      return true;
    }
    return false;
  }
  setZIndex(zIndex) {
    if (!this.parent) {
      Util.warn("Node has no parent. zIndex parameter is ignored.");
      return this;
    }
    if (zIndex < 0 || zIndex >= this.parent.children.length) {
      Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
    }
    const index = this.index;
    this.parent.children.splice(index, 1);
    this.parent.children.splice(zIndex, 0, this);
    this.parent._setChildrenIndices();
    return this;
  }
  getAbsoluteOpacity() {
    return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
  }
  _getAbsoluteOpacity() {
    let absOpacity = this.opacity();
    const parent = this.getParent();
    if (parent && !parent._isUnderCache) {
      absOpacity *= parent.getAbsoluteOpacity();
    }
    return absOpacity;
  }
  moveTo(newContainer) {
    if (this.getParent() !== newContainer) {
      this._remove();
      newContainer.add(this);
    }
    return this;
  }
  toObject() {
    let attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
    const obj = {
      attrs: {},
      className: this.getClassName()
    };
    for (key in attrs) {
      val = attrs[key];
      nonPlainObject = Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val);
      if (nonPlainObject) {
        continue;
      }
      getter = typeof this[key] === "function" && this[key];
      delete attrs[key];
      defaultValue = getter ? getter.call(this) : null;
      attrs[key] = val;
      if (defaultValue !== val) {
        obj.attrs[key] = val;
      }
    }
    return Util._prepareToStringify(obj);
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  getParent() {
    return this.parent;
  }
  findAncestors(selector, includeSelf, stopNode) {
    const res = [];
    if (includeSelf && this._isMatch(selector)) {
      res.push(this);
    }
    let ancestor = this.parent;
    while (ancestor) {
      if (ancestor === stopNode) {
        return res;
      }
      if (ancestor._isMatch(selector)) {
        res.push(ancestor);
      }
      ancestor = ancestor.parent;
    }
    return res;
  }
  isAncestorOf(node) {
    return false;
  }
  findAncestor(selector, includeSelf, stopNode) {
    return this.findAncestors(selector, includeSelf, stopNode)[0];
  }
  _isMatch(selector) {
    if (!selector) {
      return false;
    }
    if (typeof selector === "function") {
      return selector(this);
    }
    let selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
    for (n = 0; n < len; n++) {
      sel = selectorArr[n];
      if (!Util.isValidSelector(sel)) {
        Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
        Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
        Util.warn("Konva is awesome, right?");
      }
      if (sel.charAt(0) === "#") {
        if (this.id() === sel.slice(1)) {
          return true;
        }
      } else if (sel.charAt(0) === ".") {
        if (this.hasName(sel.slice(1))) {
          return true;
        }
      } else if (this.className === sel || this.nodeType === sel) {
        return true;
      }
    }
    return false;
  }
  getLayer() {
    const parent = this.getParent();
    return parent ? parent.getLayer() : null;
  }
  getStage() {
    return this._getCache(STAGE, this._getStage);
  }
  _getStage() {
    const parent = this.getParent();
    if (parent) {
      return parent.getStage();
    } else {
      return null;
    }
  }
  fire(eventType, evt = {}, bubble) {
    evt.target = evt.target || this;
    if (bubble) {
      this._fireAndBubble(eventType, evt);
    } else {
      this._fire(eventType, evt);
    }
    return this;
  }
  getAbsoluteTransform(top) {
    if (top) {
      return this._getAbsoluteTransform(top);
    } else {
      return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
    }
  }
  _getAbsoluteTransform(top) {
    let at;
    if (top) {
      at = new Transform();
      this._eachAncestorReverse(function(node) {
        const transformsEnabled = node.transformsEnabled();
        if (transformsEnabled === "all") {
          at.multiply(node.getTransform());
        } else if (transformsEnabled === "position") {
          at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
        }
      }, top);
      return at;
    } else {
      at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform();
      if (this.parent) {
        this.parent.getAbsoluteTransform().copyInto(at);
      } else {
        at.reset();
      }
      const transformsEnabled = this.transformsEnabled();
      if (transformsEnabled === "all") {
        at.multiply(this.getTransform());
      } else if (transformsEnabled === "position") {
        const x = this.attrs.x || 0;
        const y = this.attrs.y || 0;
        const offsetX = this.attrs.offsetX || 0;
        const offsetY = this.attrs.offsetY || 0;
        at.translate(x - offsetX, y - offsetY);
      }
      at.dirty = false;
      return at;
    }
  }
  getAbsoluteScale(top) {
    let parent = this;
    while (parent) {
      if (parent._isUnderCache) {
        top = parent;
      }
      parent = parent.getParent();
    }
    const transform = this.getAbsoluteTransform(top);
    const attrs = transform.decompose();
    return {
      x: attrs.scaleX,
      y: attrs.scaleY
    };
  }
  getAbsoluteRotation() {
    return this.getAbsoluteTransform().decompose().rotation;
  }
  getTransform() {
    return this._getCache(TRANSFORM, this._getTransform);
  }
  _getTransform() {
    var _a, _b;
    const m = this._cache.get(TRANSFORM) || new Transform();
    m.reset();
    const x = this.x(), y = this.y(), rotation = Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
    if (x !== 0 || y !== 0) {
      m.translate(x, y);
    }
    if (rotation !== 0) {
      m.rotate(rotation);
    }
    if (skewX !== 0 || skewY !== 0) {
      m.skew(skewX, skewY);
    }
    if (scaleX !== 1 || scaleY !== 1) {
      m.scale(scaleX, scaleY);
    }
    if (offsetX !== 0 || offsetY !== 0) {
      m.translate(-1 * offsetX, -1 * offsetY);
    }
    m.dirty = false;
    return m;
  }
  clone(obj) {
    let attrs = Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
    for (key in obj) {
      attrs[key] = obj[key];
    }
    const node = new this.constructor(attrs);
    for (key in this.eventListeners) {
      allListeners = this.eventListeners[key];
      len = allListeners.length;
      for (n = 0; n < len; n++) {
        listener = allListeners[n];
        if (listener.name.indexOf(KONVA) < 0) {
          if (!node.eventListeners[key]) {
            node.eventListeners[key] = [];
          }
          node.eventListeners[key].push(listener);
        }
      }
    }
    return node;
  }
  _toKonvaCanvas(config) {
    config = config || {};
    const box = this.getClientRect();
    const stage = this.getStage(), x = config.x !== void 0 ? config.x : Math.floor(box.x), y = config.y !== void 0 ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new SceneCanvas({
      width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
      height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
      pixelRatio
    }), context = canvas.getContext();
    const bufferCanvas = new SceneCanvas({
      width: canvas.width / canvas.pixelRatio + Math.abs(x),
      height: canvas.height / canvas.pixelRatio + Math.abs(y),
      pixelRatio: canvas.pixelRatio
    });
    if (config.imageSmoothingEnabled === false) {
      context._context.imageSmoothingEnabled = false;
    }
    context.save();
    if (x || y) {
      context.translate(-1 * x, -1 * y);
    }
    this.drawScene(canvas, void 0, bufferCanvas);
    context.restore();
    return canvas;
  }
  toCanvas(config) {
    return this._toKonvaCanvas(config)._canvas;
  }
  toDataURL(config) {
    config = config || {};
    const mimeType = config.mimeType || null, quality = config.quality || null;
    const url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
    if (config.callback) {
      config.callback(url);
    }
    return url;
  }
  toImage(config) {
    return new Promise((resolve, reject) => {
      try {
        const callback = config === null || config === void 0 ? void 0 : config.callback;
        if (callback)
          delete config.callback;
        Util._urlToImage(this.toDataURL(config), function(img) {
          resolve(img);
          callback === null || callback === void 0 ? void 0 : callback(img);
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  toBlob(config) {
    return new Promise((resolve, reject) => {
      try {
        const callback = config === null || config === void 0 ? void 0 : config.callback;
        if (callback)
          delete config.callback;
        this.toCanvas(config).toBlob((blob) => {
          resolve(blob);
          callback === null || callback === void 0 ? void 0 : callback(blob);
        }, config === null || config === void 0 ? void 0 : config.mimeType, config === null || config === void 0 ? void 0 : config.quality);
      } catch (err) {
        reject(err);
      }
    });
  }
  setSize(size) {
    this.width(size.width);
    this.height(size.height);
    return this;
  }
  getSize() {
    return {
      width: this.width(),
      height: this.height()
    };
  }
  getClassName() {
    return this.className || this.nodeType;
  }
  getType() {
    return this.nodeType;
  }
  getDragDistance() {
    if (this.attrs.dragDistance !== void 0) {
      return this.attrs.dragDistance;
    } else if (this.parent) {
      return this.parent.getDragDistance();
    } else {
      return Konva.dragDistance;
    }
  }
  _off(type, name, callback) {
    let evtListeners = this.eventListeners[type], i, evtName, handler;
    for (i = 0; i < evtListeners.length; i++) {
      evtName = evtListeners[i].name;
      handler = evtListeners[i].handler;
      if ((evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
        evtListeners.splice(i, 1);
        if (evtListeners.length === 0) {
          delete this.eventListeners[type];
          break;
        }
        i--;
      }
    }
  }
  _fireChangeEvent(attr, oldVal, newVal) {
    this._fire(attr + CHANGE, {
      oldVal,
      newVal
    });
  }
  addName(name) {
    if (!this.hasName(name)) {
      const oldName = this.name();
      const newName = oldName ? oldName + " " + name : name;
      this.name(newName);
    }
    return this;
  }
  hasName(name) {
    if (!name) {
      return false;
    }
    const fullName = this.name();
    if (!fullName) {
      return false;
    }
    const names = (fullName || "").split(/\s/g);
    return names.indexOf(name) !== -1;
  }
  removeName(name) {
    const names = (this.name() || "").split(/\s/g);
    const index = names.indexOf(name);
    if (index !== -1) {
      names.splice(index, 1);
      this.name(names.join(" "));
    }
    return this;
  }
  setAttr(attr, val) {
    const func = this[SET2 + Util._capitalize(attr)];
    if (Util._isFunction(func)) {
      func.call(this, val);
    } else {
      this._setAttr(attr, val);
    }
    return this;
  }
  _requestDraw() {
    if (Konva.autoDrawEnabled) {
      const drawNode = this.getLayer() || this.getStage();
      drawNode === null || drawNode === void 0 ? void 0 : drawNode.batchDraw();
    }
  }
  _setAttr(key, val) {
    const oldVal = this.attrs[key];
    if (oldVal === val && !Util.isObject(val)) {
      return;
    }
    if (val === void 0 || val === null) {
      delete this.attrs[key];
    } else {
      this.attrs[key] = val;
    }
    if (this._shouldFireChangeEvents) {
      this._fireChangeEvent(key, oldVal, val);
    }
    this._requestDraw();
  }
  _setComponentAttr(key, component, val) {
    let oldVal;
    if (val !== void 0) {
      oldVal = this.attrs[key];
      if (!oldVal) {
        this.attrs[key] = this.getAttr(key);
      }
      this.attrs[key][component] = val;
      this._fireChangeEvent(key, oldVal, val);
    }
  }
  _fireAndBubble(eventType, evt, compareShape) {
    if (evt && this.nodeType === SHAPE) {
      evt.target = this;
    }
    const nonBubbling = [
      MOUSEENTER,
      MOUSELEAVE,
      POINTERENTER,
      POINTERLEAVE,
      TOUCHENTER,
      TOUCHLEAVE
    ];
    const shouldStop = nonBubbling.indexOf(eventType) !== -1 && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
    if (!shouldStop) {
      this._fire(eventType, evt);
      const stopBubble = nonBubbling.indexOf(eventType) !== -1 && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
      if ((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble) {
        if (compareShape && compareShape.parent) {
          this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
        } else {
          this._fireAndBubble.call(this.parent, eventType, evt);
        }
      }
    }
  }
  _getProtoListeners(eventType) {
    var _a, _b, _c;
    const allListeners = (_a = this._cache.get(ALL_LISTENERS)) !== null && _a !== void 0 ? _a : {};
    let events2 = allListeners === null || allListeners === void 0 ? void 0 : allListeners[eventType];
    if (events2 === void 0) {
      events2 = [];
      let obj = Object.getPrototypeOf(this);
      while (obj) {
        const hierarchyEvents = (_c = (_b = obj.eventListeners) === null || _b === void 0 ? void 0 : _b[eventType]) !== null && _c !== void 0 ? _c : [];
        events2.push(...hierarchyEvents);
        obj = Object.getPrototypeOf(obj);
      }
      allListeners[eventType] = events2;
      this._cache.set(ALL_LISTENERS, allListeners);
    }
    return events2;
  }
  _fire(eventType, evt) {
    evt = evt || {};
    evt.currentTarget = this;
    evt.type = eventType;
    const topListeners = this._getProtoListeners(eventType);
    if (topListeners) {
      for (let i = 0; i < topListeners.length; i++) {
        topListeners[i].handler.call(this, evt);
      }
    }
    const selfListeners = this.eventListeners[eventType];
    if (selfListeners) {
      for (let i = 0; i < selfListeners.length; i++) {
        selfListeners[i].handler.call(this, evt);
      }
    }
  }
  draw() {
    this.drawScene();
    this.drawHit();
    return this;
  }
  _createDragElement(evt) {
    const pointerId = evt ? evt.pointerId : void 0;
    const stage = this.getStage();
    const ap = this.getAbsolutePosition();
    if (!stage) {
      return;
    }
    const pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;
    DD._dragElements.set(this._id, {
      node: this,
      startPointerPos: pos,
      offset: {
        x: pos.x - ap.x,
        y: pos.y - ap.y
      },
      dragStatus: "ready",
      pointerId
    });
  }
  startDrag(evt, bubbleEvent = true) {
    if (!DD._dragElements.has(this._id)) {
      this._createDragElement(evt);
    }
    const elem = DD._dragElements.get(this._id);
    elem.dragStatus = "dragging";
    this.fire("dragstart", {
      type: "dragstart",
      target: this,
      evt: evt && evt.evt
    }, bubbleEvent);
  }
  _setDragPosition(evt, elem) {
    const pos = this.getStage()._getPointerById(elem.pointerId);
    if (!pos) {
      return;
    }
    let newNodePos = {
      x: pos.x - elem.offset.x,
      y: pos.y - elem.offset.y
    };
    const dbf = this.dragBoundFunc();
    if (dbf !== void 0) {
      const bounded = dbf.call(this, newNodePos, evt);
      if (!bounded) {
        Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      } else {
        newNodePos = bounded;
      }
    }
    if (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) {
      this.setAbsolutePosition(newNodePos);
      this._requestDraw();
    }
    this._lastPos = newNodePos;
  }
  stopDrag(evt) {
    const elem = DD._dragElements.get(this._id);
    if (elem) {
      elem.dragStatus = "stopped";
    }
    DD._endDragBefore(evt);
    DD._endDragAfter(evt);
  }
  setDraggable(draggable) {
    this._setAttr("draggable", draggable);
    this._dragChange();
  }
  isDragging() {
    const elem = DD._dragElements.get(this._id);
    return elem ? elem.dragStatus === "dragging" : false;
  }
  _listenDrag() {
    this._dragCleanup();
    this.on("mousedown.konva touchstart.konva", function(evt) {
      const shouldCheckButton = evt.evt["button"] !== void 0;
      const canDrag = !shouldCheckButton || Konva.dragButtons.indexOf(evt.evt["button"]) >= 0;
      if (!canDrag) {
        return;
      }
      if (this.isDragging()) {
        return;
      }
      let hasDraggingChild = false;
      DD._dragElements.forEach((elem) => {
        if (this.isAncestorOf(elem.node)) {
          hasDraggingChild = true;
        }
      });
      if (!hasDraggingChild) {
        this._createDragElement(evt);
      }
    });
  }
  _dragChange() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      this._dragCleanup();
      const stage = this.getStage();
      if (!stage) {
        return;
      }
      const dragElement = DD._dragElements.get(this._id);
      const isDragging = dragElement && dragElement.dragStatus === "dragging";
      const isReady = dragElement && dragElement.dragStatus === "ready";
      if (isDragging) {
        this.stopDrag();
      } else if (isReady) {
        DD._dragElements.delete(this._id);
      }
    }
  }
  _dragCleanup() {
    this.off("mousedown.konva");
    this.off("touchstart.konva");
  }
  isClientRectOnScreen(margin = { x: 0, y: 0 }) {
    const stage = this.getStage();
    if (!stage) {
      return false;
    }
    const screenRect = {
      x: -margin.x,
      y: -margin.y,
      width: stage.width() + 2 * margin.x,
      height: stage.height() + 2 * margin.y
    };
    return Util.haveIntersection(screenRect, this.getClientRect());
  }
  static create(data, container) {
    if (Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  }
  static _createNode(obj, container) {
    let className = _Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;
    if (container) {
      obj.attrs.container = container;
    }
    if (!Konva[className]) {
      Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".');
      className = "Shape";
    }
    const Class = Konva[className];
    no = new Class(obj.attrs);
    if (children) {
      len = children.length;
      for (n = 0; n < len; n++) {
        no.add(_Node._createNode(children[n]));
      }
    }
    return no;
  }
};
Node.prototype.nodeType = "Node";
Node.prototype._attrsAffectingSize = [];
Node.prototype.eventListeners = {};
Node.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function() {
  if (this._batchingTransformChange) {
    this._needClearTransformCache = true;
    return;
  }
  this._clearCache(TRANSFORM);
  this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
});
Node.prototype.on.call(Node.prototype, "visibleChange.konva", function() {
  this._clearSelfAndDescendantCache(VISIBLE);
});
Node.prototype.on.call(Node.prototype, "listeningChange.konva", function() {
  this._clearSelfAndDescendantCache(LISTENING);
});
Node.prototype.on.call(Node.prototype, "opacityChange.konva", function() {
  this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
});
var addGetterSetter = Factory.addGetterSetter;
addGetterSetter(Node, "zIndex");
addGetterSetter(Node, "absolutePosition");
addGetterSetter(Node, "position");
addGetterSetter(Node, "x", 0, getNumberValidator());
addGetterSetter(Node, "y", 0, getNumberValidator());
addGetterSetter(Node, "globalCompositeOperation", "source-over", getStringValidator());
addGetterSetter(Node, "opacity", 1, getNumberValidator());
addGetterSetter(Node, "name", "", getStringValidator());
addGetterSetter(Node, "id", "", getStringValidator());
addGetterSetter(Node, "rotation", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Node, "scale", ["x", "y"]);
addGetterSetter(Node, "scaleX", 1, getNumberValidator());
addGetterSetter(Node, "scaleY", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Node, "skew", ["x", "y"]);
addGetterSetter(Node, "skewX", 0, getNumberValidator());
addGetterSetter(Node, "skewY", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Node, "offset", ["x", "y"]);
addGetterSetter(Node, "offsetX", 0, getNumberValidator());
addGetterSetter(Node, "offsetY", 0, getNumberValidator());
addGetterSetter(Node, "dragDistance", void 0, getNumberValidator());
addGetterSetter(Node, "width", 0, getNumberValidator());
addGetterSetter(Node, "height", 0, getNumberValidator());
addGetterSetter(Node, "listening", true, getBooleanValidator());
addGetterSetter(Node, "preventDefault", true, getBooleanValidator());
addGetterSetter(Node, "filters", void 0, function(val) {
  this._filterUpToDate = false;
  return val;
});
addGetterSetter(Node, "visible", true, getBooleanValidator());
addGetterSetter(Node, "transformsEnabled", "all", getStringValidator());
addGetterSetter(Node, "size");
addGetterSetter(Node, "dragBoundFunc");
addGetterSetter(Node, "draggable", false, getBooleanValidator());
Factory.backCompat(Node, {
  rotateDeg: "rotate",
  setRotationDeg: "setRotation",
  getRotationDeg: "getRotation"
});

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Container.js
var Container = class extends Node {
  constructor() {
    super(...arguments);
    this.children = [];
  }
  getChildren(filterFunc) {
    const children = this.children || [];
    if (filterFunc) {
      return children.filter(filterFunc);
    }
    return children;
  }
  hasChildren() {
    return this.getChildren().length > 0;
  }
  removeChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.remove();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  destroyChildren() {
    this.getChildren().forEach((child) => {
      child.parent = null;
      child.index = 0;
      child.destroy();
    });
    this.children = [];
    this._requestDraw();
    return this;
  }
  add(...children) {
    if (children.length === 0) {
      return this;
    }
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.add(children[i]);
      }
      return this;
    }
    const child = children[0];
    if (child.getParent()) {
      child.moveTo(this);
      return this;
    }
    this._validateAdd(child);
    child.index = this.getChildren().length;
    child.parent = this;
    child._clearCaches();
    this.getChildren().push(child);
    this._fire("add", {
      child
    });
    this._requestDraw();
    return this;
  }
  destroy() {
    if (this.hasChildren()) {
      this.destroyChildren();
    }
    super.destroy();
    return this;
  }
  find(selector) {
    return this._generalFind(selector, false);
  }
  findOne(selector) {
    const result = this._generalFind(selector, true);
    return result.length > 0 ? result[0] : void 0;
  }
  _generalFind(selector, findOne) {
    const retArr = [];
    this._descendants((node) => {
      const valid = node._isMatch(selector);
      if (valid) {
        retArr.push(node);
      }
      if (valid && findOne) {
        return true;
      }
      return false;
    });
    return retArr;
  }
  _descendants(fn) {
    let shouldStop = false;
    const children = this.getChildren();
    for (const child of children) {
      shouldStop = fn(child);
      if (shouldStop) {
        return true;
      }
      if (!child.hasChildren()) {
        continue;
      }
      shouldStop = child._descendants(fn);
      if (shouldStop) {
        return true;
      }
    }
    return false;
  }
  toObject() {
    const obj = Node.prototype.toObject.call(this);
    obj.children = [];
    this.getChildren().forEach((child) => {
      obj.children.push(child.toObject());
    });
    return obj;
  }
  isAncestorOf(node) {
    let parent = node.getParent();
    while (parent) {
      if (parent._id === this._id) {
        return true;
      }
      parent = parent.getParent();
    }
    return false;
  }
  clone(obj) {
    const node = Node.prototype.clone.call(this, obj);
    this.getChildren().forEach(function(no) {
      node.add(no.clone());
    });
    return node;
  }
  getAllIntersections(pos) {
    const arr = [];
    this.find("Shape").forEach((shape) => {
      if (shape.isVisible() && shape.intersects(pos)) {
        arr.push(shape);
      }
    });
    return arr;
  }
  _clearSelfAndDescendantCache(attr) {
    var _a;
    super._clearSelfAndDescendantCache(attr);
    if (this.isCached()) {
      return;
    }
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(node) {
      node._clearSelfAndDescendantCache(attr);
    });
  }
  _setChildrenIndices() {
    var _a;
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child, n) {
      child.index = n;
    });
    this._requestDraw();
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
    const caching = canvas && canvas.isCache;
    if (!this.isVisible() && !caching) {
      return this;
    }
    if (cachedSceneCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedSceneCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawScene", canvas, top, bufferCanvas);
    }
    return this;
  }
  drawHit(can, top) {
    if (!this.shouldDrawHit(top)) {
      return this;
    }
    const layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
    if (cachedHitCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedHitCanvas(context);
      context.restore();
    } else {
      this._drawChildren("drawHit", canvas, top);
    }
    return this;
  }
  _drawChildren(drawMethod, canvas, top, bufferCanvas) {
    var _a;
    const context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = typeof clipWidth === "number" && typeof clipHeight === "number" || clipFunc;
    const selfCache = top === this;
    if (hasClip) {
      context.save();
      const transform = this.getAbsoluteTransform(top);
      let m = transform.getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      context.beginPath();
      let clipArgs;
      if (clipFunc) {
        clipArgs = clipFunc.call(this, context, this);
      } else {
        const clipX = this.clipX();
        const clipY = this.clipY();
        context.rect(clipX || 0, clipY || 0, clipWidth, clipHeight);
      }
      context.clip.apply(context, clipArgs);
      m = transform.copy().invert().getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
    const hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
    if (hasComposition) {
      context.save();
      context._applyGlobalCompositeOperation(this);
    }
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      child[drawMethod](canvas, top, bufferCanvas);
    });
    if (hasComposition) {
      context.restore();
    }
    if (hasClip) {
      context.restore();
    }
  }
  getClientRect(config = {}) {
    var _a;
    const skipTransform = config.skipTransform;
    const relativeTo = config.relativeTo;
    let minX, minY, maxX, maxY;
    let selfRect = {
      x: Infinity,
      y: Infinity,
      width: 0,
      height: 0
    };
    const that = this;
    (_a = this.children) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      if (!child.visible()) {
        return;
      }
      const rect = child.getClientRect({
        relativeTo: that,
        skipShadow: config.skipShadow,
        skipStroke: config.skipStroke
      });
      if (rect.width === 0 && rect.height === 0) {
        return;
      }
      if (minX === void 0) {
        minX = rect.x;
        minY = rect.y;
        maxX = rect.x + rect.width;
        maxY = rect.y + rect.height;
      } else {
        minX = Math.min(minX, rect.x);
        minY = Math.min(minY, rect.y);
        maxX = Math.max(maxX, rect.x + rect.width);
        maxY = Math.max(maxY, rect.y + rect.height);
      }
    });
    const shapes2 = this.find("Shape");
    let hasVisible = false;
    for (let i = 0; i < shapes2.length; i++) {
      const shape = shapes2[i];
      if (shape._isVisible(this)) {
        hasVisible = true;
        break;
      }
    }
    if (hasVisible && minX !== void 0) {
      selfRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    } else {
      selfRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (!skipTransform) {
      return this._transformedRect(selfRect, relativeTo);
    }
    return selfRect;
  }
};
Factory.addComponentsGetterSetter(Container, "clip", [
  "x",
  "y",
  "width",
  "height"
]);
Factory.addGetterSetter(Container, "clipX", void 0, getNumberValidator());
Factory.addGetterSetter(Container, "clipY", void 0, getNumberValidator());
Factory.addGetterSetter(Container, "clipWidth", void 0, getNumberValidator());
Factory.addGetterSetter(Container, "clipHeight", void 0, getNumberValidator());
Factory.addGetterSetter(Container, "clipFunc");

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/PointerEvents.js
var Captures = /* @__PURE__ */ new Map();
var SUPPORT_POINTER_EVENTS = Konva._global["PointerEvent"] !== void 0;
function getCapturedShape(pointerId) {
  return Captures.get(pointerId);
}
function createEvent(evt) {
  return {
    evt,
    pointerId: evt.pointerId
  };
}
function hasPointerCapture(pointerId, shape) {
  return Captures.get(pointerId) === shape;
}
function setPointerCapture(pointerId, shape) {
  releaseCapture(pointerId);
  const stage = shape.getStage();
  if (!stage)
    return;
  Captures.set(pointerId, shape);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture")));
  }
}
function releaseCapture(pointerId, target) {
  const shape = Captures.get(pointerId);
  if (!shape)
    return;
  const stage = shape.getStage();
  if (stage && stage.content) {
  }
  Captures.delete(pointerId);
  if (SUPPORT_POINTER_EVENTS) {
    shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
  }
}

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Stage.js
var STAGE2 = "Stage";
var STRING = "string";
var PX = "px";
var MOUSEOUT = "mouseout";
var MOUSELEAVE2 = "mouseleave";
var MOUSEOVER = "mouseover";
var MOUSEENTER2 = "mouseenter";
var MOUSEMOVE = "mousemove";
var MOUSEDOWN = "mousedown";
var MOUSEUP = "mouseup";
var POINTERMOVE = "pointermove";
var POINTERDOWN = "pointerdown";
var POINTERUP = "pointerup";
var POINTERCANCEL = "pointercancel";
var LOSTPOINTERCAPTURE = "lostpointercapture";
var POINTEROUT = "pointerout";
var POINTERLEAVE2 = "pointerleave";
var POINTEROVER = "pointerover";
var POINTERENTER2 = "pointerenter";
var CONTEXTMENU = "contextmenu";
var TOUCHSTART = "touchstart";
var TOUCHEND = "touchend";
var TOUCHMOVE = "touchmove";
var TOUCHCANCEL = "touchcancel";
var WHEEL = "wheel";
var MAX_LAYERS_NUMBER = 5;
var EVENTS = [
  [MOUSEENTER2, "_pointerenter"],
  [MOUSEDOWN, "_pointerdown"],
  [MOUSEMOVE, "_pointermove"],
  [MOUSEUP, "_pointerup"],
  [MOUSELEAVE2, "_pointerleave"],
  [TOUCHSTART, "_pointerdown"],
  [TOUCHMOVE, "_pointermove"],
  [TOUCHEND, "_pointerup"],
  [TOUCHCANCEL, "_pointercancel"],
  [MOUSEOVER, "_pointerover"],
  [WHEEL, "_wheel"],
  [CONTEXTMENU, "_contextmenu"],
  [POINTERDOWN, "_pointerdown"],
  [POINTERMOVE, "_pointermove"],
  [POINTERUP, "_pointerup"],
  [POINTERCANCEL, "_pointercancel"],
  [POINTERLEAVE2, "_pointerleave"],
  [LOSTPOINTERCAPTURE, "_lostpointercapture"]
];
var EVENTS_MAP = {
  mouse: {
    [POINTEROUT]: MOUSEOUT,
    [POINTERLEAVE2]: MOUSELEAVE2,
    [POINTEROVER]: MOUSEOVER,
    [POINTERENTER2]: MOUSEENTER2,
    [POINTERMOVE]: MOUSEMOVE,
    [POINTERDOWN]: MOUSEDOWN,
    [POINTERUP]: MOUSEUP,
    [POINTERCANCEL]: "mousecancel",
    pointerclick: "click",
    pointerdblclick: "dblclick"
  },
  touch: {
    [POINTEROUT]: "touchout",
    [POINTERLEAVE2]: "touchleave",
    [POINTEROVER]: "touchover",
    [POINTERENTER2]: "touchenter",
    [POINTERMOVE]: TOUCHMOVE,
    [POINTERDOWN]: TOUCHSTART,
    [POINTERUP]: TOUCHEND,
    [POINTERCANCEL]: TOUCHCANCEL,
    pointerclick: "tap",
    pointerdblclick: "dbltap"
  },
  pointer: {
    [POINTEROUT]: POINTEROUT,
    [POINTERLEAVE2]: POINTERLEAVE2,
    [POINTEROVER]: POINTEROVER,
    [POINTERENTER2]: POINTERENTER2,
    [POINTERMOVE]: POINTERMOVE,
    [POINTERDOWN]: POINTERDOWN,
    [POINTERUP]: POINTERUP,
    [POINTERCANCEL]: POINTERCANCEL,
    pointerclick: "pointerclick",
    pointerdblclick: "pointerdblclick"
  }
};
var getEventType = (type) => {
  if (type.indexOf("pointer") >= 0) {
    return "pointer";
  }
  if (type.indexOf("touch") >= 0) {
    return "touch";
  }
  return "mouse";
};
var getEventsMap = (eventType) => {
  const type = getEventType(eventType);
  if (type === "pointer") {
    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
  }
  if (type === "touch") {
    return EVENTS_MAP.touch;
  }
  if (type === "mouse") {
    return EVENTS_MAP.mouse;
  }
};
function checkNoClip(attrs = {}) {
  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
    Util.warn("Stage does not support clipping. Please use clip for Layers or Groups.");
  }
  return attrs;
}
var NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;
var stages = [];
var Stage = class extends Container {
  constructor(config) {
    super(checkNoClip(config));
    this._pointerPositions = [];
    this._changedPointerPositions = [];
    this._buildDOM();
    this._bindContentEvents();
    stages.push(this);
    this.on("widthChange.konva heightChange.konva", this._resizeDOM);
    this.on("visibleChange.konva", this._checkVisibility);
    this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
      checkNoClip(this.attrs);
    });
    this._checkVisibility();
  }
  _validateAdd(child) {
    const isLayer = child.getType() === "Layer";
    const isFastLayer = child.getType() === "FastLayer";
    const valid = isLayer || isFastLayer;
    if (!valid) {
      Util.throw("You may only add layers to the stage.");
    }
  }
  _checkVisibility() {
    if (!this.content) {
      return;
    }
    const style = this.visible() ? "" : "none";
    this.content.style.display = style;
  }
  setContainer(container) {
    if (typeof container === STRING) {
      let id;
      if (container.charAt(0) === ".") {
        const className = container.slice(1);
        container = document.getElementsByClassName(className)[0];
      } else {
        if (container.charAt(0) !== "#") {
          id = container;
        } else {
          id = container.slice(1);
        }
        container = document.getElementById(id);
      }
      if (!container) {
        throw "Can not find container in document with id " + id;
      }
    }
    this._setAttr("container", container);
    if (this.content) {
      if (this.content.parentElement) {
        this.content.parentElement.removeChild(this.content);
      }
      container.appendChild(this.content);
    }
    return this;
  }
  shouldDrawHit() {
    return true;
  }
  clear() {
    const layers = this.children, len = layers.length;
    for (let n = 0; n < len; n++) {
      layers[n].clear();
    }
    return this;
  }
  clone(obj) {
    if (!obj) {
      obj = {};
    }
    obj.container = typeof document !== "undefined" && document.createElement("div");
    return Container.prototype.clone.call(this, obj);
  }
  destroy() {
    super.destroy();
    const content = this.content;
    if (content && Util._isInDocument(content)) {
      this.container().removeChild(content);
    }
    const index = stages.indexOf(this);
    if (index > -1) {
      stages.splice(index, 1);
    }
    Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);
    return this;
  }
  getPointerPosition() {
    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];
    if (!pos) {
      Util.warn(NO_POINTERS_MESSAGE);
      return null;
    }
    return {
      x: pos.x,
      y: pos.y
    };
  }
  _getPointerById(id) {
    return this._pointerPositions.find((p) => p.id === id);
  }
  getPointersPositions() {
    return this._pointerPositions;
  }
  getStage() {
    return this;
  }
  getContent() {
    return this.content;
  }
  _toKonvaCanvas(config) {
    config = { ...config };
    config.x = config.x || 0;
    config.y = config.y || 0;
    config.width = config.width || this.width();
    config.height = config.height || this.height();
    const canvas = new SceneCanvas({
      width: config.width,
      height: config.height,
      pixelRatio: config.pixelRatio || 1
    });
    const _context = canvas.getContext()._context;
    const layers = this.children;
    if (config.x || config.y) {
      _context.translate(-1 * config.x, -1 * config.y);
    }
    layers.forEach(function(layer) {
      if (!layer.isVisible()) {
        return;
      }
      const layerCanvas = layer._toKonvaCanvas(config);
      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
    });
    return canvas;
  }
  getIntersection(pos) {
    if (!pos) {
      return null;
    }
    const layers = this.children, len = layers.length, end = len - 1;
    for (let n = end; n >= 0; n--) {
      const shape = layers[n].getIntersection(pos);
      if (shape) {
        return shape;
      }
    }
    return null;
  }
  _resizeDOM() {
    const width = this.width();
    const height = this.height();
    if (this.content) {
      this.content.style.width = width + PX;
      this.content.style.height = height + PX;
    }
    this.bufferCanvas.setSize(width, height);
    this.bufferHitCanvas.setSize(width, height);
    this.children.forEach((layer) => {
      layer.setSize({ width, height });
      layer.draw();
    });
  }
  add(layer, ...rest) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    super.add(layer);
    const length = this.children.length;
    if (length > MAX_LAYERS_NUMBER) {
      Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.");
    }
    layer.setSize({ width: this.width(), height: this.height() });
    layer.draw();
    if (Konva.isBrowser) {
      this.content.appendChild(layer.canvas._canvas);
    }
    return this;
  }
  getParent() {
    return null;
  }
  getLayer() {
    return null;
  }
  hasPointerCapture(pointerId) {
    return hasPointerCapture(pointerId, this);
  }
  setPointerCapture(pointerId) {
    setPointerCapture(pointerId, this);
  }
  releaseCapture(pointerId) {
    releaseCapture(pointerId, this);
  }
  getLayers() {
    return this.children;
  }
  _bindContentEvents() {
    if (!Konva.isBrowser) {
      return;
    }
    EVENTS.forEach(([event, methodName]) => {
      this.content.addEventListener(event, (evt) => {
        this[methodName](evt);
      }, { passive: false });
    });
  }
  _pointerenter(evt) {
    this.setPointersPositions(evt);
    const events2 = getEventsMap(evt.type);
    if (events2) {
      this._fire(events2.pointerenter, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _pointerover(evt) {
    this.setPointersPositions(evt);
    const events2 = getEventsMap(evt.type);
    if (events2) {
      this._fire(events2.pointerover, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _getTargetShape(evenType) {
    let shape = this[evenType + "targetShape"];
    if (shape && !shape.getStage()) {
      shape = null;
    }
    return shape;
  }
  _pointerleave(evt) {
    const events2 = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events2) {
      return;
    }
    this.setPointersPositions(evt);
    const targetShape = this._getTargetShape(eventType);
    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;
    if (targetShape && eventsEnabled) {
      targetShape._fireAndBubble(events2.pointerout, { evt });
      targetShape._fireAndBubble(events2.pointerleave, { evt });
      this._fire(events2.pointerleave, {
        evt,
        target: this,
        currentTarget: this
      });
      this[eventType + "targetShape"] = null;
    } else if (eventsEnabled) {
      this._fire(events2.pointerleave, {
        evt,
        target: this,
        currentTarget: this
      });
      this._fire(events2.pointerout, {
        evt,
        target: this,
        currentTarget: this
      });
    }
    this.pointerPos = null;
    this._pointerPositions = [];
  }
  _pointerdown(evt) {
    const events2 = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events2) {
      return;
    }
    this.setPointersPositions(evt);
    let triggeredOnShape = false;
    this._changedPointerPositions.forEach((pos) => {
      const shape = this.getIntersection(pos);
      DD.justDragged = false;
      Konva["_" + eventType + "ListenClick"] = true;
      if (!shape || !shape.isListening()) {
        this[eventType + "ClickStartShape"] = void 0;
        return;
      }
      if (Konva.capturePointerEventsEnabled) {
        shape.setPointerCapture(pos.id);
      }
      this[eventType + "ClickStartShape"] = shape;
      shape._fireAndBubble(events2.pointerdown, {
        evt,
        pointerId: pos.id
      });
      triggeredOnShape = true;
      const isTouch = evt.type.indexOf("touch") >= 0;
      if (shape.preventDefault() && evt.cancelable && isTouch) {
        evt.preventDefault();
      }
    });
    if (!triggeredOnShape) {
      this._fire(events2.pointerdown, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._pointerPositions[0].id
      });
    }
  }
  _pointermove(evt) {
    const events2 = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events2) {
      return;
    }
    const isTouchPointer = evt.type.indexOf("touch") >= 0 || evt.pointerType === "touch";
    if (Konva.isDragging() && DD.node.preventDefault() && evt.cancelable && isTouchPointer) {
      evt.preventDefault();
    }
    this.setPointersPositions(evt);
    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;
    if (!eventsEnabled) {
      return;
    }
    const processedShapesIds = {};
    let triggeredOnShape = false;
    const targetShape = this._getTargetShape(eventType);
    this._changedPointerPositions.forEach((pos) => {
      const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
      const pointerId = pos.id;
      const event = { evt, pointerId };
      const differentTarget = targetShape !== shape;
      if (differentTarget && targetShape) {
        targetShape._fireAndBubble(events2.pointerout, { ...event }, shape);
        targetShape._fireAndBubble(events2.pointerleave, { ...event }, shape);
      }
      if (shape) {
        if (processedShapesIds[shape._id]) {
          return;
        }
        processedShapesIds[shape._id] = true;
      }
      if (shape && shape.isListening()) {
        triggeredOnShape = true;
        if (differentTarget) {
          shape._fireAndBubble(events2.pointerover, { ...event }, targetShape);
          shape._fireAndBubble(events2.pointerenter, { ...event }, targetShape);
          this[eventType + "targetShape"] = shape;
        }
        shape._fireAndBubble(events2.pointermove, { ...event });
      } else {
        if (targetShape) {
          this._fire(events2.pointerover, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
          this[eventType + "targetShape"] = null;
        }
      }
    });
    if (!triggeredOnShape) {
      this._fire(events2.pointermove, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      });
    }
  }
  _pointerup(evt) {
    const events2 = getEventsMap(evt.type);
    const eventType = getEventType(evt.type);
    if (!events2) {
      return;
    }
    this.setPointersPositions(evt);
    const clickStartShape = this[eventType + "ClickStartShape"];
    const clickEndShape = this[eventType + "ClickEndShape"];
    const processedShapesIds = {};
    let skipPointerUpTrigger = false;
    this._changedPointerPositions.forEach((pos) => {
      const shape = getCapturedShape(pos.id) || this.getIntersection(pos);
      if (shape) {
        shape.releaseCapture(pos.id);
        if (processedShapesIds[shape._id]) {
          return;
        }
        processedShapesIds[shape._id] = true;
      }
      const pointerId = pos.id;
      const event = { evt, pointerId };
      let fireDblClick = false;
      if (Konva["_" + eventType + "InDblClickWindow"]) {
        fireDblClick = true;
        clearTimeout(this[eventType + "DblTimeout"]);
      } else if (!DD.justDragged) {
        Konva["_" + eventType + "InDblClickWindow"] = true;
        clearTimeout(this[eventType + "DblTimeout"]);
      }
      this[eventType + "DblTimeout"] = setTimeout(function() {
        Konva["_" + eventType + "InDblClickWindow"] = false;
      }, Konva.dblClickWindow);
      if (shape && shape.isListening()) {
        skipPointerUpTrigger = true;
        this[eventType + "ClickEndShape"] = shape;
        shape._fireAndBubble(events2.pointerup, { ...event });
        if (Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape) {
          shape._fireAndBubble(events2.pointerclick, { ...event });
          if (fireDblClick && clickEndShape && clickEndShape === shape) {
            shape._fireAndBubble(events2.pointerdblclick, { ...event });
          }
        }
      } else {
        this[eventType + "ClickEndShape"] = null;
        if (!skipPointerUpTrigger) {
          this._fire(events2.pointerup, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._changedPointerPositions[0].id
          });
          skipPointerUpTrigger = true;
        }
        if (Konva["_" + eventType + "ListenClick"]) {
          this._fire(events2.pointerclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
        }
        if (fireDblClick) {
          this._fire(events2.pointerdblclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          });
        }
      }
    });
    if (!skipPointerUpTrigger) {
      this._fire(events2.pointerup, {
        evt,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      });
    }
    Konva["_" + eventType + "ListenClick"] = false;
    if (evt.cancelable && eventType !== "touch" && eventType !== "pointer") {
      evt.preventDefault();
    }
  }
  _contextmenu(evt) {
    this.setPointersPositions(evt);
    const shape = this.getIntersection(this.getPointerPosition());
    if (shape && shape.isListening()) {
      shape._fireAndBubble(CONTEXTMENU, { evt });
    } else {
      this._fire(CONTEXTMENU, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _wheel(evt) {
    this.setPointersPositions(evt);
    const shape = this.getIntersection(this.getPointerPosition());
    if (shape && shape.isListening()) {
      shape._fireAndBubble(WHEEL, { evt });
    } else {
      this._fire(WHEEL, {
        evt,
        target: this,
        currentTarget: this
      });
    }
  }
  _pointercancel(evt) {
    this.setPointersPositions(evt);
    const shape = getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
    if (shape) {
      shape._fireAndBubble(POINTERUP, createEvent(evt));
    }
    releaseCapture(evt.pointerId);
  }
  _lostpointercapture(evt) {
    releaseCapture(evt.pointerId);
  }
  setPointersPositions(evt) {
    const contentPosition = this._getContentPosition();
    let x = null, y = null;
    evt = evt ? evt : window.event;
    if (evt.touches !== void 0) {
      this._pointerPositions = [];
      this._changedPointerPositions = [];
      Array.prototype.forEach.call(evt.touches, (touch) => {
        this._pointerPositions.push({
          id: touch.identifier,
          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
        });
      });
      Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
        this._changedPointerPositions.push({
          id: touch.identifier,
          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
        });
      });
    } else {
      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
      this.pointerPos = {
        x,
        y
      };
      this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];
      this._changedPointerPositions = [
        { x, y, id: Util._getFirstPointerId(evt) }
      ];
    }
  }
  _setPointerPosition(evt) {
    Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
    this.setPointersPositions(evt);
  }
  _getContentPosition() {
    if (!this.content || !this.content.getBoundingClientRect) {
      return {
        top: 0,
        left: 0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const rect = this.content.getBoundingClientRect();
    return {
      top: rect.top,
      left: rect.left,
      scaleX: rect.width / this.content.clientWidth || 1,
      scaleY: rect.height / this.content.clientHeight || 1
    };
  }
  _buildDOM() {
    this.bufferCanvas = new SceneCanvas({
      width: this.width(),
      height: this.height()
    });
    this.bufferHitCanvas = new HitCanvas({
      pixelRatio: 1,
      width: this.width(),
      height: this.height()
    });
    if (!Konva.isBrowser) {
      return;
    }
    const container = this.container();
    if (!container) {
      throw "Stage has no container. A container is required.";
    }
    container.innerHTML = "";
    this.content = document.createElement("div");
    this.content.style.position = "relative";
    this.content.style.userSelect = "none";
    this.content.className = "konvajs-content";
    this.content.setAttribute("role", "presentation");
    container.appendChild(this.content);
    this._resizeDOM();
  }
  cache() {
    Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.");
    return this;
  }
  clearCache() {
    return this;
  }
  batchDraw() {
    this.getChildren().forEach(function(layer) {
      layer.batchDraw();
    });
    return this;
  }
};
Stage.prototype.nodeType = STAGE2;
_registerNode(Stage);
Factory.addGetterSetter(Stage, "container");
if (Konva.isBrowser) {
  document.addEventListener("visibilitychange", () => {
    stages.forEach((stage) => {
      stage.batchDraw();
    });
  });
}

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Shape.js
var HAS_SHADOW = "hasShadow";
var SHADOW_RGBA = "shadowRGBA";
var patternImage = "patternImage";
var linearGradient = "linearGradient";
var radialGradient = "radialGradient";
var dummyContext;
function getDummyContext() {
  if (dummyContext) {
    return dummyContext;
  }
  dummyContext = Util.createCanvasElement().getContext("2d");
  return dummyContext;
}
var shapes = {};
function _fillFunc(context) {
  const fillRule = this.attrs.fillRule;
  if (fillRule) {
    context.fill(fillRule);
  } else {
    context.fill();
  }
}
function _strokeFunc(context) {
  context.stroke();
}
function _fillFuncHit(context) {
  const fillRule = this.attrs.fillRule;
  if (fillRule) {
    context.fill(fillRule);
  } else {
    context.fill();
  }
}
function _strokeFuncHit(context) {
  context.stroke();
}
function _clearHasShadowCache() {
  this._clearCache(HAS_SHADOW);
}
function _clearGetShadowRGBACache() {
  this._clearCache(SHADOW_RGBA);
}
function _clearFillPatternCache() {
  this._clearCache(patternImage);
}
function _clearLinearGradientCache() {
  this._clearCache(linearGradient);
}
function _clearRadialGradientCache() {
  this._clearCache(radialGradient);
}
var Shape = class extends Node {
  constructor(config) {
    super(config);
    let key;
    let attempts = 0;
    while (true) {
      key = Util.getHitColor();
      if (key && !(key in shapes)) {
        break;
      }
      attempts++;
      if (attempts >= 1e4) {
        Util.warn("Failed to find a unique color key for a shape. Konva may work incorrectly. Most likely your browser is using canvas farbling. Consider disabling it.");
        key = Util.getRandomColor();
        break;
      }
    }
    this.colorKey = key;
    shapes[key] = this;
  }
  getContext() {
    Util.warn("shape.getContext() method is deprecated. Please do not use it.");
    return this.getLayer().getContext();
  }
  getCanvas() {
    Util.warn("shape.getCanvas() method is deprecated. Please do not use it.");
    return this.getLayer().getCanvas();
  }
  getSceneFunc() {
    return this.attrs.sceneFunc || this["_sceneFunc"];
  }
  getHitFunc() {
    return this.attrs.hitFunc || this["_hitFunc"];
  }
  hasShadow() {
    return this._getCache(HAS_SHADOW, this._hasShadow);
  }
  _hasShadow() {
    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
  }
  _getFillPattern() {
    return this._getCache(patternImage, this.__getFillPattern);
  }
  __getFillPattern() {
    if (this.fillPatternImage()) {
      const ctx = getDummyContext();
      const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
      if (pattern && pattern.setTransform) {
        const tr = new Transform();
        tr.translate(this.fillPatternX(), this.fillPatternY());
        tr.rotate(Konva.getAngle(this.fillPatternRotation()));
        tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());
        tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
        const m = tr.getMatrix();
        const matrix = typeof DOMMatrix === "undefined" ? {
          a: m[0],
          b: m[1],
          c: m[2],
          d: m[3],
          e: m[4],
          f: m[5]
        } : new DOMMatrix(m);
        pattern.setTransform(matrix);
      }
      return pattern;
    }
  }
  _getLinearGradient() {
    return this._getCache(linearGradient, this.__getLinearGradient);
  }
  __getLinearGradient() {
    const colorStops = this.fillLinearGradientColorStops();
    if (colorStops) {
      const ctx = getDummyContext();
      const start = this.fillLinearGradientStartPoint();
      const end = this.fillLinearGradientEndPoint();
      const grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
      for (let n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      return grd;
    }
  }
  _getRadialGradient() {
    return this._getCache(radialGradient, this.__getRadialGradient);
  }
  __getRadialGradient() {
    const colorStops = this.fillRadialGradientColorStops();
    if (colorStops) {
      const ctx = getDummyContext();
      const start = this.fillRadialGradientStartPoint();
      const end = this.fillRadialGradientEndPoint();
      const grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
      for (let n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      return grd;
    }
  }
  getShadowRGBA() {
    return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
  }
  _getShadowRGBA() {
    if (!this.hasShadow()) {
      return;
    }
    const rgba = Util.colorToRGBA(this.shadowColor());
    if (rgba) {
      return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a * (this.shadowOpacity() || 1) + ")";
    }
  }
  hasFill() {
    return this._calculate("hasFill", [
      "fillEnabled",
      "fill",
      "fillPatternImage",
      "fillLinearGradientColorStops",
      "fillRadialGradientColorStops"
    ], () => {
      return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());
    });
  }
  hasStroke() {
    return this._calculate("hasStroke", [
      "strokeEnabled",
      "strokeWidth",
      "stroke",
      "strokeLinearGradientColorStops"
    ], () => {
      return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());
    });
  }
  hasHitStroke() {
    const width = this.hitStrokeWidth();
    if (width === "auto") {
      return this.hasStroke();
    }
    return this.strokeEnabled() && !!width;
  }
  intersects(point) {
    const stage = this.getStage();
    if (!stage) {
      return false;
    }
    const bufferHitCanvas = stage.bufferHitCanvas;
    bufferHitCanvas.getContext().clear();
    this.drawHit(bufferHitCanvas, void 0, true);
    const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
    return p[3] > 0;
  }
  destroy() {
    Node.prototype.destroy.call(this);
    delete shapes[this.colorKey];
    delete this.colorKey;
    return this;
  }
  _useBufferCanvas(forceFill) {
    var _a;
    const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;
    if (!perfectDrawEnabled) {
      return false;
    }
    const hasFill = forceFill || this.hasFill();
    const hasStroke = this.hasStroke();
    const isTransparent = this.getAbsoluteOpacity() !== 1;
    if (hasFill && hasStroke && isTransparent) {
      return true;
    }
    const hasShadow = this.hasShadow();
    const strokeForShadow = this.shadowForStrokeEnabled();
    if (hasFill && hasStroke && hasShadow && strokeForShadow) {
      return true;
    }
    return false;
  }
  setStrokeHitEnabled(val) {
    Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.");
    if (val) {
      this.hitStrokeWidth("auto");
    } else {
      this.hitStrokeWidth(0);
    }
  }
  getStrokeHitEnabled() {
    if (this.hitStrokeWidth() === 0) {
      return false;
    } else {
      return true;
    }
  }
  getSelfRect() {
    const size = this.size();
    return {
      x: this._centroid ? -size.width / 2 : 0,
      y: this._centroid ? -size.height / 2 : 0,
      width: size.width,
      height: size.height
    };
  }
  getClientRect(config = {}) {
    let hasCachedParent = false;
    let parent = this.getParent();
    while (parent) {
      if (parent.isCached()) {
        hasCachedParent = true;
        break;
      }
      parent = parent.getParent();
    }
    const skipTransform = config.skipTransform;
    const relativeTo = config.relativeTo || hasCachedParent && this.getStage() || void 0;
    const fillRect = this.getSelfRect();
    const applyStroke = !config.skipStroke && this.hasStroke();
    const strokeWidth = applyStroke && this.strokeWidth() || 0;
    const fillAndStrokeWidth = fillRect.width + strokeWidth;
    const fillAndStrokeHeight = fillRect.height + strokeWidth;
    const applyShadow = !config.skipShadow && this.hasShadow();
    const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
    const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
    const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
    const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
    const blurRadius = applyShadow && this.shadowBlur() || 0;
    const width = preWidth + blurRadius * 2;
    const height = preHeight + blurRadius * 2;
    const rect = {
      width,
      height,
      x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
      y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
    };
    if (!skipTransform) {
      return this._transformedRect(rect, relativeTo);
    }
    return rect;
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer();
    const canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow();
    let stage;
    const skipBuffer = false;
    const cachingSelf = top === this;
    if (!this.isVisible() && !cachingSelf) {
      return this;
    }
    if (cachedCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedSceneCanvas(context);
      context.restore();
      return this;
    }
    if (!drawFunc) {
      return this;
    }
    context.save();
    if (this._useBufferCanvas() && !skipBuffer) {
      stage = this.getStage();
      const bc = bufferCanvas || stage.bufferCanvas;
      const bufferContext = bc.getContext();
      bufferContext.clear();
      bufferContext.save();
      bufferContext._applyLineJoin(this);
      bufferContext._applyMiterLimit(this);
      const o = this.getAbsoluteTransform(top).getMatrix();
      bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
      drawFunc.call(this, bufferContext, this);
      bufferContext.restore();
      const ratio = bc.pixelRatio;
      if (hasShadow) {
        context._applyShadow(this);
      }
      if (!cachingSelf) {
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
      }
      context.drawImage(bc._canvas, bc.x || 0, bc.y || 0, bc.width / ratio, bc.height / ratio);
    } else {
      context._applyLineJoin(this);
      context._applyMiterLimit(this);
      if (!cachingSelf) {
        const o = this.getAbsoluteTransform(top).getMatrix();
        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        context._applyOpacity(this);
        context._applyGlobalCompositeOperation(this);
      }
      if (hasShadow) {
        context._applyShadow(this);
      }
      drawFunc.call(this, context, this);
    }
    context.restore();
    return this;
  }
  drawHit(can, top, skipDragCheck = false) {
    if (!this.shouldDrawHit(top, skipDragCheck)) {
      return this;
    }
    const layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
    if (!this.colorKey) {
      Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()");
    }
    if (cachedHitCanvas) {
      context.save();
      const m = this.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._drawCachedHitCanvas(context);
      context.restore();
      return this;
    }
    if (!drawFunc) {
      return this;
    }
    context.save();
    context._applyLineJoin(this);
    context._applyMiterLimit(this);
    const selfCache = this === top;
    if (!selfCache) {
      const o = this.getAbsoluteTransform(top).getMatrix();
      context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
    }
    drawFunc.call(this, context, this);
    context.restore();
    return this;
  }
  drawHitFromCache(alphaThreshold = 0) {
    const cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight();
    hitContext.clear();
    hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
    try {
      const hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
      const hitData = hitImageData.data;
      const len = hitData.length;
      const rgbColorKey = Util._hexToRgb(this.colorKey);
      for (let i = 0; i < len; i += 4) {
        const alpha = hitData[i + 3];
        if (alpha > alphaThreshold) {
          hitData[i] = rgbColorKey.r;
          hitData[i + 1] = rgbColorKey.g;
          hitData[i + 2] = rgbColorKey.b;
          hitData[i + 3] = 255;
        } else {
          hitData[i + 3] = 0;
        }
      }
      hitContext.putImageData(hitImageData, 0, 0);
    } catch (e) {
      Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
    }
    return this;
  }
  hasPointerCapture(pointerId) {
    return hasPointerCapture(pointerId, this);
  }
  setPointerCapture(pointerId) {
    setPointerCapture(pointerId, this);
  }
  releaseCapture(pointerId) {
    releaseCapture(pointerId, this);
  }
};
Shape.prototype._fillFunc = _fillFunc;
Shape.prototype._strokeFunc = _strokeFunc;
Shape.prototype._fillFuncHit = _fillFuncHit;
Shape.prototype._strokeFuncHit = _strokeFuncHit;
Shape.prototype._centroid = false;
Shape.prototype.nodeType = "Shape";
_registerNode(Shape);
Shape.prototype.eventListeners = {};
Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
Factory.addGetterSetter(Shape, "stroke", void 0, getStringOrGradientValidator());
Factory.addGetterSetter(Shape, "strokeWidth", 2, getNumberValidator());
Factory.addGetterSetter(Shape, "fillAfterStrokeEnabled", false);
Factory.addGetterSetter(Shape, "hitStrokeWidth", "auto", getNumberOrAutoValidator());
Factory.addGetterSetter(Shape, "strokeHitEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "perfectDrawEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "shadowForStrokeEnabled", true, getBooleanValidator());
Factory.addGetterSetter(Shape, "lineJoin");
Factory.addGetterSetter(Shape, "lineCap");
Factory.addGetterSetter(Shape, "miterLimit");
Factory.addGetterSetter(Shape, "sceneFunc");
Factory.addGetterSetter(Shape, "hitFunc");
Factory.addGetterSetter(Shape, "dash");
Factory.addGetterSetter(Shape, "dashOffset", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowColor", void 0, getStringValidator());
Factory.addGetterSetter(Shape, "shadowBlur", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowOpacity", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "shadowOffset", ["x", "y"]);
Factory.addGetterSetter(Shape, "shadowOffsetX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "shadowOffsetY", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternImage");
Factory.addGetterSetter(Shape, "fill", void 0, getStringOrGradientValidator());
Factory.addGetterSetter(Shape, "fillPatternX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternY", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillLinearGradientColorStops");
Factory.addGetterSetter(Shape, "strokeLinearGradientColorStops");
Factory.addGetterSetter(Shape, "fillRadialGradientStartRadius", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientEndRadius", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientColorStops");
Factory.addGetterSetter(Shape, "fillPatternRepeat", "repeat");
Factory.addGetterSetter(Shape, "fillEnabled", true);
Factory.addGetterSetter(Shape, "strokeEnabled", true);
Factory.addGetterSetter(Shape, "shadowEnabled", true);
Factory.addGetterSetter(Shape, "dashEnabled", true);
Factory.addGetterSetter(Shape, "strokeScaleEnabled", true);
Factory.addGetterSetter(Shape, "fillPriority", "color");
Factory.addComponentsGetterSetter(Shape, "fillPatternOffset", ["x", "y"]);
Factory.addGetterSetter(Shape, "fillPatternOffsetX", 0, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternOffsetY", 0, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "fillPatternScale", ["x", "y"]);
Factory.addGetterSetter(Shape, "fillPatternScaleX", 1, getNumberValidator());
Factory.addGetterSetter(Shape, "fillPatternScaleY", 1, getNumberValidator());
Factory.addComponentsGetterSetter(Shape, "fillLinearGradientStartPoint", [
  "x",
  "y"
]);
Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientStartPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillLinearGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "fillLinearGradientStartPointY", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillLinearGradientEndPoint", [
  "x",
  "y"
]);
Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientEndPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillLinearGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "fillLinearGradientEndPointY", 0);
Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillRadialGradientStartPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillRadialGradientStartPointX", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientStartPointY", 0);
Factory.addComponentsGetterSetter(Shape, "fillRadialGradientEndPoint", [
  "x",
  "y"
]);
Factory.addGetterSetter(Shape, "fillRadialGradientEndPointX", 0);
Factory.addGetterSetter(Shape, "fillRadialGradientEndPointY", 0);
Factory.addGetterSetter(Shape, "fillPatternRotation", 0);
Factory.addGetterSetter(Shape, "fillRule", void 0, getStringValidator());
Factory.backCompat(Shape, {
  dashArray: "dash",
  getDashArray: "getDash",
  setDashArray: "getDash",
  drawFunc: "sceneFunc",
  getDrawFunc: "getSceneFunc",
  setDrawFunc: "setSceneFunc",
  drawHitFunc: "hitFunc",
  getDrawHitFunc: "getHitFunc",
  setDrawHitFunc: "setHitFunc"
});

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Layer.js
var BEFORE_DRAW = "beforeDraw";
var DRAW = "draw";
var INTERSECTION_OFFSETS = [
  { x: 0, y: 0 },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 }
];
var INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
var Layer = class extends Container {
  constructor(config) {
    super(config);
    this.canvas = new SceneCanvas();
    this.hitCanvas = new HitCanvas({
      pixelRatio: 1
    });
    this._waitingForDraw = false;
    this.on("visibleChange.konva", this._checkVisibility);
    this._checkVisibility();
    this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled);
    this._setSmoothEnabled();
  }
  createPNGStream() {
    const c = this.canvas._canvas;
    return c.createPNGStream();
  }
  getCanvas() {
    return this.canvas;
  }
  getNativeCanvasElement() {
    return this.canvas._canvas;
  }
  getHitCanvas() {
    return this.hitCanvas;
  }
  getContext() {
    return this.getCanvas().getContext();
  }
  clear(bounds) {
    this.getContext().clear(bounds);
    this.getHitCanvas().getContext().clear(bounds);
    return this;
  }
  setZIndex(index) {
    super.setZIndex(index);
    const stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      if (index < stage.children.length - 1) {
        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);
      } else {
        stage.content.appendChild(this.getNativeCanvasElement());
      }
    }
    return this;
  }
  moveToTop() {
    Node.prototype.moveToTop.call(this);
    const stage = this.getStage();
    if (stage && stage.content) {
      stage.content.removeChild(this.getNativeCanvasElement());
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveUp() {
    const moved = Node.prototype.moveUp.call(this);
    if (!moved) {
      return false;
    }
    const stage = this.getStage();
    if (!stage || !stage.content) {
      return false;
    }
    stage.content.removeChild(this.getNativeCanvasElement());
    if (this.index < stage.children.length - 1) {
      stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);
    } else {
      stage.content.appendChild(this.getNativeCanvasElement());
    }
    return true;
  }
  moveDown() {
    if (Node.prototype.moveDown.call(this)) {
      const stage = this.getStage();
      if (stage) {
        const children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  moveToBottom() {
    if (Node.prototype.moveToBottom.call(this)) {
      const stage = this.getStage();
      if (stage) {
        const children = stage.children;
        if (stage.content) {
          stage.content.removeChild(this.getNativeCanvasElement());
          stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);
        }
      }
      return true;
    }
    return false;
  }
  getLayer() {
    return this;
  }
  remove() {
    const _canvas = this.getNativeCanvasElement();
    Node.prototype.remove.call(this);
    if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {
      _canvas.parentNode.removeChild(_canvas);
    }
    return this;
  }
  getStage() {
    return this.parent;
  }
  setSize({ width, height }) {
    this.canvas.setSize(width, height);
    this.hitCanvas.setSize(width, height);
    this._setSmoothEnabled();
    return this;
  }
  _validateAdd(child) {
    const type = child.getType();
    if (type !== "Group" && type !== "Shape") {
      Util.throw("You may only add groups and shapes to a layer.");
    }
  }
  _toKonvaCanvas(config) {
    config = { ...config };
    config.width = config.width || this.getWidth();
    config.height = config.height || this.getHeight();
    config.x = config.x !== void 0 ? config.x : this.x();
    config.y = config.y !== void 0 ? config.y : this.y();
    return Node.prototype._toKonvaCanvas.call(this, config);
  }
  _checkVisibility() {
    const visible = this.visible();
    if (visible) {
      this.canvas._canvas.style.display = "block";
    } else {
      this.canvas._canvas.style.display = "none";
    }
  }
  _setSmoothEnabled() {
    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
  }
  getWidth() {
    if (this.parent) {
      return this.parent.width();
    }
  }
  setWidth() {
    Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
  }
  getHeight() {
    if (this.parent) {
      return this.parent.height();
    }
  }
  setHeight() {
    Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
  }
  batchDraw() {
    if (!this._waitingForDraw) {
      this._waitingForDraw = true;
      Util.requestAnimFrame(() => {
        this.draw();
        this._waitingForDraw = false;
      });
    }
    return this;
  }
  getIntersection(pos) {
    if (!this.isListening() || !this.isVisible()) {
      return null;
    }
    let spiralSearchDistance = 1;
    let continueSearch = false;
    while (true) {
      for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
        const intersectionOffset = INTERSECTION_OFFSETS[i];
        const obj = this._getIntersection({
          x: pos.x + intersectionOffset.x * spiralSearchDistance,
          y: pos.y + intersectionOffset.y * spiralSearchDistance
        });
        const shape = obj.shape;
        if (shape) {
          return shape;
        }
        continueSearch = !!obj.antialiased;
        if (!obj.antialiased) {
          break;
        }
      }
      if (continueSearch) {
        spiralSearchDistance += 1;
      } else {
        return null;
      }
    }
  }
  _getIntersection(pos) {
    const ratio = this.hitCanvas.pixelRatio;
    const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
    const p3 = p[3];
    if (p3 === 255) {
      const colorKey = Util.getHitColorKey(p[0], p[1], p[2]);
      const shape = shapes[colorKey];
      if (shape) {
        return {
          shape
        };
      }
      return {
        antialiased: true
      };
    } else if (p3 > 0) {
      return {
        antialiased: true
      };
    }
    return {};
  }
  drawScene(can, top, bufferCanvas) {
    const layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
    this._fire(BEFORE_DRAW, {
      node: this
    });
    if (this.clearBeforeDraw()) {
      canvas.getContext().clear();
    }
    Container.prototype.drawScene.call(this, canvas, top, bufferCanvas);
    this._fire(DRAW, {
      node: this
    });
    return this;
  }
  drawHit(can, top) {
    const layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
    if (layer && layer.clearBeforeDraw()) {
      layer.getHitCanvas().getContext().clear();
    }
    Container.prototype.drawHit.call(this, canvas, top);
    return this;
  }
  enableHitGraph() {
    this.hitGraphEnabled(true);
    return this;
  }
  disableHitGraph() {
    this.hitGraphEnabled(false);
    return this;
  }
  setHitGraphEnabled(val) {
    Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    this.listening(val);
  }
  getHitGraphEnabled(val) {
    Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead.");
    return this.listening();
  }
  toggleHitCanvas() {
    if (!this.parent || !this.parent["content"]) {
      return;
    }
    const parent = this.parent;
    const added = !!this.hitCanvas._canvas.parentNode;
    if (added) {
      parent.content.removeChild(this.hitCanvas._canvas);
    } else {
      parent.content.appendChild(this.hitCanvas._canvas);
    }
  }
  destroy() {
    Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);
    return super.destroy();
  }
};
Layer.prototype.nodeType = "Layer";
_registerNode(Layer);
Factory.addGetterSetter(Layer, "imageSmoothingEnabled", true);
Factory.addGetterSetter(Layer, "clearBeforeDraw", true);
Factory.addGetterSetter(Layer, "hitGraphEnabled", true, getBooleanValidator());

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/FastLayer.js
var FastLayer = class extends Layer {
  constructor(attrs) {
    super(attrs);
    this.listening(false);
    Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
  }
};
FastLayer.prototype.nodeType = "FastLayer";
_registerNode(FastLayer);

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Group.js
var Group = class extends Container {
  _validateAdd(child) {
    const type = child.getType();
    if (type !== "Group" && type !== "Shape") {
      Util.throw("You may only add groups and shapes to groups.");
    }
  }
};
Group.prototype.nodeType = "Group";
_registerNode(Group);

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Animation.js
var now = (function() {
  if (glob.performance && glob.performance.now) {
    return function() {
      return glob.performance.now();
    };
  }
  return function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
})();
var Animation = class _Animation {
  constructor(func, layers) {
    this.id = _Animation.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now(),
      frameRate: 0
    };
    this.func = func;
    this.setLayers(layers);
  }
  setLayers(layers) {
    let lays = [];
    if (layers) {
      lays = Array.isArray(layers) ? layers : [layers];
    }
    this.layers = lays;
    return this;
  }
  getLayers() {
    return this.layers;
  }
  addLayer(layer) {
    const layers = this.layers;
    const len = layers.length;
    for (let n = 0; n < len; n++) {
      if (layers[n]._id === layer._id) {
        return false;
      }
    }
    this.layers.push(layer);
    return true;
  }
  isRunning() {
    const a = _Animation;
    const animations = a.animations;
    const len = animations.length;
    for (let n = 0; n < len; n++) {
      if (animations[n].id === this.id) {
        return true;
      }
    }
    return false;
  }
  start() {
    this.stop();
    this.frame.timeDiff = 0;
    this.frame.lastTime = now();
    _Animation._addAnimation(this);
    return this;
  }
  stop() {
    _Animation._removeAnimation(this);
    return this;
  }
  _updateFrameObject(time2) {
    this.frame.timeDiff = time2 - this.frame.lastTime;
    this.frame.lastTime = time2;
    this.frame.time += this.frame.timeDiff;
    this.frame.frameRate = 1e3 / this.frame.timeDiff;
  }
  static _addAnimation(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  }
  static _removeAnimation(anim) {
    const id = anim.id;
    const animations = this.animations;
    const len = animations.length;
    for (let n = 0; n < len; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  }
  static _runFrames() {
    const layerHash = {};
    const animations = this.animations;
    for (let n = 0; n < animations.length; n++) {
      const anim = animations[n];
      const layers = anim.layers;
      const func = anim.func;
      anim._updateFrameObject(now());
      const layersLen = layers.length;
      let needRedraw;
      if (func) {
        needRedraw = func.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (let i = 0; i < layersLen; i++) {
        const layer = layers[i];
        if (layer._id !== void 0) {
          layerHash[layer._id] = layer;
        }
      }
    }
    for (const key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].batchDraw();
    }
  }
  static _animationLoop() {
    const Anim = _Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      Util.requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  }
  static _handleAnimation() {
    if (!this.animRunning) {
      this.animRunning = true;
      Util.requestAnimFrame(this._animationLoop);
    }
  }
};
Animation.animations = [];
Animation.animIdCounter = 0;
Animation.animRunning = false;

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Tween.js
var blacklist = {
  node: 1,
  duration: 1,
  easing: 1,
  onFinish: 1,
  yoyo: 1
};
var PAUSED = 1;
var PLAYING = 2;
var REVERSING = 3;
var colorAttrs = ["fill", "stroke", "shadowColor"];
var idCounter2 = 0;
var TweenEngine = class {
  constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
    this.prop = prop;
    this.propFunc = propFunc;
    this.begin = begin;
    this._pos = begin;
    this.duration = duration;
    this._change = 0;
    this.prevPos = 0;
    this.yoyo = yoyo;
    this._time = 0;
    this._position = 0;
    this._startTime = 0;
    this._finish = 0;
    this.func = func;
    this._change = finish - this.begin;
    this.pause();
  }
  fire(str) {
    const handler = this[str];
    if (handler) {
      handler();
    }
  }
  setTime(t) {
    if (t > this.duration) {
      if (this.yoyo) {
        this._time = this.duration;
        this.reverse();
      } else {
        this.finish();
      }
    } else if (t < 0) {
      if (this.yoyo) {
        this._time = 0;
        this.play();
      } else {
        this.reset();
      }
    } else {
      this._time = t;
      this.update();
    }
  }
  getTime() {
    return this._time;
  }
  setPosition(p) {
    this.prevPos = this._pos;
    this.propFunc(p);
    this._pos = p;
  }
  getPosition(t) {
    if (t === void 0) {
      t = this._time;
    }
    return this.func(t, this.begin, this._change, this.duration);
  }
  play() {
    this.state = PLAYING;
    this._startTime = this.getTimer() - this._time;
    this.onEnterFrame();
    this.fire("onPlay");
  }
  reverse() {
    this.state = REVERSING;
    this._time = this.duration - this._time;
    this._startTime = this.getTimer() - this._time;
    this.onEnterFrame();
    this.fire("onReverse");
  }
  seek(t) {
    this.pause();
    this._time = t;
    this.update();
    this.fire("onSeek");
  }
  reset() {
    this.pause();
    this._time = 0;
    this.update();
    this.fire("onReset");
  }
  finish() {
    this.pause();
    this._time = this.duration;
    this.update();
    this.fire("onFinish");
  }
  update() {
    this.setPosition(this.getPosition(this._time));
    this.fire("onUpdate");
  }
  onEnterFrame() {
    const t = this.getTimer() - this._startTime;
    if (this.state === PLAYING) {
      this.setTime(t);
    } else if (this.state === REVERSING) {
      this.setTime(this.duration - t);
    }
  }
  pause() {
    this.state = PAUSED;
    this.fire("onPause");
  }
  getTimer() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
};
var Tween = class _Tween {
  constructor(config) {
    const that = this, node = config.node, nodeId = node._id, easing = config.easing || Easings.Linear, yoyo = !!config.yoyo;
    let duration, key;
    if (typeof config.duration === "undefined") {
      duration = 0.3;
    } else if (config.duration === 0) {
      duration = 1e-3;
    } else {
      duration = config.duration;
    }
    this.node = node;
    this._id = idCounter2++;
    const layers = node.getLayer() || (node instanceof Konva["Stage"] ? node.getLayers() : null);
    if (!layers) {
      Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first.");
    }
    this.anim = new Animation(function() {
      that.tween.onEnterFrame();
    }, layers);
    this.tween = new TweenEngine(key, function(i) {
      that._tweenFunc(i);
    }, easing, 0, 1, duration * 1e3, yoyo);
    this._addListeners();
    if (!_Tween.attrs[nodeId]) {
      _Tween.attrs[nodeId] = {};
    }
    if (!_Tween.attrs[nodeId][this._id]) {
      _Tween.attrs[nodeId][this._id] = {};
    }
    if (!_Tween.tweens[nodeId]) {
      _Tween.tweens[nodeId] = {};
    }
    for (key in config) {
      if (blacklist[key] === void 0) {
        this._addAttr(key, config[key]);
      }
    }
    this.reset();
    this.onFinish = config.onFinish;
    this.onReset = config.onReset;
    this.onUpdate = config.onUpdate;
  }
  _addAttr(key, end) {
    const node = this.node, nodeId = node._id;
    let diff, len, trueEnd, trueStart, endRGBA;
    const tweenId = _Tween.tweens[nodeId][key];
    if (tweenId) {
      delete _Tween.attrs[nodeId][tweenId][key];
    }
    let start = node.getAttr(key);
    if (Util._isArray(end)) {
      diff = [];
      len = Math.max(end.length, start.length);
      if (key === "points" && end.length !== start.length) {
        if (end.length > start.length) {
          trueStart = start;
          start = Util._prepareArrayForTween(start, end, node.closed());
        } else {
          trueEnd = end;
          end = Util._prepareArrayForTween(end, start, node.closed());
        }
      }
      if (key.indexOf("fill") === 0) {
        for (let n = 0; n < len; n++) {
          if (n % 2 === 0) {
            diff.push(end[n] - start[n]);
          } else {
            const startRGBA = Util.colorToRGBA(start[n]);
            endRGBA = Util.colorToRGBA(end[n]);
            start[n] = startRGBA;
            diff.push({
              r: endRGBA.r - startRGBA.r,
              g: endRGBA.g - startRGBA.g,
              b: endRGBA.b - startRGBA.b,
              a: endRGBA.a - startRGBA.a
            });
          }
        }
      } else {
        for (let n = 0; n < len; n++) {
          diff.push(end[n] - start[n]);
        }
      }
    } else if (colorAttrs.indexOf(key) !== -1) {
      start = Util.colorToRGBA(start);
      endRGBA = Util.colorToRGBA(end);
      diff = {
        r: endRGBA.r - start.r,
        g: endRGBA.g - start.g,
        b: endRGBA.b - start.b,
        a: endRGBA.a - start.a
      };
    } else {
      diff = end - start;
    }
    _Tween.attrs[nodeId][this._id][key] = {
      start,
      diff,
      end,
      trueEnd,
      trueStart
    };
    _Tween.tweens[nodeId][key] = this._id;
  }
  _tweenFunc(i) {
    const node = this.node, attrs = _Tween.attrs[node._id][this._id];
    let key, attr, start, diff, newVal, n, len, end;
    for (key in attrs) {
      attr = attrs[key];
      start = attr.start;
      diff = attr.diff;
      end = attr.end;
      if (Util._isArray(start)) {
        newVal = [];
        len = Math.max(start.length, end.length);
        if (key.indexOf("fill") === 0) {
          for (n = 0; n < len; n++) {
            if (n % 2 === 0) {
              newVal.push((start[n] || 0) + diff[n] * i);
            } else {
              newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i) + "," + Math.round(start[n].g + diff[n].g * i) + "," + Math.round(start[n].b + diff[n].b * i) + "," + (start[n].a + diff[n].a * i) + ")");
            }
          }
        } else {
          for (n = 0; n < len; n++) {
            newVal.push((start[n] || 0) + diff[n] * i);
          }
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        newVal = "rgba(" + Math.round(start.r + diff.r * i) + "," + Math.round(start.g + diff.g * i) + "," + Math.round(start.b + diff.b * i) + "," + (start.a + diff.a * i) + ")";
      } else {
        newVal = start + diff * i;
      }
      node.setAttr(key, newVal);
    }
  }
  _addListeners() {
    this.tween.onPlay = () => {
      this.anim.start();
    };
    this.tween.onReverse = () => {
      this.anim.start();
    };
    this.tween.onPause = () => {
      this.anim.stop();
    };
    this.tween.onFinish = () => {
      const node = this.node;
      const attrs = _Tween.attrs[node._id][this._id];
      if (attrs.points && attrs.points.trueEnd) {
        node.setAttr("points", attrs.points.trueEnd);
      }
      if (this.onFinish) {
        this.onFinish.call(this);
      }
    };
    this.tween.onReset = () => {
      const node = this.node;
      const attrs = _Tween.attrs[node._id][this._id];
      if (attrs.points && attrs.points.trueStart) {
        node.points(attrs.points.trueStart);
      }
      if (this.onReset) {
        this.onReset();
      }
    };
    this.tween.onUpdate = () => {
      if (this.onUpdate) {
        this.onUpdate.call(this);
      }
    };
  }
  play() {
    this.tween.play();
    return this;
  }
  reverse() {
    this.tween.reverse();
    return this;
  }
  reset() {
    this.tween.reset();
    return this;
  }
  seek(t) {
    this.tween.seek(t * 1e3);
    return this;
  }
  pause() {
    this.tween.pause();
    return this;
  }
  finish() {
    this.tween.finish();
    return this;
  }
  destroy() {
    const nodeId = this.node._id, thisId = this._id, attrs = _Tween.tweens[nodeId];
    this.pause();
    if (this.anim) {
      this.anim.stop();
    }
    for (const key in attrs) {
      delete _Tween.tweens[nodeId][key];
    }
    delete _Tween.attrs[nodeId][thisId];
    if (_Tween.tweens[nodeId]) {
      if (Object.keys(_Tween.tweens[nodeId]).length === 0) {
        delete _Tween.tweens[nodeId];
      }
      if (Object.keys(_Tween.attrs[nodeId]).length === 0) {
        delete _Tween.attrs[nodeId];
      }
    }
  }
};
Tween.attrs = {};
Tween.tweens = {};
Node.prototype.to = function(params) {
  const onFinish = params.onFinish;
  params.node = this;
  params.onFinish = function() {
    this.destroy();
    if (onFinish) {
      onFinish();
    }
  };
  const tween = new Tween(params);
  tween.play();
};
var Easings = {
  BackEaseIn(t, b, c, d) {
    const s = 1.70158;
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  },
  BackEaseOut(t, b, c, d) {
    const s = 1.70158;
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  },
  BackEaseInOut(t, b, c, d) {
    let s = 1.70158;
    if ((t /= d / 2) < 1) {
      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  },
  ElasticEaseIn(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d) === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  },
  ElasticEaseOut(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d) === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
  },
  ElasticEaseInOut(t, b, c, d, a, p) {
    let s = 0;
    if (t === 0) {
      return b;
    }
    if ((t /= d / 2) === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    if (!a || a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    if (t < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    }
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
  },
  BounceEaseOut(t, b, c, d) {
    if ((t /= d) < 1 / 2.75) {
      return c * (7.5625 * t * t) + b;
    } else if (t < 2 / 2.75) {
      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
    } else if (t < 2.5 / 2.75) {
      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
    } else {
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
    }
  },
  BounceEaseIn(t, b, c, d) {
    return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;
  },
  BounceEaseInOut(t, b, c, d) {
    if (t < d / 2) {
      return Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
    } else {
      return Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
  },
  EaseIn(t, b, c, d) {
    return c * (t /= d) * t + b;
  },
  EaseOut(t, b, c, d) {
    return -c * (t /= d) * (t - 2) + b;
  },
  EaseInOut(t, b, c, d) {
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t + b;
    }
    return -c / 2 * (--t * (t - 2) - 1) + b;
  },
  StrongEaseIn(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  },
  StrongEaseOut(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  },
  StrongEaseInOut(t, b, c, d) {
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  },
  Linear(t, b, c, d) {
    return c * t / d + b;
  }
};

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/_CoreInternals.js
var Konva2 = Util._assign(Konva, {
  Util,
  Transform,
  Node,
  Container,
  Stage,
  stages,
  Layer,
  FastLayer,
  Group,
  DD,
  Shape,
  shapes,
  Animation,
  Tween,
  Easings,
  Context,
  Canvas
});

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/Core.js
var Core_default = Konva2;

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/shapes/Line.js
function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
  const d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
  return [p1x, p1y, p2x, p2y];
}
function expandPoints(p, tension) {
  const len = p.length, allPoints = [];
  for (let n = 2; n < len - 2; n += 2) {
    const cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
    if (isNaN(cp[0])) {
      continue;
    }
    allPoints.push(cp[0]);
    allPoints.push(cp[1]);
    allPoints.push(p[n]);
    allPoints.push(p[n + 1]);
    allPoints.push(cp[2]);
    allPoints.push(cp[3]);
  }
  return allPoints;
}
var Line = class extends Shape {
  constructor(config) {
    super(config);
    this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
      this._clearCache("tensionPoints");
    });
  }
  _sceneFunc(context) {
    const points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier();
    if (!length) {
      return;
    }
    let n = 0;
    context.beginPath();
    context.moveTo(points[0], points[1]);
    if (tension !== 0 && length > 4) {
      const tp = this.getTensionPoints();
      const len = tp.length;
      n = closed ? 0 : 4;
      if (!closed) {
        context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
      }
      while (n < len - 2) {
        context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
      }
      if (!closed) {
        context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
      }
    } else if (bezier) {
      n = 2;
      while (n < length) {
        context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
      }
    } else {
      for (n = 2; n < length; n += 2) {
        context.lineTo(points[n], points[n + 1]);
      }
    }
    if (closed) {
      context.closePath();
      context.fillStrokeShape(this);
    } else {
      context.strokeShape(this);
    }
  }
  getTensionPoints() {
    return this._getCache("tensionPoints", this._getTensionPoints);
  }
  _getTensionPoints() {
    if (this.closed()) {
      return this._getTensionPointsClosed();
    } else {
      return expandPoints(this.points(), this.tension());
    }
  }
  _getTensionPointsClosed() {
    const p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
      lastControlPoints[0],
      lastControlPoints[1],
      p[len - 2],
      p[len - 1],
      lastControlPoints[2],
      lastControlPoints[3],
      firstControlPoints[0],
      firstControlPoints[1],
      p[0],
      p[1]
    ]);
    return tp;
  }
  getWidth() {
    return this.getSelfRect().width;
  }
  getHeight() {
    return this.getSelfRect().height;
  }
  getSelfRect() {
    let points = this.points();
    if (points.length < 4) {
      return {
        x: points[0] || 0,
        y: points[1] || 0,
        width: 0,
        height: 0
      };
    }
    if (this.tension() !== 0) {
      points = [
        points[0],
        points[1],
        ...this._getTensionPoints(),
        points[points.length - 2],
        points[points.length - 1]
      ];
    } else {
      points = this.points();
    }
    let minX = points[0];
    let maxX = points[0];
    let minY = points[1];
    let maxY = points[1];
    let x, y;
    for (let i = 0; i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
};
Line.prototype.className = "Line";
Line.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
_registerNode(Line);
Factory.addGetterSetter(Line, "closed", false);
Factory.addGetterSetter(Line, "bezier", false);
Factory.addGetterSetter(Line, "tension", 0, getNumberValidator());
Factory.addGetterSetter(Line, "points", [], getNumberArrayValidator());

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/shapes/Rect.js
var Rect = class extends Shape {
  _sceneFunc(context) {
    const cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
    context.beginPath();
    if (!cornerRadius) {
      context.rect(0, 0, width, height);
    } else {
      Util.drawRoundedRectPath(context, width, height, cornerRadius);
    }
    context.closePath();
    context.fillStrokeShape(this);
  }
};
Rect.prototype.className = "Rect";
_registerNode(Rect);
Factory.addGetterSetter(Rect, "cornerRadius", 0, getNumberOrArrayOfNumbersValidator(4));

// node_modules/.pnpm/konva@10.0.11/node_modules/konva/lib/shapes/Text.js
function stringToArray(string) {
  return [...string].reduce((acc, char, index, array) => {
    if (new RegExp("\\p{Emoji}", "u").test(char)) {
      const nextChar = array[index + 1];
      if (nextChar && new RegExp("\\p{Emoji_Modifier}|\\u200D", "u").test(nextChar)) {
        acc.push(char + nextChar);
        array[index + 1] = "";
      } else {
        acc.push(char);
      }
    } else if (new RegExp("\\p{Regional_Indicator}{2}", "u").test(char + (array[index + 1] || ""))) {
      acc.push(char + array[index + 1]);
    } else if (index > 0 && new RegExp("\\p{Mn}|\\p{Me}|\\p{Mc}", "u").test(char)) {
      acc[acc.length - 1] += char;
    } else if (char) {
      acc.push(char);
    }
    return acc;
  }, []);
}
var AUTO = "auto";
var CENTER = "center";
var INHERIT = "inherit";
var JUSTIFY = "justify";
var CHANGE_KONVA = "Change.konva";
var CONTEXT_2D = "2d";
var DASH = "-";
var LEFT = "left";
var TEXT = "text";
var TEXT_UPPER = "Text";
var TOP = "top";
var BOTTOM = "bottom";
var MIDDLE = "middle";
var NORMAL = "normal";
var PX_SPACE = "px ";
var SPACE2 = " ";
var RIGHT = "right";
var RTL = "rtl";
var WORD = "word";
var CHAR = "char";
var NONE = "none";
var ELLIPSIS = "";
var ATTR_CHANGE_LIST = [
  "direction",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "padding",
  "align",
  "verticalAlign",
  "lineHeight",
  "text",
  "width",
  "height",
  "wrap",
  "ellipsis",
  "letterSpacing"
];
var attrChangeListLen = ATTR_CHANGE_LIST.length;
function normalizeFontFamily(fontFamily) {
  return fontFamily.split(",").map((family) => {
    family = family.trim();
    const hasSpace = family.indexOf(" ") >= 0;
    const hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
    if (hasSpace && !hasQuotes) {
      family = `"${family}"`;
    }
    return family;
  }).join(", ");
}
var dummyContext2;
function getDummyContext2() {
  if (dummyContext2) {
    return dummyContext2;
  }
  dummyContext2 = Util.createCanvasElement().getContext(CONTEXT_2D);
  return dummyContext2;
}
function _fillFunc2(context) {
  context.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function _strokeFunc2(context) {
  context.setAttr("miterLimit", 2);
  context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function checkDefaultFill(config) {
  config = config || {};
  if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops && !config.fillPatternImage) {
    config.fill = config.fill || "black";
  }
  return config;
}
var Text = class extends Shape {
  constructor(config) {
    super(checkDefaultFill(config));
    this._partialTextX = 0;
    this._partialTextY = 0;
    for (let n = 0; n < attrChangeListLen; n++) {
      this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
    }
    this._setTextData();
  }
  _sceneFunc(context) {
    var _a, _b;
    const textArr = this.textArr, textArrLen = textArr.length;
    if (!this.text()) {
      return;
    }
    let padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), direction = this.direction(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), charRenderFunc = this.charRenderFunc(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n;
    direction = direction === INHERIT ? context.direction : direction;
    let translateY = lineHeightPx / 2;
    let baseline = MIDDLE;
    if (!Konva.legacyTextRendering) {
      const metrics = this.measureSize("M");
      baseline = "alphabetic";
      const ascent = (_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.actualBoundingBoxAscent;
      const descent = (_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.actualBoundingBoxDescent;
      translateY = (ascent - descent) / 2 + lineHeightPx / 2;
    }
    if (direction === RTL) {
      context.setAttr("direction", direction);
    }
    context.setAttr("font", this._getContextFont());
    context.setAttr("textBaseline", baseline);
    context.setAttr("textAlign", LEFT);
    if (verticalAlign === MIDDLE) {
      alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
    } else if (verticalAlign === BOTTOM) {
      alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
    }
    context.translate(padding, alignY + padding);
    for (n = 0; n < textArrLen; n++) {
      let lineTranslateX = 0;
      let lineTranslateY = 0;
      const obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph;
      context.save();
      if (align === RIGHT) {
        lineTranslateX += totalWidth - width - padding * 2;
      } else if (align === CENTER) {
        lineTranslateX += (totalWidth - width - padding * 2) / 2;
      }
      if (shouldUnderline) {
        context.save();
        context.beginPath();
        const yOffset = !Konva.legacyTextRendering ? Math.round(fontSize / 4) : Math.round(fontSize / 2);
        const x = lineTranslateX;
        const y = translateY + lineTranslateY + yOffset;
        context.moveTo(x, y);
        const lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
        context.lineTo(x + Math.round(lineWidth), y);
        context.lineWidth = fontSize / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill;
        context.stroke();
        context.restore();
      }
      const lineThroughStartX = lineTranslateX;
      if (direction !== RTL && (letterSpacing !== 0 || align === JUSTIFY || charRenderFunc)) {
        const spacesNumber = text.split(" ").length - 1;
        const array = stringToArray(text);
        for (let li = 0; li < array.length; li++) {
          const letter = array[li];
          if (letter === " " && !lastLine && align === JUSTIFY) {
            lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
          }
          this._partialTextX = lineTranslateX;
          this._partialTextY = translateY + lineTranslateY;
          this._partialText = letter;
          if (charRenderFunc) {
            context.save();
            const previousLines = textArr.slice(0, n);
            const previousGraphemes = previousLines.reduce((acc, line) => acc + stringToArray(line.text).length, 0);
            const charIndex = li + previousGraphemes;
            charRenderFunc({
              char: letter,
              index: charIndex,
              x: lineTranslateX,
              y: translateY + lineTranslateY,
              lineIndex: n,
              column: li,
              isLastInLine: lastLine,
              width: this.measureSize(letter).width,
              context
            });
          }
          context.fillStrokeShape(this);
          if (charRenderFunc) {
            context.restore();
          }
          lineTranslateX += this.measureSize(letter).width + letterSpacing;
        }
      } else {
        if (letterSpacing !== 0) {
          context.setAttr("letterSpacing", `${letterSpacing}px`);
        }
        this._partialTextX = lineTranslateX;
        this._partialTextY = translateY + lineTranslateY;
        this._partialText = text;
        context.fillStrokeShape(this);
      }
      if (shouldLineThrough) {
        context.save();
        context.beginPath();
        const yOffset = !Konva.legacyTextRendering ? -Math.round(fontSize / 4) : 0;
        const x = lineThroughStartX;
        context.moveTo(x, translateY + lineTranslateY + yOffset);
        const lineWidth = align === JUSTIFY && !lastLine ? totalWidth - padding * 2 : width;
        context.lineTo(x + Math.round(lineWidth), translateY + lineTranslateY + yOffset);
        context.lineWidth = fontSize / 15;
        const gradient = this._getLinearGradient();
        context.strokeStyle = gradient || fill;
        context.stroke();
        context.restore();
      }
      context.restore();
      if (textArrLen > 1) {
        translateY += lineHeightPx;
      }
    }
  }
  _hitFunc(context) {
    const width = this.getWidth(), height = this.getHeight();
    context.beginPath();
    context.rect(0, 0, width, height);
    context.closePath();
    context.fillStrokeShape(this);
  }
  setText(text) {
    const str = Util._isString(text) ? text : text === null || text === void 0 ? "" : text + "";
    this._setAttr(TEXT, str);
    return this;
  }
  getWidth() {
    const isAuto = this.attrs.width === AUTO || this.attrs.width === void 0;
    return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
  }
  getHeight() {
    const isAuto = this.attrs.height === AUTO || this.attrs.height === void 0;
    return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
  }
  getTextWidth() {
    return this.textWidth;
  }
  getTextHeight() {
    Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.");
    return this.textHeight;
  }
  measureSize(text) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let _context = getDummyContext2(), fontSize = this.fontSize(), metrics;
    _context.save();
    _context.font = this._getContextFont();
    metrics = _context.measureText(text);
    _context.restore();
    const scaleFactor = fontSize / 100;
    return {
      actualBoundingBoxAscent: (_a = metrics.actualBoundingBoxAscent) !== null && _a !== void 0 ? _a : 71.58203125 * scaleFactor,
      actualBoundingBoxDescent: (_b = metrics.actualBoundingBoxDescent) !== null && _b !== void 0 ? _b : 0,
      actualBoundingBoxLeft: (_c = metrics.actualBoundingBoxLeft) !== null && _c !== void 0 ? _c : -7.421875 * scaleFactor,
      actualBoundingBoxRight: (_d = metrics.actualBoundingBoxRight) !== null && _d !== void 0 ? _d : 75.732421875 * scaleFactor,
      alphabeticBaseline: (_e = metrics.alphabeticBaseline) !== null && _e !== void 0 ? _e : 0,
      emHeightAscent: (_f = metrics.emHeightAscent) !== null && _f !== void 0 ? _f : 100 * scaleFactor,
      emHeightDescent: (_g = metrics.emHeightDescent) !== null && _g !== void 0 ? _g : -20 * scaleFactor,
      fontBoundingBoxAscent: (_h = metrics.fontBoundingBoxAscent) !== null && _h !== void 0 ? _h : 91 * scaleFactor,
      fontBoundingBoxDescent: (_j = metrics.fontBoundingBoxDescent) !== null && _j !== void 0 ? _j : 21 * scaleFactor,
      hangingBaseline: (_k = metrics.hangingBaseline) !== null && _k !== void 0 ? _k : 72.80000305175781 * scaleFactor,
      ideographicBaseline: (_l = metrics.ideographicBaseline) !== null && _l !== void 0 ? _l : -21 * scaleFactor,
      width: metrics.width,
      height: fontSize
    };
  }
  _getContextFont() {
    return this.fontStyle() + SPACE2 + this.fontVariant() + SPACE2 + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
  }
  _addTextLine(line) {
    const align = this.align();
    if (align === JUSTIFY) {
      line = line.trim();
    }
    const width = this._getTextWidth(line);
    return this.textArr.push({
      text: line,
      width,
      lastInParagraph: false
    });
  }
  _getTextWidth(text) {
    const letterSpacing = this.letterSpacing();
    const length = text.length;
    return getDummyContext2().measureText(text).width + letterSpacing * length;
  }
  _setTextData() {
    let lines = this.text().split("\n"), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== void 0, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
    this.textArr = [];
    getDummyContext2().font = this._getContextFont();
    const additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
    for (let i = 0, max = lines.length; i < max; ++i) {
      let line = lines[i];
      let lineWidth = this._getTextWidth(line);
      if (fixedWidth && lineWidth > maxWidth) {
        while (line.length > 0) {
          let low = 0, high = stringToArray(line).length, match = "", matchWidth = 0;
          while (low < high) {
            const mid = low + high >>> 1, lineArray = stringToArray(line), substr = lineArray.slice(0, mid + 1).join(""), substrWidth = this._getTextWidth(substr);
            const shouldConsiderEllipsis = shouldAddEllipsis && fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
            const effectiveWidth = shouldConsiderEllipsis ? substrWidth + additionalWidth : substrWidth;
            if (effectiveWidth <= maxWidth) {
              low = mid + 1;
              match = substr;
              matchWidth = substrWidth;
            } else {
              high = mid;
            }
          }
          if (match) {
            if (wrapAtWord) {
              const lineArray2 = stringToArray(line);
              const matchArray = stringToArray(match);
              const nextChar = lineArray2[matchArray.length];
              const nextIsSpaceOrDash = nextChar === SPACE2 || nextChar === DASH;
              let wrapIndex;
              if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                wrapIndex = matchArray.length;
              } else {
                const lastSpaceIndex = matchArray.lastIndexOf(SPACE2);
                const lastDashIndex = matchArray.lastIndexOf(DASH);
                wrapIndex = Math.max(lastSpaceIndex, lastDashIndex) + 1;
              }
              if (wrapIndex > 0) {
                low = wrapIndex;
                match = lineArray2.slice(0, low).join("");
                matchWidth = this._getTextWidth(match);
              }
            }
            match = match.trimRight();
            this._addTextLine(match);
            textWidth = Math.max(textWidth, matchWidth);
            currentHeightPx += lineHeightPx;
            const shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
            if (shouldHandleEllipsis) {
              this._tryToAddEllipsisToLastLine();
              break;
            }
            const lineArray = stringToArray(line);
            line = lineArray.slice(low).join("").trimLeft();
            if (line.length > 0) {
              lineWidth = this._getTextWidth(line);
              if (lineWidth <= maxWidth) {
                this._addTextLine(line);
                currentHeightPx += lineHeightPx;
                textWidth = Math.max(textWidth, lineWidth);
                break;
              }
            }
          } else {
            break;
          }
        }
      } else {
        this._addTextLine(line);
        currentHeightPx += lineHeightPx;
        textWidth = Math.max(textWidth, lineWidth);
        if (this._shouldHandleEllipsis(currentHeightPx) && i < max - 1) {
          this._tryToAddEllipsisToLastLine();
        }
      }
      if (this.textArr[this.textArr.length - 1]) {
        this.textArr[this.textArr.length - 1].lastInParagraph = true;
      }
      if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
        break;
      }
    }
    this.textHeight = fontSize;
    this.textWidth = textWidth;
  }
  _shouldHandleEllipsis(currentHeightPx) {
    const fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
    return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
  }
  _tryToAddEllipsisToLastLine() {
    const width = this.attrs.width, fixedWidth = width !== AUTO && width !== void 0, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis();
    const lastLine = this.textArr[this.textArr.length - 1];
    if (!lastLine || !shouldAddEllipsis) {
      return;
    }
    if (fixedWidth) {
      const haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
      if (!haveSpace) {
        lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
      }
    }
    this.textArr.splice(this.textArr.length - 1, 1);
    this._addTextLine(lastLine.text + ELLIPSIS);
  }
  getStrokeScaleEnabled() {
    return true;
  }
  _useBufferCanvas() {
    const hasLine = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1;
    const hasShadow = this.hasShadow();
    if (hasLine && hasShadow) {
      return true;
    }
    return super._useBufferCanvas();
  }
};
Text.prototype._fillFunc = _fillFunc2;
Text.prototype._strokeFunc = _strokeFunc2;
Text.prototype.className = TEXT_UPPER;
Text.prototype._attrsAffectingSize = [
  "text",
  "fontSize",
  "padding",
  "wrap",
  "lineHeight",
  "letterSpacing"
];
_registerNode(Text);
Factory.overWriteSetter(Text, "width", getNumberOrAutoValidator());
Factory.overWriteSetter(Text, "height", getNumberOrAutoValidator());
Factory.addGetterSetter(Text, "direction", INHERIT);
Factory.addGetterSetter(Text, "fontFamily", "Arial");
Factory.addGetterSetter(Text, "fontSize", 12, getNumberValidator());
Factory.addGetterSetter(Text, "fontStyle", NORMAL);
Factory.addGetterSetter(Text, "fontVariant", NORMAL);
Factory.addGetterSetter(Text, "padding", 0, getNumberValidator());
Factory.addGetterSetter(Text, "align", LEFT);
Factory.addGetterSetter(Text, "verticalAlign", TOP);
Factory.addGetterSetter(Text, "lineHeight", 1, getNumberValidator());
Factory.addGetterSetter(Text, "wrap", WORD);
Factory.addGetterSetter(Text, "ellipsis", false, getBooleanValidator());
Factory.addGetterSetter(Text, "letterSpacing", 0, getNumberValidator());
Factory.addGetterSetter(Text, "text", "", getStringValidator());
Factory.addGetterSetter(Text, "textDecoration", "");
Factory.addGetterSetter(Text, "charRenderFunc", void 0);

// node_modules/.pnpm/waveform-data@4.5.2/node_modules/waveform-data/dist/waveform-data.esm.js
function WaveformDataChannel(waveformData, channelIndex) {
  this._waveformData = waveformData;
  this._channelIndex = channelIndex;
}
WaveformDataChannel.prototype.min_sample = function(index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._at(offset);
};
WaveformDataChannel.prototype.max_sample = function(index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._at(offset);
};
WaveformDataChannel.prototype.set_min_sample = function(index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._set_at(offset, sample);
};
WaveformDataChannel.prototype.set_max_sample = function(index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._set_at(offset, sample);
};
WaveformDataChannel.prototype.min_array = function() {
  var length = this._waveformData.length;
  var values = [];
  for (var i = 0; i < length; i++) {
    values.push(this.min_sample(i));
  }
  return values;
};
WaveformDataChannel.prototype.max_array = function() {
  var length = this._waveformData.length;
  var values = [];
  for (var i = 0; i < length; i++) {
    values.push(this.max_sample(i));
  }
  return values;
};
var INT8_MAX = 127;
var INT8_MIN = -128;
var INT16_MAX = 32767;
var INT16_MIN = -32768;
function calculateWaveformDataLength(audio_sample_count, scale) {
  var data_length = Math.floor(audio_sample_count / scale);
  var samples_remaining = audio_sample_count - data_length * scale;
  if (samples_remaining > 0) {
    data_length++;
  }
  return data_length;
}
function generateWaveformData(options) {
  var scale = options.scale;
  var amplitude_scale = options.amplitude_scale;
  var split_channels = options.split_channels;
  var length = options.length;
  var sample_rate = options.sample_rate;
  var channels = options.channels.map(function(channel3) {
    return new Float32Array(channel3);
  });
  var output_channels = split_channels ? channels.length : 1;
  var header_size = 24;
  var data_length = calculateWaveformDataLength(length, scale);
  var bytes_per_sample = options.bits === 8 ? 1 : 2;
  var total_size = header_size + data_length * 2 * bytes_per_sample * output_channels;
  var buffer = new ArrayBuffer(total_size);
  var data_view = new DataView(buffer);
  var scale_counter = 0;
  var offset = header_size;
  var min_value = new Array(output_channels);
  var max_value = new Array(output_channels);
  for (var channel2 = 0; channel2 < output_channels; channel2++) {
    min_value[channel2] = Infinity;
    max_value[channel2] = -Infinity;
  }
  var range_min = options.bits === 8 ? INT8_MIN : INT16_MIN;
  var range_max = options.bits === 8 ? INT8_MAX : INT16_MAX;
  data_view.setInt32(0, 2, true);
  data_view.setUint32(4, options.bits === 8, true);
  data_view.setInt32(8, sample_rate, true);
  data_view.setInt32(12, scale, true);
  data_view.setInt32(16, data_length, true);
  data_view.setInt32(20, output_channels, true);
  for (var i = 0; i < length; i++) {
    var sample = 0;
    if (output_channels === 1) {
      for (var _channel = 0; _channel < channels.length; ++_channel) {
        sample += channels[_channel][i];
      }
      sample = Math.floor(range_max * sample * amplitude_scale / channels.length);
      if (sample < min_value[0]) {
        min_value[0] = sample;
        if (min_value[0] < range_min) {
          min_value[0] = range_min;
        }
      }
      if (sample > max_value[0]) {
        max_value[0] = sample;
        if (max_value[0] > range_max) {
          max_value[0] = range_max;
        }
      }
    } else {
      for (var _channel2 = 0; _channel2 < output_channels; ++_channel2) {
        sample = Math.floor(range_max * channels[_channel2][i] * amplitude_scale);
        if (sample < min_value[_channel2]) {
          min_value[_channel2] = sample;
          if (min_value[_channel2] < range_min) {
            min_value[_channel2] = range_min;
          }
        }
        if (sample > max_value[_channel2]) {
          max_value[_channel2] = sample;
          if (max_value[_channel2] > range_max) {
            max_value[_channel2] = range_max;
          }
        }
      }
    }
    if (++scale_counter === scale) {
      for (var _channel3 = 0; _channel3 < output_channels; _channel3++) {
        if (options.bits === 8) {
          data_view.setInt8(offset++, min_value[_channel3]);
          data_view.setInt8(offset++, max_value[_channel3]);
        } else {
          data_view.setInt16(offset, min_value[_channel3], true);
          data_view.setInt16(offset + 2, max_value[_channel3], true);
          offset += 4;
        }
        min_value[_channel3] = Infinity;
        max_value[_channel3] = -Infinity;
      }
      scale_counter = 0;
    }
  }
  if (scale_counter > 0) {
    for (var _channel4 = 0; _channel4 < output_channels; _channel4++) {
      if (options.bits === 8) {
        data_view.setInt8(offset++, min_value[_channel4]);
        data_view.setInt8(offset++, max_value[_channel4]);
      } else {
        data_view.setInt16(offset, min_value[_channel4], true);
        data_view.setInt16(offset + 2, max_value[_channel4], true);
      }
    }
  }
  return buffer;
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function isJsonWaveformData(data) {
  return data && _typeof(data) === "object" && "sample_rate" in data && "samples_per_pixel" in data && "bits" in data && "length" in data && "data" in data;
}
function isBinaryWaveformData(data) {
  var isCompatible = data && _typeof(data) === "object" && "byteLength" in data;
  if (isCompatible) {
    var view = new DataView(data);
    var version = view.getInt32(0, true);
    if (version !== 1 && version !== 2) {
      throw new TypeError("WaveformData.create(): This waveform data version not supported");
    }
  }
  return isCompatible;
}
function convertJsonToBinary(data) {
  var waveformData = data.data;
  var channels = data.channels || 1;
  var header_size = 24;
  var bytes_per_sample = data.bits === 8 ? 1 : 2;
  var expected_length = data.length * 2 * channels;
  if (waveformData.length !== expected_length) {
    throw new Error("WaveformData.create(): Length mismatch in JSON waveform data");
  }
  var total_size = header_size + waveformData.length * bytes_per_sample;
  var array_buffer = new ArrayBuffer(total_size);
  var data_object = new DataView(array_buffer);
  data_object.setInt32(0, 2, true);
  data_object.setUint32(4, data.bits === 8, true);
  data_object.setInt32(8, data.sample_rate, true);
  data_object.setInt32(12, data.samples_per_pixel, true);
  data_object.setInt32(16, data.length, true);
  data_object.setInt32(20, channels, true);
  var index = header_size;
  if (data.bits === 8) {
    for (var i = 0; i < waveformData.length; i++) {
      data_object.setInt8(index++, waveformData[i], true);
    }
  } else {
    for (var _i = 0; _i < waveformData.length; _i++) {
      data_object.setInt16(index, waveformData[_i], true);
      index += 2;
    }
  }
  return array_buffer;
}
function isNullOrUndefined(value) {
  return value === void 0 || value === null;
}
function decodeBase64(base64, enableUnicode) {
  var binaryString = atob(base64);
  if (enableUnicode) {
    var binaryView = new Uint8Array(binaryString.length);
    for (var i = 0, n = binaryString.length; i < n; ++i) {
      binaryView[i] = binaryString.charCodeAt(i);
    }
    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
  }
  return binaryString;
}
function createURL(base64, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64(base64, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  var blob = new Blob([body], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
    return new Worker(url, options);
  };
}
var WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQXVkaW9CdWZmZXItYmFzZWQgV2F2ZWZvcm1EYXRhIGdlbmVyYXRvcgogICAqCiAgICogQWRhcHRlZCBmcm9tIEJsb2NrRmlsZTo6Q2FsY1N1bW1hcnkgaW4gQXVkYWNpdHksIHdpdGggcGVybWlzc2lvbi4KICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F1ZGFjaXR5L2F1ZGFjaXR5L2Jsb2IvCiAgICogICAxMTA4YzEzNzZjMDkxNjYxNjIzMzVmYWI0NzQzMDA4Y2JhNTdjNGVlL3NyYy9CbG9ja0ZpbGUuY3BwI0wxOTgKICAgKi8KCiAgdmFyIElOVDhfTUFYID0gMTI3OwogIHZhciBJTlQ4X01JTiA9IC0xMjg7CiAgdmFyIElOVDE2X01BWCA9IDMyNzY3OwogIHZhciBJTlQxNl9NSU4gPSAtMzI3Njg7CiAgZnVuY3Rpb24gY2FsY3VsYXRlV2F2ZWZvcm1EYXRhTGVuZ3RoKGF1ZGlvX3NhbXBsZV9jb3VudCwgc2NhbGUpIHsKICAgIHZhciBkYXRhX2xlbmd0aCA9IE1hdGguZmxvb3IoYXVkaW9fc2FtcGxlX2NvdW50IC8gc2NhbGUpOwogICAgdmFyIHNhbXBsZXNfcmVtYWluaW5nID0gYXVkaW9fc2FtcGxlX2NvdW50IC0gZGF0YV9sZW5ndGggKiBzY2FsZTsKICAgIGlmIChzYW1wbGVzX3JlbWFpbmluZyA+IDApIHsKICAgICAgZGF0YV9sZW5ndGgrKzsKICAgIH0KICAgIHJldHVybiBkYXRhX2xlbmd0aDsKICB9CiAgZnVuY3Rpb24gZ2VuZXJhdGVXYXZlZm9ybURhdGEob3B0aW9ucykgewogICAgdmFyIHNjYWxlID0gb3B0aW9ucy5zY2FsZTsKICAgIHZhciBhbXBsaXR1ZGVfc2NhbGUgPSBvcHRpb25zLmFtcGxpdHVkZV9zY2FsZTsKICAgIHZhciBzcGxpdF9jaGFubmVscyA9IG9wdGlvbnMuc3BsaXRfY2hhbm5lbHM7CiAgICB2YXIgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7CiAgICB2YXIgc2FtcGxlX3JhdGUgPSBvcHRpb25zLnNhbXBsZV9yYXRlOwogICAgdmFyIGNoYW5uZWxzID0gb3B0aW9ucy5jaGFubmVscy5tYXAoZnVuY3Rpb24gKGNoYW5uZWwpIHsKICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY2hhbm5lbCk7CiAgICB9KTsKICAgIHZhciBvdXRwdXRfY2hhbm5lbHMgPSBzcGxpdF9jaGFubmVscyA/IGNoYW5uZWxzLmxlbmd0aCA6IDE7CiAgICB2YXIgaGVhZGVyX3NpemUgPSAyNDsKICAgIHZhciBkYXRhX2xlbmd0aCA9IGNhbGN1bGF0ZVdhdmVmb3JtRGF0YUxlbmd0aChsZW5ndGgsIHNjYWxlKTsKICAgIHZhciBieXRlc19wZXJfc2FtcGxlID0gb3B0aW9ucy5iaXRzID09PSA4ID8gMSA6IDI7CiAgICB2YXIgdG90YWxfc2l6ZSA9IGhlYWRlcl9zaXplICsgZGF0YV9sZW5ndGggKiAyICogYnl0ZXNfcGVyX3NhbXBsZSAqIG91dHB1dF9jaGFubmVsczsKICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodG90YWxfc2l6ZSk7CiAgICB2YXIgZGF0YV92aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7CiAgICB2YXIgc2NhbGVfY291bnRlciA9IDA7CiAgICB2YXIgb2Zmc2V0ID0gaGVhZGVyX3NpemU7CiAgICB2YXIgbWluX3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CiAgICB2YXIgbWF4X3ZhbHVlID0gbmV3IEFycmF5KG91dHB1dF9jaGFubmVscyk7CiAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG91dHB1dF9jaGFubmVsczsgY2hhbm5lbCsrKSB7CiAgICAgIG1pbl92YWx1ZVtjaGFubmVsXSA9IEluZmluaXR5OwogICAgICBtYXhfdmFsdWVbY2hhbm5lbF0gPSAtSW5maW5pdHk7CiAgICB9CiAgICB2YXIgcmFuZ2VfbWluID0gb3B0aW9ucy5iaXRzID09PSA4ID8gSU5UOF9NSU4gOiBJTlQxNl9NSU47CiAgICB2YXIgcmFuZ2VfbWF4ID0gb3B0aW9ucy5iaXRzID09PSA4ID8gSU5UOF9NQVggOiBJTlQxNl9NQVg7CiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMCwgMiwgdHJ1ZSk7IC8vIFZlcnNpb24KICAgIGRhdGFfdmlldy5zZXRVaW50MzIoNCwgb3B0aW9ucy5iaXRzID09PSA4LCB0cnVlKTsgLy8gSXMgOCBiaXQ/CiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoOCwgc2FtcGxlX3JhdGUsIHRydWUpOyAvLyBTYW1wbGUgcmF0ZQogICAgZGF0YV92aWV3LnNldEludDMyKDEyLCBzY2FsZSwgdHJ1ZSk7IC8vIFNjYWxlCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMTYsIGRhdGFfbGVuZ3RoLCB0cnVlKTsgLy8gTGVuZ3RoCiAgICBkYXRhX3ZpZXcuc2V0SW50MzIoMjAsIG91dHB1dF9jaGFubmVscywgdHJ1ZSk7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBzYW1wbGUgPSAwOwogICAgICBpZiAob3V0cHV0X2NoYW5uZWxzID09PSAxKSB7CiAgICAgICAgZm9yICh2YXIgX2NoYW5uZWwgPSAwOyBfY2hhbm5lbCA8IGNoYW5uZWxzLmxlbmd0aDsgKytfY2hhbm5lbCkgewogICAgICAgICAgc2FtcGxlICs9IGNoYW5uZWxzW19jaGFubmVsXVtpXTsKICAgICAgICB9CiAgICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihyYW5nZV9tYXggKiBzYW1wbGUgKiBhbXBsaXR1ZGVfc2NhbGUgLyBjaGFubmVscy5sZW5ndGgpOwogICAgICAgIGlmIChzYW1wbGUgPCBtaW5fdmFsdWVbMF0pIHsKICAgICAgICAgIG1pbl92YWx1ZVswXSA9IHNhbXBsZTsKICAgICAgICAgIGlmIChtaW5fdmFsdWVbMF0gPCByYW5nZV9taW4pIHsKICAgICAgICAgICAgbWluX3ZhbHVlWzBdID0gcmFuZ2VfbWluOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoc2FtcGxlID4gbWF4X3ZhbHVlWzBdKSB7CiAgICAgICAgICBtYXhfdmFsdWVbMF0gPSBzYW1wbGU7CiAgICAgICAgICBpZiAobWF4X3ZhbHVlWzBdID4gcmFuZ2VfbWF4KSB7CiAgICAgICAgICAgIG1heF92YWx1ZVswXSA9IHJhbmdlX21heDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yICh2YXIgX2NoYW5uZWwyID0gMDsgX2NoYW5uZWwyIDwgb3V0cHV0X2NoYW5uZWxzOyArK19jaGFubmVsMikgewogICAgICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihyYW5nZV9tYXggKiBjaGFubmVsc1tfY2hhbm5lbDJdW2ldICogYW1wbGl0dWRlX3NjYWxlKTsKICAgICAgICAgIGlmIChzYW1wbGUgPCBtaW5fdmFsdWVbX2NoYW5uZWwyXSkgewogICAgICAgICAgICBtaW5fdmFsdWVbX2NoYW5uZWwyXSA9IHNhbXBsZTsKICAgICAgICAgICAgaWYgKG1pbl92YWx1ZVtfY2hhbm5lbDJdIDwgcmFuZ2VfbWluKSB7CiAgICAgICAgICAgICAgbWluX3ZhbHVlW19jaGFubmVsMl0gPSByYW5nZV9taW47CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzYW1wbGUgPiBtYXhfdmFsdWVbX2NoYW5uZWwyXSkgewogICAgICAgICAgICBtYXhfdmFsdWVbX2NoYW5uZWwyXSA9IHNhbXBsZTsKICAgICAgICAgICAgaWYgKG1heF92YWx1ZVtfY2hhbm5lbDJdID4gcmFuZ2VfbWF4KSB7CiAgICAgICAgICAgICAgbWF4X3ZhbHVlW19jaGFubmVsMl0gPSByYW5nZV9tYXg7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKCsrc2NhbGVfY291bnRlciA9PT0gc2NhbGUpIHsKICAgICAgICBmb3IgKHZhciBfY2hhbm5lbDMgPSAwOyBfY2hhbm5lbDMgPCBvdXRwdXRfY2hhbm5lbHM7IF9jaGFubmVsMysrKSB7CiAgICAgICAgICBpZiAob3B0aW9ucy5iaXRzID09PSA4KSB7CiAgICAgICAgICAgIGRhdGFfdmlldy5zZXRJbnQ4KG9mZnNldCsrLCBtaW5fdmFsdWVbX2NoYW5uZWwzXSk7CiAgICAgICAgICAgIGRhdGFfdmlldy5zZXRJbnQ4KG9mZnNldCsrLCBtYXhfdmFsdWVbX2NoYW5uZWwzXSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50MTYob2Zmc2V0LCBtaW5fdmFsdWVbX2NoYW5uZWwzXSwgdHJ1ZSk7CiAgICAgICAgICAgIGRhdGFfdmlldy5zZXRJbnQxNihvZmZzZXQgKyAyLCBtYXhfdmFsdWVbX2NoYW5uZWwzXSwgdHJ1ZSk7CiAgICAgICAgICAgIG9mZnNldCArPSA0OwogICAgICAgICAgfQogICAgICAgICAgbWluX3ZhbHVlW19jaGFubmVsM10gPSBJbmZpbml0eTsKICAgICAgICAgIG1heF92YWx1ZVtfY2hhbm5lbDNdID0gLUluZmluaXR5OwogICAgICAgIH0KICAgICAgICBzY2FsZV9jb3VudGVyID0gMDsKICAgICAgfQogICAgfQogICAgaWYgKHNjYWxlX2NvdW50ZXIgPiAwKSB7CiAgICAgIGZvciAodmFyIF9jaGFubmVsNCA9IDA7IF9jaGFubmVsNCA8IG91dHB1dF9jaGFubmVsczsgX2NoYW5uZWw0KyspIHsKICAgICAgICBpZiAob3B0aW9ucy5iaXRzID09PSA4KSB7CiAgICAgICAgICBkYXRhX3ZpZXcuc2V0SW50OChvZmZzZXQrKywgbWluX3ZhbHVlW19jaGFubmVsNF0pOwogICAgICAgICAgZGF0YV92aWV3LnNldEludDgob2Zmc2V0KyssIG1heF92YWx1ZVtfY2hhbm5lbDRdKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGF0YV92aWV3LnNldEludDE2KG9mZnNldCwgbWluX3ZhbHVlW19jaGFubmVsNF0sIHRydWUpOwogICAgICAgICAgZGF0YV92aWV3LnNldEludDE2KG9mZnNldCArIDIsIG1heF92YWx1ZVtfY2hhbm5lbDRdLCB0cnVlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBidWZmZXI7CiAgfQoKICBvbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoZXZ0KSB7CiAgICB2YXIgYnVmZmVyID0gZ2VuZXJhdGVXYXZlZm9ybURhdGEoZXZ0LmRhdGEpOwoKICAgIC8vIFRyYW5zZmVyIGJ1ZmZlciB0byB0aGUgY2FsbGluZyB0aHJlYWQKICAgIHRoaXMucG9zdE1lc3NhZ2UoYnVmZmVyLCBbYnVmZmVyXSk7CiAgICB0aGlzLmNsb3NlKCk7CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVmb3JtLWRhdGEtd29ya2VyLmpzLm1hcAoK", null, false);
function WaveformData(data) {
  if (isJsonWaveformData(data)) {
    data = convertJsonToBinary(data);
  }
  if (isBinaryWaveformData(data)) {
    this._data = new DataView(data);
    this._offset = this._version() === 2 ? 24 : 20;
    this._channels = [];
    for (var channel2 = 0; channel2 < this.channels; channel2++) {
      this._channels[channel2] = new WaveformDataChannel(this, channel2);
    }
  } else {
    throw new TypeError("WaveformData.create(): Unknown data format");
  }
}
var defaultOptions = {
  scale: 512,
  bits: 8,
  amplitude_scale: 1,
  split_channels: false,
  disable_worker: false
};
function getOptions(options) {
  var opts = {
    scale: options.scale || defaultOptions.scale,
    bits: options.bits || defaultOptions.bits,
    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,
    split_channels: options.split_channels || defaultOptions.split_channels,
    disable_worker: options.disable_worker || defaultOptions.disable_worker
  };
  return opts;
}
function getChannelData(audio_buffer) {
  var channels = [];
  for (var i = 0; i < audio_buffer.numberOfChannels; ++i) {
    channels.push(audio_buffer.getChannelData(i).buffer);
  }
  return channels;
}
function createFromAudioBuffer(audio_buffer, options, callback) {
  var channels = getChannelData(audio_buffer);
  if (options.disable_worker) {
    var buffer = generateWaveformData({
      scale: options.scale,
      bits: options.bits,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels
    });
    callback(void 0, new WaveformData(buffer), audio_buffer);
  } else {
    var worker = new WorkerFactory();
    worker.onmessage = function(evt) {
      callback(void 0, new WaveformData(evt.data), audio_buffer);
    };
    worker.postMessage({
      scale: options.scale,
      bits: options.bits,
      amplitude_scale: options.amplitude_scale,
      split_channels: options.split_channels,
      length: audio_buffer.length,
      sample_rate: audio_buffer.sampleRate,
      channels
    }, channels);
  }
}
function createFromArrayBuffer(audioContext, audioData, options, callback) {
  function errorCallback(error) {
    if (!error) {
      error = new DOMException("EncodingError");
    }
    callback(error);
    callback = function callback2() {
    };
  }
  var promise = audioContext.decodeAudioData(audioData, function(audio_buffer) {
    createFromAudioBuffer(audio_buffer, options, callback);
  }, errorCallback);
  if (promise) {
    promise.catch(errorCallback);
  }
}
WaveformData.create = function create(data) {
  return new WaveformData(data);
};
WaveformData.createFromAudio = function(options, callback) {
  var opts = getOptions(options);
  if (options.audio_context && options.array_buffer) {
    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);
  } else if (options.audio_buffer) {
    return createFromAudioBuffer(options.audio_buffer, opts, callback);
  } else {
    throw new TypeError(
      // eslint-disable-next-line
      "WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object"
    );
  }
};
function WaveformResampler(options) {
  this._inputData = options.waveformData;
  this._output_samples_per_pixel = options.scale;
  this._scale = this._inputData.scale;
  this._input_buffer_size = this._inputData.length;
  var input_buffer_length_samples = this._input_buffer_size * this._inputData.scale;
  var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / this._output_samples_per_pixel);
  var output_header_size = 24;
  var bytes_per_sample = this._inputData.bits === 8 ? 1 : 2;
  var total_size = output_header_size + output_buffer_length_samples * 2 * this._inputData.channels * bytes_per_sample;
  this._output_data = new ArrayBuffer(total_size);
  this.output_dataview = new DataView(this._output_data);
  this.output_dataview.setInt32(0, 2, true);
  this.output_dataview.setUint32(4, this._inputData.bits === 8, true);
  this.output_dataview.setInt32(8, this._inputData.sample_rate, true);
  this.output_dataview.setInt32(12, this._output_samples_per_pixel, true);
  this.output_dataview.setInt32(16, output_buffer_length_samples, true);
  this.output_dataview.setInt32(20, this._inputData.channels, true);
  this._outputWaveformData = new WaveformData(this._output_data);
  this._input_index = 0;
  this._output_index = 0;
  var channels = this._inputData.channels;
  this._min = new Array(channels);
  this._max = new Array(channels);
  for (var channel2 = 0; channel2 < channels; ++channel2) {
    if (this._input_buffer_size > 0) {
      this._min[channel2] = this._inputData.channel(channel2).min_sample(this._input_index);
      this._max[channel2] = this._inputData.channel(channel2).max_sample(this._input_index);
    } else {
      this._min[channel2] = 0;
      this._max[channel2] = 0;
    }
  }
  this._min_value = this._inputData.bits === 8 ? -128 : -32768;
  this._max_value = this._inputData.bits === 8 ? 127 : 32767;
  this._where = 0;
  this._prev_where = 0;
  this._stop = 0;
  this._last_input_index = 0;
}
WaveformResampler.prototype.sample_at_pixel = function(x) {
  return Math.floor(x * this._output_samples_per_pixel);
};
WaveformResampler.prototype.next = function() {
  var count = 0;
  var total = 1e3;
  var channels = this._inputData.channels;
  var channel2;
  while (this._input_index < this._input_buffer_size && count < total) {
    while (Math.floor(this.sample_at_pixel(this._output_index) / this._scale) === this._input_index) {
      if (this._output_index > 0) {
        for (var i = 0; i < channels; ++i) {
          channel2 = this._outputWaveformData.channel(i);
          channel2.set_min_sample(this._output_index - 1, this._min[i]);
          channel2.set_max_sample(this._output_index - 1, this._max[i]);
        }
      }
      this._last_input_index = this._input_index;
      this._output_index++;
      this._where = this.sample_at_pixel(this._output_index);
      this._prev_where = this.sample_at_pixel(this._output_index - 1);
      if (this._where !== this._prev_where) {
        for (var _i = 0; _i < channels; ++_i) {
          this._min[_i] = this._max_value;
          this._max[_i] = this._min_value;
        }
      }
    }
    this._where = this.sample_at_pixel(this._output_index);
    this._stop = Math.floor(this._where / this._scale);
    if (this._stop > this._input_buffer_size) {
      this._stop = this._input_buffer_size;
    }
    while (this._input_index < this._stop) {
      for (var _i2 = 0; _i2 < channels; ++_i2) {
        channel2 = this._inputData.channel(_i2);
        var value = channel2.min_sample(this._input_index);
        if (value < this._min[_i2]) {
          this._min[_i2] = value;
        }
        value = channel2.max_sample(this._input_index);
        if (value > this._max[_i2]) {
          this._max[_i2] = value;
        }
      }
      this._input_index++;
    }
    count++;
  }
  if (this._input_index < this._input_buffer_size) {
    return false;
  } else {
    if (this._input_index !== this._last_input_index) {
      for (var _i3 = 0; _i3 < channels; ++_i3) {
        channel2 = this._outputWaveformData.channel(_i3);
        channel2.set_min_sample(this._output_index - 1, this._min[_i3]);
        channel2.set_max_sample(this._output_index - 1, this._max[_i3]);
      }
    }
    return true;
  }
};
WaveformResampler.prototype.getOutputData = function() {
  return this._output_data;
};
WaveformData.prototype = {
  _getResampleOptions: function _getResampleOptions(options) {
    var opts = {};
    opts.scale = options.scale;
    opts.width = options.width;
    if (!isNullOrUndefined(opts.width) && (typeof opts.width !== "number" || opts.width <= 0)) {
      throw new RangeError("WaveformData.resample(): width should be a positive integer value");
    }
    if (!isNullOrUndefined(opts.scale) && (typeof opts.scale !== "number" || opts.scale <= 0)) {
      throw new RangeError("WaveformData.resample(): scale should be a positive integer value");
    }
    if (!opts.scale && !opts.width) {
      throw new Error("WaveformData.resample(): Missing scale or width option");
    }
    if (opts.width) {
      opts.scale = Math.floor(this.duration * this.sample_rate / opts.width);
    }
    if (opts.scale < this.scale) {
      throw new Error("WaveformData.resample(): Zoom level " + opts.scale + " too low, minimum: " + this.scale);
    }
    opts.abortSignal = options.abortSignal;
    return opts;
  },
  resample: function resample(options) {
    options = this._getResampleOptions(options);
    options.waveformData = this;
    var resampler = new WaveformResampler(options);
    while (!resampler.next()) {
    }
    return new WaveformData(resampler.getOutputData());
  },
  /**
   * Concatenates with one or more other waveforms, returning a new WaveformData object.
   */
  concat: function concat() {
    var self2 = this;
    var otherWaveforms = Array.prototype.slice.call(arguments);
    otherWaveforms.forEach(function(otherWaveform) {
      if (self2.channels !== otherWaveform.channels || self2.sample_rate !== otherWaveform.sample_rate || self2.bits !== otherWaveform.bits || self2.scale !== otherWaveform.scale) {
        throw new Error("WaveformData.concat(): Waveforms are incompatible");
      }
    });
    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);
    return WaveformData.create(combinedBuffer);
  },
  /**
   * Returns a new ArrayBuffer with the concatenated waveform.
   * All waveforms must have identical metadata (version, channels, etc)
   */
  _concatBuffers: function _concatBuffers() {
    var otherWaveforms = Array.prototype.slice.call(arguments);
    var headerSize = this._offset;
    var totalSize = headerSize;
    var totalDataLength = 0;
    var bufferCollection = [this].concat(otherWaveforms).map(function(w) {
      return w._data.buffer;
    });
    for (var i = 0; i < bufferCollection.length; i++) {
      var buffer = bufferCollection[i];
      var dataSize = new DataView(buffer).getInt32(16, true);
      totalSize += buffer.byteLength - headerSize;
      totalDataLength += dataSize;
    }
    var totalBuffer = new ArrayBuffer(totalSize);
    var sourceHeader = new DataView(bufferCollection[0]);
    var totalBufferView = new DataView(totalBuffer);
    for (var _i4 = 0; _i4 < headerSize; _i4++) {
      totalBufferView.setUint8(_i4, sourceHeader.getUint8(_i4));
    }
    totalBufferView.setInt32(16, totalDataLength, true);
    var offset = 0;
    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);
    for (var _i5 = 0; _i5 < bufferCollection.length; _i5++) {
      var _buffer = bufferCollection[_i5];
      dataOfTotalBuffer.set(new Uint8Array(_buffer, headerSize), offset);
      offset += _buffer.byteLength - headerSize;
    }
    return totalBuffer;
  },
  slice: function slice(options) {
    var startIndex = 0;
    var endIndex = 0;
    if (!isNullOrUndefined(options.startIndex) && !isNullOrUndefined(options.endIndex)) {
      startIndex = options.startIndex;
      endIndex = options.endIndex;
    } else if (!isNullOrUndefined(options.startTime) && !isNullOrUndefined(options.endTime)) {
      startIndex = this.at_time(options.startTime);
      endIndex = this.at_time(options.endTime);
    }
    if (startIndex < 0) {
      throw new RangeError("startIndex or startTime must not be negative");
    }
    if (endIndex < 0) {
      throw new RangeError("endIndex or endTime must not be negative");
    }
    if (startIndex > this.length) {
      startIndex = this.length;
    }
    if (endIndex > this.length) {
      endIndex = this.length;
    }
    if (startIndex > endIndex) {
      startIndex = endIndex;
    }
    var length = endIndex - startIndex;
    var header_size = 24;
    var bytes_per_sample = this.bits === 8 ? 1 : 2;
    var total_size = header_size + length * 2 * this.channels * bytes_per_sample;
    var output_data = new ArrayBuffer(total_size);
    var output_dataview = new DataView(output_data);
    output_dataview.setInt32(0, 2, true);
    output_dataview.setUint32(4, this.bits === 8, true);
    output_dataview.setInt32(8, this.sample_rate, true);
    output_dataview.setInt32(12, this.scale, true);
    output_dataview.setInt32(16, length, true);
    output_dataview.setInt32(20, this.channels, true);
    for (var i = 0; i < length * this.channels * 2; i++) {
      var sample = this._at(startIndex * this.channels * 2 + i);
      if (this.bits === 8) {
        output_dataview.setInt8(header_size + i, sample);
      } else {
        output_dataview.setInt16(header_size + i * 2, sample, true);
      }
    }
    return new WaveformData(output_data);
  },
  /**
   * Returns the data format version number.
   */
  _version: function _version() {
    return this._data.getInt32(0, true);
  },
  /**
   * Returns the length of the waveform, in pixels.
   */
  get length() {
    return this._data.getUint32(16, true);
  },
  /**
   * Returns the number of bits per sample, either 8 or 16.
   */
  get bits() {
    var bits = Boolean(this._data.getUint32(4, true));
    return bits ? 8 : 16;
  },
  /**
   * Returns the (approximate) duration of the audio file, in seconds.
   */
  get duration() {
    return this.length * this.scale / this.sample_rate;
  },
  /**
   * Returns the number of pixels per second.
   */
  get pixels_per_second() {
    return this.sample_rate / this.scale;
  },
  /**
   * Returns the amount of time represented by a single pixel, in seconds.
   */
  get seconds_per_pixel() {
    return this.scale / this.sample_rate;
  },
  /**
   * Returns the number of waveform channels.
   */
  get channels() {
    if (this._version() === 2) {
      return this._data.getInt32(20, true);
    } else {
      return 1;
    }
  },
  /**
   * Returns a waveform channel.
   */
  channel: function channel(index) {
    if (index >= 0 && index < this._channels.length) {
      return this._channels[index];
    } else {
      throw new RangeError("Invalid channel: " + index);
    }
  },
  /**
   * Returns the number of audio samples per second.
   */
  get sample_rate() {
    return this._data.getInt32(8, true);
  },
  /**
   * Returns the number of audio samples per pixel.
   */
  get scale() {
    return this._data.getInt32(12, true);
  },
  /**
   * Returns a waveform data value at a specific offset.
   */
  _at: function at_sample(index) {
    if (this.bits === 8) {
      return this._data.getInt8(this._offset + index);
    } else {
      return this._data.getInt16(this._offset + index * 2, true);
    }
  },
  /**
   * Sets a waveform data value at a specific offset.
   */
  _set_at: function set_at(index, sample) {
    if (this.bits === 8) {
      return this._data.setInt8(this._offset + index, sample);
    } else {
      return this._data.setInt16(this._offset + index * 2, sample, true);
    }
  },
  /**
   * Returns the waveform data index position for a given time.
   */
  at_time: function at_time(time2) {
    return Math.floor(time2 * this.sample_rate / this.scale);
  },
  /**
   * Returns the time in seconds for a given index.
   */
  time: function time(index) {
    return index * this.scale / this.sample_rate;
  },
  /**
   * Returns an object containing the waveform data.
   */
  toJSON: function toJSON() {
    var waveform = {
      version: 2,
      channels: this.channels,
      sample_rate: this.sample_rate,
      samples_per_pixel: this.scale,
      bits: this.bits,
      length: this.length,
      data: []
    };
    for (var i = 0; i < this.length; i++) {
      for (var channel2 = 0; channel2 < this.channels; channel2++) {
        waveform.data.push(this.channel(channel2).min_sample(i));
        waveform.data.push(this.channel(channel2).max_sample(i));
      }
    }
    return waveform;
  },
  /**
   * Returns the waveform data in binary format as an ArrayBuffer.
   */
  toArrayBuffer: function toArrayBuffer() {
    return this._data.buffer;
  }
};

// node_modules/.pnpm/peaks.js@4.0.0_konva@10.0.11_waveform-data@4.5.2/node_modules/peaks.js/dist/peaks.esm.js
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames2() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
var EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
function _typeof2(o) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof2(o);
}
function Cue(time2, type, id) {
  this.time = time2;
  this.type = type;
  this.id = id;
}
Cue.POINT = 0;
Cue.SEGMENT_START = 1;
Cue.SEGMENT_END = 2;
Cue.sorter = function(a, b) {
  return a.time - b.time;
};
function zeroPad(number, precision) {
  number = number.toString();
  while (number.length < precision) {
    number = "0" + number;
  }
  return number;
}
function formatTime(time2, precision) {
  var result = [];
  var fractionSeconds = Math.floor(time2 % 1 * Math.pow(10, precision));
  var seconds = Math.floor(time2);
  var minutes = Math.floor(seconds / 60);
  var hours = Math.floor(minutes / 60);
  if (hours > 0) {
    result.push(hours);
  }
  result.push(minutes % 60);
  result.push(seconds % 60);
  for (var i = 0; i < result.length; i++) {
    result[i] = zeroPad(result[i], 2);
  }
  result = result.join(":");
  if (precision > 0) {
    result += "." + zeroPad(fractionSeconds, precision);
  }
  return result;
}
function roundUpToNearest(value, multiple) {
  if (multiple === 0) {
    return 0;
  }
  var multiplier = 1;
  if (value < 0) {
    multiplier = -1;
    value = -value;
  }
  var roundedUp = Math.ceil(value);
  return multiplier * ((roundedUp + multiple - 1) / multiple | 0) * multiple;
}
function clamp(value, min, max) {
  if (value < min) {
    return min;
  } else if (value > max) {
    return max;
  } else {
    return value;
  }
}
function objectHasProperty(object, field) {
  return Object.prototype.hasOwnProperty.call(object, field);
}
function extend(to, from) {
  for (var key in from) {
    if (objectHasProperty(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function isInAscendingOrder(array) {
  if (array.length === 0) {
    return true;
  }
  var value = array[0];
  for (var i = 1; i < array.length; i++) {
    if (value >= array[i]) {
      return false;
    }
    value = array[i];
  }
  return true;
}
function isNumber(value) {
  return typeof value === "number";
}
function isFinite2(value) {
  if (typeof value !== "number") {
    return false;
  }
  if (value !== value || value === Infinity || value === -Infinity) {
    return false;
  }
  return true;
}
function isValidTime(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function isObject(value) {
  return value !== null && _typeof2(value) === "object" && !Array.isArray(value);
}
function isString(value) {
  return typeof value === "string";
}
function isArrayBuffer(value) {
  return Object.prototype.toString.call(value).includes("ArrayBuffer");
}
function isNullOrUndefined2(value) {
  return value === void 0 || value === null;
}
function isFunction(value) {
  return typeof value === "function";
}
function isBoolean(value) {
  return value === true || value === false;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement;
}
function isArray(value) {
  return Array.isArray(value);
}
function isLinearGradientColor(value) {
  return isObject(value) && objectHasProperty(value, "linearGradientStart") && objectHasProperty(value, "linearGradientEnd") && objectHasProperty(value, "linearGradientColorStops") && isNumber(value.linearGradientStart) && isNumber(value.linearGradientEnd) && isArray(value.linearGradientColorStops) && value.linearGradientColorStops.length === 2;
}
function getMarkerObject(obj) {
  while (obj.parent !== null) {
    if (obj.parent instanceof Core_default.Layer) {
      return obj;
    }
    obj = obj.parent;
  }
  return null;
}
var isHeadless = /HeadlessChrome/.test(navigator.userAgent);
function windowIsVisible() {
  if (isHeadless || navigator.webdriver) {
    return false;
  }
  return (typeof document === "undefined" ? "undefined" : _typeof2(document)) === "object" && "visibilityState" in document && document.visibilityState === "visible";
}
var requestAnimationFrame2 = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
var eventTypes = {
  forward: {},
  reverse: {}
};
var EVENT_TYPE_POINT = 0;
var EVENT_TYPE_SEGMENT_ENTER = 1;
var EVENT_TYPE_SEGMENT_EXIT = 2;
eventTypes.forward[Cue.POINT] = EVENT_TYPE_POINT;
eventTypes.forward[Cue.SEGMENT_START] = EVENT_TYPE_SEGMENT_ENTER;
eventTypes.forward[Cue.SEGMENT_END] = EVENT_TYPE_SEGMENT_EXIT;
eventTypes.reverse[Cue.POINT] = EVENT_TYPE_POINT;
eventTypes.reverse[Cue.SEGMENT_START] = EVENT_TYPE_SEGMENT_EXIT;
eventTypes.reverse[Cue.SEGMENT_END] = EVENT_TYPE_SEGMENT_ENTER;
var eventNames = {};
eventNames[EVENT_TYPE_POINT] = "points.enter";
eventNames[EVENT_TYPE_SEGMENT_ENTER] = "segments.enter";
eventNames[EVENT_TYPE_SEGMENT_EXIT] = "segments.exit";
var eventAttributes = {};
eventAttributes[EVENT_TYPE_POINT] = "point";
eventAttributes[EVENT_TYPE_SEGMENT_ENTER] = "segment";
eventAttributes[EVENT_TYPE_SEGMENT_EXIT] = "segment";
function getPointOrSegment(peaks, cue) {
  switch (cue.type) {
    case Cue.POINT:
      return peaks.points.getPoint(cue.id);
    case Cue.SEGMENT_START:
    case Cue.SEGMENT_END:
      return peaks.segments.getSegment(cue.id);
    default:
      throw new Error("getPointOrSegment: id not found?");
  }
}
function CueEmitter(peaks) {
  this._cues = [];
  this._peaks = peaks;
  this._previousTime = -1;
  this._updateCues = this._updateCues.bind(this);
  this._onPlaying = this._onPlaying.bind(this);
  this._onSeeked = this._onSeeked.bind(this);
  this._onTimeUpdate = this._onTimeUpdate.bind(this);
  this._onAnimationFrame = this._onAnimationFrame.bind(this);
  this._rAFHandle = null;
  this._activeSegments = {};
  this._attachEventHandlers();
}
CueEmitter.prototype._updateCues = function() {
  var self2 = this;
  var points = self2._peaks.points.getPoints();
  var segments = self2._peaks.segments.getSegments();
  self2._cues.length = 0;
  points.forEach(function(point) {
    self2._cues.push(new Cue(point.time, Cue.POINT, point.id));
  });
  segments.forEach(function(segment) {
    self2._cues.push(new Cue(segment.startTime, Cue.SEGMENT_START, segment.id));
    self2._cues.push(new Cue(segment.endTime, Cue.SEGMENT_END, segment.id));
  });
  self2._cues.sort(Cue.sorter);
  var time2 = self2._peaks.player.getCurrentTime();
  self2._updateActiveSegments(time2);
};
CueEmitter.prototype._onUpdate = function(time2, previousTime) {
  var isForward = time2 > previousTime;
  var start;
  var end;
  var step;
  if (isForward) {
    start = 0;
    end = this._cues.length;
    step = 1;
  } else {
    start = this._cues.length - 1;
    end = -1;
    step = -1;
  }
  for (var i = start; isForward ? i < end : i > end; i += step) {
    var cue = this._cues[i];
    if (isForward ? cue.time > previousTime : cue.time < previousTime) {
      if (isForward ? cue.time > time2 : cue.time < time2) {
        break;
      }
      var marker = getPointOrSegment(this._peaks, cue);
      var eventType = isForward ? eventTypes.forward[cue.type] : eventTypes.reverse[cue.type];
      if (eventType === EVENT_TYPE_SEGMENT_ENTER) {
        this._activeSegments[marker.id] = marker;
      } else if (eventType === EVENT_TYPE_SEGMENT_EXIT) {
        delete this._activeSegments[marker.id];
      }
      var event = {
        time: time2
      };
      event[eventAttributes[eventType]] = marker;
      this._peaks.emit(eventNames[eventType], event);
    }
  }
};
CueEmitter.prototype._onTimeUpdate = function(time2) {
  if (windowIsVisible()) {
    return;
  }
  if (this._peaks.player.isPlaying() && !this._peaks.player.isSeeking()) {
    this._onUpdate(time2, this._previousTime);
  }
  this._previousTime = time2;
};
CueEmitter.prototype._onAnimationFrame = function() {
  var time2 = this._peaks.player.getCurrentTime();
  if (!this._peaks.player.isSeeking()) {
    this._onUpdate(time2, this._previousTime);
  }
  this._previousTime = time2;
  if (this._peaks.player.isPlaying()) {
    this._rAFHandle = requestAnimationFrame2(this._onAnimationFrame);
  }
};
CueEmitter.prototype._onPlaying = function() {
  this._previousTime = this._peaks.player.getCurrentTime();
  this._rAFHandle = requestAnimationFrame2(this._onAnimationFrame);
};
CueEmitter.prototype._onSeeked = function(time2) {
  this._previousTime = time2;
  this._updateActiveSegments(time2);
};
function getSegmentIdComparator(id) {
  return function compareSegmentIds(segment) {
    return segment.id === id;
  };
}
CueEmitter.prototype._updateActiveSegments = function(time2) {
  var self2 = this;
  var activeSegments = self2._peaks.segments.getSegmentsAtTime(time2);
  for (var id in self2._activeSegments) {
    if (objectHasProperty(self2._activeSegments, id)) {
      var segment = activeSegments.find(getSegmentIdComparator(id));
      if (!segment) {
        self2._peaks.emit("segments.exit", {
          segment: self2._activeSegments[id],
          time: time2
        });
        delete self2._activeSegments[id];
      }
    }
  }
  activeSegments.forEach(function(segment2) {
    if (!(segment2.id in self2._activeSegments)) {
      self2._activeSegments[segment2.id] = segment2;
      self2._peaks.emit("segments.enter", {
        segment: segment2,
        time: time2
      });
    }
  });
};
var events = ["points.update", "points.dragmove", "points.add", "points.remove", "points.remove_all", "segments.update", "segments.dragged", "segments.add", "segments.remove", "segments.remove_all"];
CueEmitter.prototype._attachEventHandlers = function() {
  this._peaks.on("player.timeupdate", this._onTimeUpdate);
  this._peaks.on("player.playing", this._onPlaying);
  this._peaks.on("player.seeked", this._onSeeked);
  for (var i = 0; i < events.length; i++) {
    this._peaks.on(events[i], this._updateCues);
  }
  this._updateCues();
};
CueEmitter.prototype._detachEventHandlers = function() {
  this._peaks.off("player.timeupdate", this._onTimeUpdate);
  this._peaks.off("player.playing", this._onPlaying);
  this._peaks.off("player.seeked", this._onSeeked);
  for (var i = 0; i < events.length; i++) {
    this._peaks.off(events[i], this._updateCues);
  }
};
CueEmitter.prototype.destroy = function() {
  if (this._rAFHandle) {
    cancelAnimationFrame(this._rAFHandle);
    this._rAFHandle = null;
  }
  this._detachEventHandlers();
  this._previousTime = -1;
};
var pointOptions = ["id", "pid", "time", "labelText", "color", "editable"];
var invalidOptions$1 = ["update", "isVisible", "peaks", "pid"];
function setDefaultPointOptions(options, peaksOptions) {
  if (isNullOrUndefined2(options.labelText)) {
    options.labelText = "";
  }
  if (isNullOrUndefined2(options.editable)) {
    options.editable = false;
  }
  if (isNullOrUndefined2(options.color)) {
    options.color = peaksOptions.pointMarkerColor;
  }
}
function validatePointOptions(options, updating) {
  var context = updating ? "update()" : "add()";
  if (!updating || updating && objectHasProperty(options, "time")) {
    if (!isValidTime(options.time)) {
      throw new TypeError("peaks.points." + context + ": time should be a numeric value");
    }
  }
  if (options.time < 0) {
    throw new RangeError("peaks.points." + context + ": time should not be negative");
  }
  if (objectHasProperty(options, "labelText") && !isString(options.labelText)) {
    throw new TypeError("peaks.points." + context + ": labelText must be a string");
  }
  if (objectHasProperty(options, "editable") && !isBoolean(options.editable)) {
    throw new TypeError("peaks.points." + context + ": editable must be true or false");
  }
  if (objectHasProperty(options, "color") && !isString(options.color) && !isLinearGradientColor(options.color)) {
    throw new TypeError("peaks.points." + context + ": color must be a string or a valid linear gradient object");
  }
  invalidOptions$1.forEach(function(name) {
    if (objectHasProperty(options, name)) {
      throw new Error("peaks.points." + context + ": invalid option name: " + name);
    }
  });
  pointOptions.forEach(function(name) {
    if (objectHasProperty(options, "_" + name)) {
      throw new Error("peaks.points." + context + ": invalid option name: _" + name);
    }
  });
}
function Point(peaks, pid, options) {
  this._peaks = peaks;
  this._pid = pid;
  this._setUserData(options);
}
Point.prototype._setUserData = function(options) {
  for (var key in options) {
    if (objectHasProperty(options, key)) {
      if (pointOptions.indexOf(key) === -1) {
        this[key] = options[key];
      } else {
        this["_" + key] = options[key];
      }
    }
  }
};
Object.defineProperties(Point.prototype, {
  id: {
    enumerable: true,
    get: function get() {
      return this._id;
    }
  },
  pid: {
    enumerable: true,
    get: function get2() {
      return this._pid;
    }
  },
  time: {
    enumerable: true,
    get: function get3() {
      return this._time;
    }
  },
  labelText: {
    get: function get4() {
      return this._labelText;
    }
  },
  color: {
    enumerable: true,
    get: function get5() {
      return this._color;
    }
  },
  editable: {
    enumerable: true,
    get: function get6() {
      return this._editable;
    }
  }
});
Point.prototype.update = function(options) {
  validatePointOptions(options, true);
  if (objectHasProperty(options, "id")) {
    if (isNullOrUndefined2(options.id)) {
      throw new TypeError("point.update(): invalid id");
    }
    this._peaks.points.updatePointId(this, options.id);
  }
  this._setUserData(options);
  this._peaks.emit("points.update", this, options);
};
Point.prototype.isVisible = function(startTime, endTime) {
  return this.time >= startTime && this.time < endTime;
};
Point.prototype._setTime = function(time2) {
  this._time = time2;
};
function WaveformPoints(peaks) {
  this._peaks = peaks;
  this._points = [];
  this._pointsById = {};
  this._pointsByPid = {};
  this._pointIdCounter = 0;
  this._pointPid = 0;
}
WaveformPoints.prototype._getNextPointId = function() {
  return "peaks.point." + this._pointIdCounter++;
};
WaveformPoints.prototype._getNextPid = function() {
  return this._pointPid++;
};
WaveformPoints.prototype._addPoint = function(point) {
  this._points.push(point);
  this._pointsById[point.id] = point;
  this._pointsByPid[point.pid] = point;
};
WaveformPoints.prototype._createPoint = function(options) {
  var pointOptions2 = {};
  extend(pointOptions2, options);
  if (isNullOrUndefined2(pointOptions2.id)) {
    pointOptions2.id = this._getNextPointId();
  }
  var pid = this._getNextPid();
  setDefaultPointOptions(pointOptions2, this._peaks.options);
  validatePointOptions(pointOptions2, false);
  return new Point(this._peaks, pid, pointOptions2);
};
WaveformPoints.prototype.getPoints = function() {
  return this._points;
};
WaveformPoints.prototype.getPoint = function(id) {
  return this._pointsById[id];
};
WaveformPoints.prototype.find = function(startTime, endTime) {
  return this._points.filter(function(point) {
    return point.isVisible(startTime, endTime);
  });
};
WaveformPoints.prototype.add = function() {
  var self2 = this;
  var arrayArgs = Array.isArray(arguments[0]);
  var points = arrayArgs ? arguments[0] : Array.prototype.slice.call(arguments);
  points = points.map(function(pointOptions2) {
    var point = self2._createPoint(pointOptions2);
    if (objectHasProperty(self2._pointsById, point.id)) {
      throw new Error("peaks.points.add(): duplicate id");
    }
    return point;
  });
  points.forEach(function(point) {
    self2._addPoint(point);
  });
  this._peaks.emit("points.add", {
    points
  });
  return arrayArgs ? points : points[0];
};
WaveformPoints.prototype.updatePointId = function(point, newPointId) {
  if (this._pointsById[point.id]) {
    if (this._pointsById[newPointId]) {
      throw new Error("point.update(): duplicate id");
    } else {
      delete this._pointsById[point.id];
      this._pointsById[newPointId] = point;
    }
  }
};
WaveformPoints.prototype._findPoint = function(predicate) {
  var indexes = [];
  for (var i = 0, length = this._points.length; i < length; i++) {
    if (predicate(this._points[i])) {
      indexes.push(i);
    }
  }
  return indexes;
};
WaveformPoints.prototype._removeIndexes = function(indexes) {
  var removed = [];
  for (var i = 0; i < indexes.length; i++) {
    var index = indexes[i] - removed.length;
    var itemRemoved = this._points.splice(index, 1)[0];
    delete this._pointsById[itemRemoved.id];
    delete this._pointsByPid[itemRemoved.pid];
    removed.push(itemRemoved);
  }
  return removed;
};
WaveformPoints.prototype._removePoints = function(predicate) {
  var indexes = this._findPoint(predicate);
  var removed = this._removeIndexes(indexes);
  this._peaks.emit("points.remove", {
    points: removed
  });
  return removed;
};
WaveformPoints.prototype.remove = function(point) {
  return this._removePoints(function(p) {
    return p === point;
  });
};
WaveformPoints.prototype.removeById = function(pointId) {
  return this._removePoints(function(point) {
    return point.id === pointId;
  });
};
WaveformPoints.prototype.removeByTime = function(time2) {
  return this._removePoints(function(point) {
    return point.time === time2;
  });
};
WaveformPoints.prototype.removeAll = function() {
  this._points = [];
  this._pointsById = {};
  this._pointsByPid = {};
  this._peaks.emit("points.remove_all");
};
var segmentOptions = ["id", "pid", "startTime", "endTime", "labelText", "color", "borderColor", "markers", "overlay", "editable"];
var invalidOptions = ["update", "isVisible", "peaks", "pid"];
function setDefaultSegmentOptions(options, globalSegmentOptions) {
  if (isNullOrUndefined2(options.color)) {
    if (globalSegmentOptions.overlay) {
      options.color = globalSegmentOptions.overlayColor;
    } else {
      options.color = globalSegmentOptions.waveformColor;
    }
  }
  if (isNullOrUndefined2(options.borderColor)) {
    options.borderColor = globalSegmentOptions.overlayBorderColor;
  }
  if (isNullOrUndefined2(options.labelText)) {
    options.labelText = "";
  }
  if (isNullOrUndefined2(options.markers)) {
    options.markers = globalSegmentOptions.markers;
  }
  if (isNullOrUndefined2(options.overlay)) {
    options.overlay = globalSegmentOptions.overlay;
  }
  if (isNullOrUndefined2(options.editable)) {
    options.editable = false;
  }
}
function validateSegmentOptions(options, updating) {
  var context = updating ? "update()" : "add()";
  if (objectHasProperty(options, "startTime") && !isValidTime(options.startTime)) {
    throw new TypeError("peaks.segments." + context + ": startTime should be a valid number");
  }
  if (objectHasProperty(options, "endTime") && !isValidTime(options.endTime)) {
    throw new TypeError("peaks.segments." + context + ": endTime should be a valid number");
  }
  if (!updating) {
    if (!objectHasProperty(options, "startTime") || !objectHasProperty(options, "endTime")) {
      throw new TypeError("peaks.segments." + context + ": missing startTime or endTime");
    }
  }
  if (options.startTime < 0) {
    throw new RangeError("peaks.segments." + context + ": startTime should not be negative");
  }
  if (options.endTime < 0) {
    throw new RangeError("peaks.segments." + context + ": endTime should not be negative");
  }
  if (options.endTime < options.startTime) {
    throw new RangeError("peaks.segments." + context + ": endTime should not be less than startTime");
  }
  if (objectHasProperty(options, "labelText") && !isString(options.labelText)) {
    throw new TypeError("peaks.segments." + context + ": labelText must be a string");
  }
  if (updating && objectHasProperty(options, "markers")) {
    throw new TypeError("peaks.segments." + context + ": cannot update markers attribute");
  }
  if (objectHasProperty(options, "markers") && !isBoolean(options.markers)) {
    throw new TypeError("peaks.segments." + context + ": markers must be true or false");
  }
  if (updating && objectHasProperty(options, "overlay")) {
    throw new TypeError("peaks.segments." + context + ": cannot update overlay attribute");
  }
  if (objectHasProperty(options, "overlay") && !isBoolean(options.overlay)) {
    throw new TypeError("peaks.segments." + context + ": overlay must be true or false");
  }
  if (objectHasProperty(options, "editable") && !isBoolean(options.editable)) {
    throw new TypeError("peaks.segments." + context + ": editable must be true or false");
  }
  if (objectHasProperty(options, "color") && !isString(options.color) && !isLinearGradientColor(options.color)) {
    throw new TypeError("peaks.segments." + context + ": color must be a string or a valid linear gradient object");
  }
  if (objectHasProperty(options, "borderColor") && !isString(options.borderColor)) {
    throw new TypeError("peaks.segments." + context + ": borderColor must be a string");
  }
  invalidOptions.forEach(function(name) {
    if (objectHasProperty(options, name)) {
      throw new Error("peaks.segments." + context + ": invalid option name: " + name);
    }
  });
  segmentOptions.forEach(function(name) {
    if (objectHasProperty(options, "_" + name)) {
      throw new Error("peaks.segments." + context + ": invalid option name: _" + name);
    }
  });
}
function Segment(peaks, pid, options) {
  this._peaks = peaks;
  this._pid = pid;
  this._id = options.id;
  this._startTime = options.startTime;
  this._endTime = options.endTime;
  this._labelText = options.labelText;
  this._color = options.color;
  this._borderColor = options.borderColor;
  this._editable = options.editable;
  this._markers = options.markers;
  this._overlay = options.overlay;
  this._setUserData(options);
}
Segment.prototype._setUserData = function(options) {
  for (var key in options) {
    if (objectHasProperty(options, key)) {
      if (segmentOptions.indexOf(key) === -1) {
        this[key] = options[key];
      } else {
        this["_" + key] = options[key];
      }
    }
  }
};
Object.defineProperties(Segment.prototype, {
  id: {
    enumerable: true,
    get: function get7() {
      return this._id;
    }
  },
  pid: {
    enumerable: true,
    get: function get8() {
      return this._pid;
    }
  },
  startTime: {
    enumerable: true,
    get: function get9() {
      return this._startTime;
    }
  },
  endTime: {
    enumerable: true,
    get: function get10() {
      return this._endTime;
    }
  },
  labelText: {
    enumerable: true,
    get: function get11() {
      return this._labelText;
    }
  },
  color: {
    enumerable: true,
    get: function get12() {
      return this._color;
    }
  },
  borderColor: {
    enumerable: true,
    get: function get13() {
      return this._borderColor;
    }
  },
  markers: {
    enumerable: true,
    get: function get14() {
      return this._markers;
    }
  },
  overlay: {
    enumerable: true,
    get: function get15() {
      return this._overlay;
    }
  },
  editable: {
    enumerable: true,
    get: function get16() {
      return this._editable;
    }
  }
});
Segment.prototype.update = function(options) {
  validateSegmentOptions(options, true);
  if (objectHasProperty(options, "id")) {
    if (isNullOrUndefined2(options.id)) {
      throw new TypeError("segment.update(): invalid id");
    }
    this._peaks.segments.updateSegmentId(this, options.id);
  }
  this._setUserData(options);
  this._peaks.emit("segments.update", this, options);
};
Segment.prototype.isVisible = function(startTime, endTime) {
  if (this.startTime === this.endTime && this.startTime === startTime) {
    return true;
  }
  if (this.endTime <= startTime) {
    return false;
  }
  if (this.startTime >= endTime) {
    return false;
  }
  return true;
};
Segment.prototype._setStartTime = function(time2) {
  this._startTime = time2;
};
Segment.prototype._setEndTime = function(time2) {
  this._endTime = time2;
};
function WaveformSegments(peaks) {
  this._peaks = peaks;
  this._segments = [];
  this._segmentsById = {};
  this._segmentsByPid = {};
  this._segmentIdCounter = 0;
  this._segmentPid = 0;
  this._isInserting = false;
}
WaveformSegments.prototype._getNextSegmentId = function() {
  return "peaks.segment." + this._segmentIdCounter++;
};
WaveformSegments.prototype._getNextPid = function() {
  return this._segmentPid++;
};
WaveformSegments.prototype._addSegment = function(segment) {
  this._segments.push(segment);
  this._segmentsById[segment.id] = segment;
  this._segmentsByPid[segment.pid] = segment;
};
WaveformSegments.prototype._createSegment = function(options) {
  var segmentOptions2 = {};
  extend(segmentOptions2, options);
  if (isNullOrUndefined2(segmentOptions2.id)) {
    segmentOptions2.id = this._getNextSegmentId();
  }
  var pid = this._getNextPid();
  setDefaultSegmentOptions(segmentOptions2, this._peaks.options.segmentOptions);
  validateSegmentOptions(segmentOptions2, false);
  return new Segment(this._peaks, pid, segmentOptions2);
};
WaveformSegments.prototype.getSegments = function() {
  return this._segments;
};
WaveformSegments.prototype.getSegment = function(id) {
  return this._segmentsById[id];
};
WaveformSegments.prototype.getSegmentsAtTime = function(time2) {
  return this._segments.filter(function(segment) {
    return time2 >= segment.startTime && time2 < segment.endTime;
  });
};
WaveformSegments.prototype.find = function(startTime, endTime) {
  return this._segments.filter(function(segment) {
    return segment.isVisible(startTime, endTime);
  });
};
WaveformSegments.prototype._getSortedSegments = function() {
  return this._segments.slice().sort(function(a, b) {
    return a.startTime - b.startTime;
  });
};
WaveformSegments.prototype.findPreviousSegment = function(segment) {
  var sortedSegments = this._getSortedSegments();
  var index = sortedSegments.findIndex(function(s) {
    return s.id === segment.id;
  });
  if (index !== -1) {
    return sortedSegments[index - 1];
  }
  return void 0;
};
WaveformSegments.prototype.findNextSegment = function(segment) {
  var sortedSegments = this._getSortedSegments();
  var index = sortedSegments.findIndex(function(s) {
    return s.id === segment.id;
  });
  if (index !== -1) {
    return sortedSegments[index + 1];
  }
  return void 0;
};
WaveformSegments.prototype.add = function() {
  var self2 = this;
  var arrayArgs = Array.isArray(arguments[0]);
  var segments = arrayArgs ? arguments[0] : Array.prototype.slice.call(arguments);
  segments = segments.map(function(segmentOptions2) {
    var segment = self2._createSegment(segmentOptions2);
    if (objectHasProperty(self2._segmentsById, segment.id)) {
      throw new Error("peaks.segments.add(): duplicate id");
    }
    return segment;
  });
  segments.forEach(function(segment) {
    self2._addSegment(segment);
  });
  this._peaks.emit("segments.add", {
    segments,
    insert: this._isInserting
  });
  return arrayArgs ? segments : segments[0];
};
WaveformSegments.prototype.updateSegmentId = function(segment, newSegmentId) {
  if (this._segmentsById[segment.id]) {
    if (this._segmentsById[newSegmentId]) {
      throw new Error("segment.update(): duplicate id");
    } else {
      delete this._segmentsById[segment.id];
      this._segmentsById[newSegmentId] = segment;
    }
  }
};
WaveformSegments.prototype._findSegment = function(predicate) {
  var indexes = [];
  for (var i = 0, length = this._segments.length; i < length; i++) {
    if (predicate(this._segments[i])) {
      indexes.push(i);
    }
  }
  return indexes;
};
WaveformSegments.prototype._removeIndexes = function(indexes) {
  var removed = [];
  for (var i = 0; i < indexes.length; i++) {
    var index = indexes[i] - removed.length;
    var itemRemoved = this._segments.splice(index, 1)[0];
    delete this._segmentsById[itemRemoved.id];
    delete this._segmentsByPid[itemRemoved.pid];
    removed.push(itemRemoved);
  }
  return removed;
};
WaveformSegments.prototype._removeSegments = function(predicate) {
  var indexes = this._findSegment(predicate);
  var removed = this._removeIndexes(indexes);
  this._peaks.emit("segments.remove", {
    segments: removed
  });
  return removed;
};
WaveformSegments.prototype.remove = function(segment) {
  return this._removeSegments(function(s) {
    return s === segment;
  });
};
WaveformSegments.prototype.removeById = function(segmentId) {
  return this._removeSegments(function(segment) {
    return segment.id === segmentId;
  });
};
WaveformSegments.prototype.removeByTime = function(startTime, endTime) {
  endTime = typeof endTime === "number" ? endTime : 0;
  var filter;
  if (endTime > 0) {
    filter = function filter2(segment) {
      return segment.startTime === startTime && segment.endTime === endTime;
    };
  } else {
    filter = function filter2(segment) {
      return segment.startTime === startTime;
    };
  }
  return this._removeSegments(filter);
};
WaveformSegments.prototype.removeAll = function() {
  this._segments = [];
  this._segmentsById = {};
  this._segmentsByPid = {};
  this._peaks.emit("segments.remove_all");
};
WaveformSegments.prototype.setInserting = function(value) {
  this._isInserting = value;
};
WaveformSegments.prototype.isInserting = function() {
  return this._isInserting;
};
var nodes = ["OBJECT", "TEXTAREA", "INPUT", "SELECT", "OPTION"];
var SPACE3 = 32;
var TAB = 9;
var LEFT_ARROW = 37;
var RIGHT_ARROW = 39;
var keys = [SPACE3, TAB, LEFT_ARROW, RIGHT_ARROW];
function KeyboardHandler(eventEmitter) {
  this.eventEmitter = eventEmitter;
  this._handleKeyEvent = this._handleKeyEvent.bind(this);
  document.addEventListener("keydown", this._handleKeyEvent);
  document.addEventListener("keypress", this._handleKeyEvent);
  document.addEventListener("keyup", this._handleKeyEvent);
}
KeyboardHandler.prototype._handleKeyEvent = function handleKeyEvent(event) {
  if (nodes.indexOf(event.target.nodeName) === -1) {
    if (keys.indexOf(event.type) > -1) {
      event.preventDefault();
    }
    if (event.type === "keydown" || event.type === "keypress") {
      switch (event.keyCode) {
        case SPACE3:
          this.eventEmitter.emit("keyboard.space");
          break;
        case TAB:
          this.eventEmitter.emit("keyboard.tab");
          break;
      }
    } else if (event.type === "keyup") {
      switch (event.keyCode) {
        case LEFT_ARROW:
          if (event.shiftKey) {
            this.eventEmitter.emit("keyboard.shift_left");
          } else {
            this.eventEmitter.emit("keyboard.left");
          }
          break;
        case RIGHT_ARROW:
          if (event.shiftKey) {
            this.eventEmitter.emit("keyboard.shift_right");
          } else {
            this.eventEmitter.emit("keyboard.right");
          }
          break;
      }
    }
  }
};
KeyboardHandler.prototype.destroy = function() {
  document.removeEventListener("keydown", this._handleKeyEvent);
  document.removeEventListener("keypress", this._handleKeyEvent);
  document.removeEventListener("keyup", this._handleKeyEvent);
};
function mediaElementHasSource(mediaElement) {
  if (mediaElement.src) {
    return true;
  }
  if (mediaElement.querySelector("source")) {
    return true;
  }
  return false;
}
function MediaElementPlayer(mediaElement) {
  this._mediaElement = mediaElement;
}
MediaElementPlayer.prototype._addMediaListener = function(type, callback) {
  this._listeners.push({
    type,
    callback
  });
  this._mediaElement.addEventListener(type, callback);
};
MediaElementPlayer.prototype.init = function(eventEmitter) {
  var self2 = this;
  self2._eventEmitter = eventEmitter;
  self2._listeners = [];
  self2._duration = self2.getDuration();
  self2._addMediaListener("timeupdate", function() {
    self2._eventEmitter.emit("player.timeupdate", self2.getCurrentTime());
  });
  self2._addMediaListener("playing", function() {
    self2._eventEmitter.emit("player.playing", self2.getCurrentTime());
  });
  self2._addMediaListener("pause", function() {
    self2._eventEmitter.emit("player.pause", self2.getCurrentTime());
  });
  self2._addMediaListener("ended", function() {
    self2._eventEmitter.emit("player.ended");
  });
  self2._addMediaListener("seeked", function() {
    self2._eventEmitter.emit("player.seeked", self2.getCurrentTime());
  });
  self2._addMediaListener("canplay", function() {
    self2._eventEmitter.emit("player.canplay");
  });
  self2._addMediaListener("error", function(event) {
    self2._eventEmitter.emit("player.error", event.target.error);
  });
  self2._interval = null;
  if (!mediaElementHasSource(self2._mediaElement)) {
    return Promise.resolve();
  } else if (self2._mediaElement.error && self2._mediaElement.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
    return Promise.reject(self2._mediaElement.error);
  }
  return new Promise(function(resolve, reject) {
    function eventHandler(event) {
      self2._mediaElement.removeEventListener("loadedmetadata", eventHandler);
      self2._mediaElement.removeEventListener("error", eventHandler);
      if (event.type === "loadedmetadata") {
        resolve();
      } else {
        reject(event.target.error);
      }
    }
    if (self2._mediaElement.readyState === HTMLMediaElement.HAVE_NOTHING) {
      self2._mediaElement.addEventListener("loadedmetadata", eventHandler);
      self2._mediaElement.addEventListener("error", eventHandler);
      self2._mediaElement.load();
    } else {
      resolve();
    }
  });
};
MediaElementPlayer.prototype.destroy = function() {
  for (var i = 0; i < this._listeners.length; i++) {
    var listener = this._listeners[i];
    this._mediaElement.removeEventListener(listener.type, listener.callback);
  }
  this._listeners.length = 0;
  this._mediaElement = null;
};
MediaElementPlayer.prototype.play = function() {
  return this._mediaElement.play();
};
MediaElementPlayer.prototype.pause = function() {
  this._mediaElement.pause();
};
MediaElementPlayer.prototype.isPlaying = function() {
  return !this._mediaElement.paused;
};
MediaElementPlayer.prototype.isSeeking = function() {
  return this._mediaElement.seeking;
};
MediaElementPlayer.prototype.getCurrentTime = function() {
  return this._mediaElement.currentTime;
};
MediaElementPlayer.prototype.getDuration = function() {
  return this._mediaElement.duration;
};
MediaElementPlayer.prototype.seek = function(time2) {
  this._mediaElement.currentTime = time2;
};
function SetSourceHandler(eventEmitter, mediaElement) {
  this._eventEmitter = eventEmitter;
  this._mediaElement = mediaElement;
  this._playerCanPlayHandler = this._playerCanPlayHandler.bind(this);
  this._playerErrorHandler = this._playerErrorHandler.bind(this);
}
SetSourceHandler.prototype.setSource = function(options, callback) {
  var self2 = this;
  self2._options = options;
  self2._callback = callback;
  self2._eventEmitter.on("player.canplay", self2._playerCanPlayHandler);
  self2._eventEmitter.on("player.error", self2._playerErrorHandler);
  return new Promise(function(resolve, reject) {
    self2._resolve = resolve;
    self2._reject = reject;
    self2._eventEmitter.on("player.canplay", self2._playerCanPlayHandler);
    self2._eventEmitter.on("player.error", self2._playerErrorHandler);
    self2._mediaElement.setAttribute("src", options.mediaUrl);
    if (self2._mediaElement.readyState === HTMLMediaElement.HAVE_NOTHING) {
      self2._mediaElement.load();
    }
  });
};
SetSourceHandler.prototype._reset = function() {
  this._eventEmitter.removeListener("player.canplay", this._playerCanPlayHandler);
  this._eventEmitter.removeListener("player.error", this._playerErrorHandler);
};
SetSourceHandler.prototype._playerCanPlayHandler = function() {
  this._reset();
  this._resolve();
};
SetSourceHandler.prototype._playerErrorHandler = function(err) {
  this._reset();
  this._reject(err);
};
MediaElementPlayer.prototype.setSource = function(options) {
  if (!options.mediaUrl) {
    return Promise.reject(new Error("peaks.setSource(): options must contain a mediaUrl when using mediaElement"));
  }
  var setSourceHandler = new SetSourceHandler(this._eventEmitter, this._mediaElement);
  return setSourceHandler.setSource(options);
};
function getAllPropertiesFrom(adapter) {
  var allProperties = [];
  var obj = adapter;
  while (obj) {
    Object.getOwnPropertyNames(obj).forEach(function(p) {
      allProperties.push(p);
    });
    obj = Object.getPrototypeOf(obj);
  }
  return allProperties;
}
function validateAdapter(adapter) {
  var publicAdapterMethods = ["init", "destroy", "play", "pause", "isPlaying", "isSeeking", "getCurrentTime", "getDuration", "seek"];
  var allProperties = getAllPropertiesFrom(adapter);
  publicAdapterMethods.forEach(function(method) {
    if (!allProperties.includes(method)) {
      throw new TypeError("Peaks.init(): Player method " + method + " is undefined");
    }
    if (typeof adapter[method] !== "function") {
      throw new TypeError("Peaks.init(): Player method " + method + " is not a function");
    }
  });
}
function Player(peaks, adapter) {
  this._peaks = peaks;
  this._playingSegment = false;
  this._segment = null;
  this._loop = false;
  this._playSegmentTimerCallback = this._playSegmentTimerCallback.bind(this);
  validateAdapter(adapter);
  this._adapter = adapter;
}
Player.prototype.init = function() {
  return this._adapter.init(this._peaks);
};
Player.prototype.destroy = function() {
  this._adapter.destroy();
};
Player.prototype.play = function() {
  return this._adapter.play();
};
Player.prototype.pause = function() {
  this._adapter.pause();
};
Player.prototype.isPlaying = function() {
  return this._adapter.isPlaying();
};
Player.prototype.isSeeking = function() {
  return this._adapter.isSeeking();
};
Player.prototype.getCurrentTime = function() {
  return this._adapter.getCurrentTime();
};
Player.prototype.getDuration = function() {
  return this._adapter.getDuration();
};
Player.prototype.seek = function(time2) {
  if (!isValidTime(time2)) {
    this._peaks._logger("peaks.player.seek(): parameter must be a valid time, in seconds");
    return;
  }
  this._adapter.seek(time2);
};
Player.prototype.playSegment = function(segment, loop) {
  var self2 = this;
  if (!segment || !isValidTime(segment.startTime) || !isValidTime(segment.endTime)) {
    return Promise.reject(new Error("peaks.player.playSegment(): parameter must be a segment object"));
  }
  self2._segment = segment;
  self2._loop = loop;
  self2.seek(segment.startTime);
  self2._peaks.once("player.playing", function() {
    if (!self2._playingSegment) {
      self2._playingSegment = true;
      window.requestAnimationFrame(self2._playSegmentTimerCallback);
    }
  });
  return self2.play();
};
Player.prototype._playSegmentTimerCallback = function() {
  if (!this.isPlaying()) {
    this._playingSegment = false;
    return;
  } else if (this.getCurrentTime() >= this._segment.endTime) {
    if (this._loop) {
      this.seek(this._segment.startTime);
    } else {
      this.pause();
      this._peaks.emit("player.ended");
      this._playingSegment = false;
      return;
    }
  }
  window.requestAnimationFrame(this._playSegmentTimerCallback);
};
Player.prototype._setSource = function(options) {
  return this._adapter.setSource(options);
};
function DefaultPointMarker(options) {
  this._options = options;
  this._draggable = options.editable;
}
DefaultPointMarker.prototype.init = function(group) {
  var handleWidth = 10;
  var handleHeight = 20;
  var handleX = -5 + 0.5;
  if (this._options.view === "zoomview") {
    this._label = new Text({
      x: 2,
      y: 0,
      text: this._options.point.labelText,
      textAlign: "left",
      fontFamily: this._options.fontFamily || "sans-serif",
      fontSize: this._options.fontSize || 10,
      fontStyle: this._options.fontStyle || "normal",
      fill: "#000"
    });
  }
  this._handle = new Rect({
    x: handleX,
    y: 0,
    width: handleWidth,
    height: handleHeight,
    fill: this._options.color,
    visible: this._draggable
  });
  this._line = new Line({
    x: 0,
    y: 0,
    stroke: this._options.color,
    strokeWidth: 1
  });
  this._time = new Text({
    x: -24,
    y: 0,
    text: this._options.layer.formatTime(this._options.point.time),
    fontFamily: this._options.fontFamily,
    fontSize: this._options.fontSize,
    fontStyle: this._options.fontStyle,
    fill: "#000",
    textAlign: "center"
  });
  this._time.hide();
  group.add(this._handle);
  group.add(this._line);
  if (this._label) {
    group.add(this._label);
  }
  group.add(this._time);
  this.fitToView();
  this.bindEventHandlers(group);
};
DefaultPointMarker.prototype.bindEventHandlers = function(group) {
  var self2 = this;
  self2._handle.on("mouseover touchstart", function() {
    if (self2._draggable) {
      self2._time.setX(-24 - self2._time.getWidth());
      self2._time.show();
    }
  });
  self2._handle.on("mouseout touchend", function() {
    if (self2._draggable) {
      self2._time.hide();
    }
  });
  group.on("dragstart", function() {
    self2._time.setX(-24 - self2._time.getWidth());
    self2._time.show();
  });
  group.on("dragend", function() {
    self2._time.hide();
  });
};
DefaultPointMarker.prototype.fitToView = function() {
  var height = this._options.layer.getHeight();
  this._line.points([0.5, 0, 0.5, height]);
  if (this._label) {
    this._label.y(12);
  }
  if (this._handle) {
    this._handle.y(height / 2 - 10.5);
  }
  if (this._time) {
    this._time.y(height / 2 - 5);
  }
};
DefaultPointMarker.prototype.update = function(options) {
  if (options.time !== void 0) {
    if (this._time) {
      this._time.setText(this._options.layer.formatTime(options.time));
    }
  }
  if (options.labelText !== void 0) {
    if (this._label) {
      this._label.text(options.labelText);
    }
  }
  if (options.color !== void 0) {
    if (this._handle) {
      this._handle.fill(options.color);
    }
    this._line.stroke(options.color);
  }
  if (options.editable !== void 0) {
    this._draggable = options.editable;
    this._handle.visible(this._draggable);
  }
};
function DefaultSegmentMarker(options) {
  this._options = options;
  this._editable = options.editable;
}
DefaultSegmentMarker.prototype.init = function(group) {
  var handleWidth = 10;
  var handleHeight = 20;
  var handleX = -5 + 0.5;
  var xPosition = this._options.startMarker ? -24 : 24;
  var time2 = this._options.startMarker ? this._options.segment.startTime : this._options.segment.endTime;
  this._label = new Text({
    x: xPosition,
    y: 0,
    text: this._options.layer.formatTime(time2),
    fontFamily: this._options.fontFamily,
    fontSize: this._options.fontSize,
    fontStyle: this._options.fontStyle,
    fill: "#000",
    textAlign: "center",
    visible: this._editable
  });
  this._label.hide();
  this._handle = new Rect({
    x: handleX,
    y: 0,
    width: handleWidth,
    height: handleHeight,
    fill: this._options.color,
    stroke: this._options.color,
    strokeWidth: 1,
    visible: this._editable
  });
  this._line = new Line({
    x: 0,
    y: 0,
    stroke: this._options.color,
    strokeWidth: 1,
    visible: this._editable
  });
  group.add(this._label);
  group.add(this._line);
  group.add(this._handle);
  this.fitToView();
  this.bindEventHandlers(group);
};
DefaultSegmentMarker.prototype.bindEventHandlers = function(group) {
  var self2 = this;
  var xPosition = self2._options.startMarker ? -24 : 24;
  group.on("dragstart", function() {
    if (self2._options.startMarker) {
      self2._label.setX(xPosition - self2._label.getWidth());
    }
    self2._label.show();
  });
  group.on("dragend", function() {
    self2._label.hide();
  });
  self2._handle.on("mouseover touchstart", function() {
    if (self2._options.startMarker) {
      self2._label.setX(xPosition - self2._label.getWidth());
    }
    self2._label.show();
  });
  self2._handle.on("mouseout touchend", function() {
    self2._label.hide();
  });
};
DefaultSegmentMarker.prototype.fitToView = function() {
  var height = this._options.layer.getHeight();
  this._label.y(height / 2 - 5);
  this._handle.y(height / 2 - 10.5);
  this._line.points([0.5, 0, 0.5, height]);
};
DefaultSegmentMarker.prototype.update = function(options) {
  if (options.startTime !== void 0 && this._options.startMarker) {
    this._label.text(this._options.layer.formatTime(options.startTime));
  }
  if (options.endTime !== void 0 && !this._options.startMarker) {
    this._label.text(this._options.layer.formatTime(options.endTime));
  }
  if (options.editable !== void 0) {
    this._editable = options.editable;
    this._label.visible(this._editable);
    this._handle.visible(this._editable);
    this._line.visible(this._editable);
  }
};
function createSegmentMarker(options) {
  if (options.view === "zoomview") {
    return new DefaultSegmentMarker(options);
  }
  return null;
}
function createSegmentLabel(options) {
  return new Text({
    x: 12,
    y: 12,
    text: options.segment.labelText,
    textAlign: "center",
    fontFamily: options.fontFamily || "sans-serif",
    fontSize: options.fontSize || 12,
    fontStyle: options.fontStyle || "normal",
    fill: "#000"
  });
}
function createPointMarker(options) {
  return new DefaultPointMarker(options);
}
function HighlightLayer(view, options) {
  this._view = view;
  this._offset = options.highlightOffset;
  this._color = options.highlightColor;
  this._layer = new Core_default.Layer({
    listening: false
  });
  this._highlightRect = null;
  this._startTime = null;
  this._endTime = null;
  this._strokeColor = options.highlightStrokeColor;
  this._opacity = options.highlightOpacity;
  this._cornerRadius = options.highlightCornerRadius;
}
HighlightLayer.prototype.addToStage = function(stage) {
  stage.add(this._layer);
};
HighlightLayer.prototype.showHighlight = function(startTime, endTime) {
  if (!this._highlightRect) {
    this._createHighlightRect(startTime, endTime);
  }
  this._update(startTime, endTime);
};
HighlightLayer.prototype._update = function(startTime, endTime) {
  this._startTime = startTime;
  this._endTime = endTime;
  var startOffset = this._view.timeToPixels(startTime);
  var endOffset = this._view.timeToPixels(endTime);
  this._highlightRect.setAttrs({
    x: startOffset,
    width: endOffset - startOffset
  });
};
HighlightLayer.prototype._createHighlightRect = function(startTime, endTime) {
  this._startTime = startTime;
  this._endTime = endTime;
  var startOffset = this._view.timeToPixels(startTime);
  var endOffset = this._view.timeToPixels(endTime);
  this._highlightRect = new Rect({
    x: startOffset,
    y: 0,
    width: endOffset - startOffset,
    height: 0,
    stroke: this._strokeColor,
    strokeWidth: 1,
    fill: this._color,
    opacity: this._opacity,
    cornerRadius: this._cornerRadius
  });
  this.fitToView();
  this._layer.add(this._highlightRect);
};
HighlightLayer.prototype.removeHighlight = function() {
  if (this._highlightRect) {
    this._highlightRect.destroy();
    this._highlightRect = null;
  }
};
HighlightLayer.prototype.updateHighlight = function() {
  if (this._highlightRect) {
    this._update(this._startTime, this._endTime);
  }
};
HighlightLayer.prototype.fitToView = function() {
  if (this._highlightRect) {
    var height = this._view.getHeight();
    var offset = clamp(this._offset, 0, Math.floor(height / 2));
    this._highlightRect.setAttrs({
      y: offset,
      height: height - offset * 2
    });
  }
};
function PointMarker(options) {
  this._point = options.point;
  this._marker = options.marker;
  this._draggable = options.draggable;
  this._onDragStart = options.onDragStart;
  this._onDragMove = options.onDragMove;
  this._onDragEnd = options.onDragEnd;
  this._dragBoundFunc = options.dragBoundFunc;
  this._onMouseEnter = options.onMouseEnter;
  this._onMouseLeave = options.onMouseLeave;
  this._group = new Core_default.Group({
    name: "point-marker",
    point: this._point,
    draggable: this._draggable,
    dragBoundFunc: options.dragBoundFunc
  });
  this._bindDefaultEventHandlers();
  this._marker.init(this._group);
}
PointMarker.prototype._bindDefaultEventHandlers = function() {
  var self2 = this;
  self2._group.on("dragstart", function(event) {
    self2._onDragStart(event, self2._point);
  });
  self2._group.on("dragmove", function(event) {
    self2._onDragMove(event, self2._point);
  });
  self2._group.on("dragend", function(event) {
    self2._onDragEnd(event, self2._point);
  });
  self2._group.on("mouseenter", function(event) {
    self2._onMouseEnter(event, self2._point);
  });
  self2._group.on("mouseleave", function(event) {
    self2._onMouseLeave(event, self2._point);
  });
};
PointMarker.prototype.addToLayer = function(layer) {
  layer.add(this._group);
};
PointMarker.prototype.fitToView = function() {
  this._marker.fitToView();
};
PointMarker.prototype.getPoint = function() {
  return this._point;
};
PointMarker.prototype.getX = function() {
  return this._group.getX();
};
PointMarker.prototype.setX = function(x) {
  this._group.setX(x);
};
PointMarker.prototype.getWidth = function() {
  return this._group.getWidth();
};
PointMarker.prototype.getAbsolutePosition = function() {
  return this._group.getAbsolutePosition();
};
PointMarker.prototype.update = function(options) {
  if (options.editable !== void 0) {
    this._group.draggable(options.editable);
  }
  if (this._marker.update) {
    this._marker.update(options);
  }
};
PointMarker.prototype.destroy = function() {
  if (this._marker.destroy) {
    this._marker.destroy();
  }
  this._group.destroyChildren();
  this._group.destroy();
};
function PointsLayer(peaks, view, enableEditing) {
  this._peaks = peaks;
  this._view = view;
  this._enableEditing = enableEditing;
  this._pointMarkers = {};
  this._layer = new Core_default.Layer();
  this._onPointsDrag = this._onPointsDrag.bind(this);
  this._onPointMarkerDragStart = this._onPointMarkerDragStart.bind(this);
  this._onPointMarkerDragMove = this._onPointMarkerDragMove.bind(this);
  this._onPointMarkerDragEnd = this._onPointMarkerDragEnd.bind(this);
  this._pointMarkerDragBoundFunc = this._pointMarkerDragBoundFunc.bind(this);
  this._onPointMarkerMouseEnter = this._onPointMarkerMouseEnter.bind(this);
  this._onPointMarkerMouseLeave = this._onPointMarkerMouseLeave.bind(this);
  this._onPointsUpdate = this._onPointsUpdate.bind(this);
  this._onPointsAdd = this._onPointsAdd.bind(this);
  this._onPointsRemove = this._onPointsRemove.bind(this);
  this._onPointsRemoveAll = this._onPointsRemoveAll.bind(this);
  this._peaks.on("points.update", this._onPointsUpdate);
  this._peaks.on("points.add", this._onPointsAdd);
  this._peaks.on("points.remove", this._onPointsRemove);
  this._peaks.on("points.remove_all", this._onPointsRemoveAll);
  this._peaks.on("points.dragstart", this._onPointsDrag);
  this._peaks.on("points.dragmove", this._onPointsDrag);
  this._peaks.on("points.dragend", this._onPointsDrag);
}
PointsLayer.prototype.addToStage = function(stage) {
  stage.add(this._layer);
};
PointsLayer.prototype.setListening = function(listening) {
  this._layer.listening(listening);
};
PointsLayer.prototype.enableEditing = function(enable) {
  this._enableEditing = enable;
};
PointsLayer.prototype.getPointMarker = function(point) {
  return this._pointMarkers[point.pid];
};
PointsLayer.prototype.formatTime = function(time2) {
  return this._view.formatTime(time2);
};
PointsLayer.prototype._onPointsUpdate = function(point, options) {
  var frameStartTime = this._view.getStartTime();
  var frameEndTime = this._view.getEndTime();
  var pointMarker = this.getPointMarker(point);
  var isVisible = point.isVisible(frameStartTime, frameEndTime);
  if (pointMarker && !isVisible) {
    this._removePoint(point);
  } else if (!pointMarker && isVisible) {
    this._updatePoint(point);
  } else if (pointMarker && isVisible) {
    if (objectHasProperty(options, "time")) {
      var pointMarkerOffset = this._view.timeToPixels(point.time);
      var pointMarkerX = pointMarkerOffset - this._view.getFrameOffset();
      pointMarker.setX(pointMarkerX);
    }
    pointMarker.update(options);
  }
};
PointsLayer.prototype._onPointsAdd = function(event) {
  var self2 = this;
  var frameStartTime = self2._view.getStartTime();
  var frameEndTime = self2._view.getEndTime();
  event.points.forEach(function(point) {
    if (point.isVisible(frameStartTime, frameEndTime)) {
      self2._updatePoint(point);
    }
  });
};
PointsLayer.prototype._onPointsRemove = function(event) {
  var self2 = this;
  event.points.forEach(function(point) {
    self2._removePoint(point);
  });
};
PointsLayer.prototype._onPointsRemoveAll = function() {
  this._layer.removeChildren();
  this._pointMarkers = {};
};
PointsLayer.prototype._createPointMarker = function(point) {
  var editable = this._enableEditing && point.editable;
  var viewOptions = this._view.getViewOptions();
  var marker = this._peaks.options.createPointMarker({
    point,
    editable,
    color: point.color,
    fontFamily: viewOptions.fontFamily,
    fontSize: viewOptions.fontSize,
    fontStyle: viewOptions.fontStyle,
    layer: this,
    view: this._view.getName()
  });
  return new PointMarker({
    point,
    draggable: editable,
    marker,
    onDragStart: this._onPointMarkerDragStart,
    onDragMove: this._onPointMarkerDragMove,
    onDragEnd: this._onPointMarkerDragEnd,
    dragBoundFunc: this._pointMarkerDragBoundFunc,
    onMouseEnter: this._onPointMarkerMouseEnter,
    onMouseLeave: this._onPointMarkerMouseLeave
  });
};
PointsLayer.prototype.getHeight = function() {
  return this._view.getHeight();
};
PointsLayer.prototype._addPointMarker = function(point) {
  var pointMarker = this._createPointMarker(point);
  this._pointMarkers[point.pid] = pointMarker;
  pointMarker.addToLayer(this._layer);
  return pointMarker;
};
PointsLayer.prototype._onPointsDrag = function(event) {
  var pointMarker = this._updatePoint(event.point);
  pointMarker.update({
    time: event.point.time
  });
};
PointsLayer.prototype._onPointMarkerMouseEnter = function(event, point) {
  this._peaks.emit("points.mouseenter", {
    point,
    evt: event.evt
  });
};
PointsLayer.prototype._onPointMarkerMouseLeave = function(event, point) {
  this._peaks.emit("points.mouseleave", {
    point,
    evt: event.evt
  });
};
PointsLayer.prototype._onPointMarkerDragStart = function(event, point) {
  this._dragPointMarker = this.getPointMarker(point);
  this._peaks.emit("points.dragstart", {
    point,
    evt: event.evt
  });
};
PointsLayer.prototype._onPointMarkerDragMove = function(event, point) {
  var pointMarker = this._pointMarkers[point.pid];
  var markerX = pointMarker.getX();
  var offset = markerX + pointMarker.getWidth();
  point._setTime(this._view.pixelOffsetToTime(offset));
  this._peaks.emit("points.dragmove", {
    point,
    evt: event.evt
  });
};
PointsLayer.prototype._onPointMarkerDragEnd = function(event, point) {
  this._dragPointMarker = null;
  this._peaks.emit("points.dragend", {
    point,
    evt: event.evt
  });
};
PointsLayer.prototype._pointMarkerDragBoundFunc = function(pos) {
  return {
    x: clamp(pos.x, 0, this._view.getWidth()),
    y: this._dragPointMarker.getAbsolutePosition().y
  };
};
PointsLayer.prototype.updatePoints = function(startTime, endTime) {
  var points = this._peaks.points.find(startTime, endTime);
  points.forEach(this._updatePoint.bind(this));
  this._removeInvisiblePoints(startTime, endTime);
};
PointsLayer.prototype._updatePoint = function(point) {
  var pointMarker = this.getPointMarker(point);
  if (!pointMarker) {
    pointMarker = this._addPointMarker(point);
  }
  var pointMarkerOffset = this._view.timeToPixels(point.time);
  var pointMarkerX = pointMarkerOffset - this._view.getFrameOffset();
  pointMarker.setX(pointMarkerX);
  return pointMarker;
};
PointsLayer.prototype._removeInvisiblePoints = function(startTime, endTime) {
  for (var pointPid in this._pointMarkers) {
    if (objectHasProperty(this._pointMarkers, pointPid)) {
      var point = this._pointMarkers[pointPid].getPoint();
      if (!point.isVisible(startTime, endTime)) {
        this._removePoint(point);
      }
    }
  }
};
PointsLayer.prototype._removePoint = function(point) {
  var pointMarker = this.getPointMarker(point);
  if (pointMarker) {
    pointMarker.destroy();
    delete this._pointMarkers[point.pid];
  }
};
PointsLayer.prototype.setVisible = function(visible) {
  this._layer.setVisible(visible);
};
PointsLayer.prototype.destroy = function() {
  this._peaks.off("points.update", this._onPointsUpdate);
  this._peaks.off("points.add", this._onPointsAdd);
  this._peaks.off("points.remove", this._onPointsRemove);
  this._peaks.off("points.remove_all", this._onPointsRemoveAll);
  this._peaks.off("points.dragstart", this._onPointsDrag);
  this._peaks.off("points.dragmove", this._onPointsDrag);
  this._peaks.off("points.dragend", this._onPointsDrag);
};
PointsLayer.prototype.fitToView = function() {
  for (var pointPid in this._pointMarkers) {
    if (objectHasProperty(this._pointMarkers, pointPid)) {
      var pointMarker = this._pointMarkers[pointPid];
      pointMarker.fitToView();
    }
  }
};
PointsLayer.prototype.draw = function() {
  this._layer.draw();
};
function PlayheadLayer(player, view, options) {
  this._player = player;
  this._view = view;
  this._playheadPixel = 0;
  this._playheadLineAnimation = null;
  this._playheadVisible = false;
  this._playheadColor = options.playheadColor;
  this._playheadTextColor = options.playheadTextColor;
  this._playheadBackgroundColor = options.playheadBackgroundColor;
  this._playheadPadding = options.playheadPadding;
  this._playheadWidth = options.playheadWidth;
  this._playheadFontFamily = options.playheadFontFamily;
  this._playheadFontSize = options.playheadFontSize;
  this._playheadFontStyle = options.playheadFontStyle;
  this._playheadLayer = new Core_default.Layer({
    listening: false
  });
  this._createPlayhead();
  if (options.showPlayheadTime) {
    this._createPlayheadText();
  }
  this.fitToView();
  this.zoomLevelChanged();
}
PlayheadLayer.prototype.addToStage = function(stage) {
  stage.add(this._playheadLayer);
};
PlayheadLayer.prototype.zoomLevelChanged = function() {
  var pixelsPerSecond = this._view.timeToPixels(1);
  this._useAnimation = pixelsPerSecond >= 5;
  if (this._useAnimation) {
    if (this._player.isPlaying() && !this._playheadLineAnimation) {
      this._start();
    }
  } else {
    if (this._playheadLineAnimation) {
      var time2 = this._player.getCurrentTime();
      this.stop(time2);
    }
  }
};
PlayheadLayer.prototype.fitToView = function() {
  var height = this._view.getHeight();
  this._playheadLine.points([0.5, 0, 0.5, height]);
  if (this._playheadText) {
    this._playheadText.y(12);
  }
};
PlayheadLayer.prototype._createPlayhead = function() {
  this._playheadLine = new Line({
    stroke: this._playheadColor,
    strokeWidth: this._playheadWidth
  });
  this._playheadGroup = new Core_default.Group({
    x: 0,
    y: 0
  });
  this._playheadGroup.add(this._playheadLine);
  this._playheadLayer.add(this._playheadGroup);
};
PlayheadLayer.prototype._createPlayheadText = function() {
  var self2 = this;
  var time2 = self2._player.getCurrentTime();
  var text = self2._view.formatTime(time2);
  self2._playheadText = new Text({
    x: 0,
    y: 0,
    padding: self2._playheadPadding,
    text,
    fontSize: self2._playheadFontSize,
    fontFamily: self2._playheadFontFamily,
    fontStyle: self2._playheadFontStyle,
    fill: self2._playheadTextColor,
    align: "right",
    sceneFunc: function sceneFunc(context, shape) {
      var width = shape.width();
      var height = shape.height() + 2 * self2._playheadPadding;
      context.fillStyle = self2._playheadBackgroundColor;
      context.fillRect(0, -self2._playheadPadding, width, height);
      shape._sceneFunc(context);
    }
  });
  self2._playheadGroup.add(self2._playheadText);
};
PlayheadLayer.prototype.updatePlayheadTime = function(time2) {
  this._syncPlayhead(time2);
  if (this._player.isPlaying()) {
    this._start();
  }
};
PlayheadLayer.prototype._syncPlayhead = function(time2) {
  var pixelIndex = this._view.timeToPixels(time2);
  var frameOffset = this._view.getFrameOffset();
  var width = this._view.getWidth();
  var isVisible = pixelIndex >= frameOffset && pixelIndex <= frameOffset + width;
  this._playheadPixel = pixelIndex;
  if (isVisible) {
    var playheadX = this._playheadPixel - frameOffset;
    if (!this._playheadVisible) {
      this._playheadVisible = true;
      this._playheadGroup.show();
    }
    this._playheadGroup.setX(playheadX);
    if (this._playheadText) {
      var text = this._view.formatTime(time2);
      var playheadTextWidth = this._playheadText.width();
      this._playheadText.setText(text);
      if (playheadTextWidth + playheadX > width - 2) {
        this._playheadText.setX(-playheadTextWidth);
      } else if (playheadTextWidth + playheadX < width) {
        this._playheadText.setX(0);
      }
    }
  } else {
    if (this._playheadVisible) {
      this._playheadVisible = false;
      this._playheadGroup.hide();
    }
  }
  if (this._view.playheadPosChanged) {
    this._view.playheadPosChanged(time2);
  }
};
PlayheadLayer.prototype._start = function() {
  var self2 = this;
  if (self2._playheadLineAnimation) {
    self2._playheadLineAnimation.stop();
    self2._playheadLineAnimation = null;
  }
  if (!self2._useAnimation) {
    return;
  }
  var lastPlayheadPosition = null;
  self2._playheadLineAnimation = new Animation(function() {
    var time2 = self2._player.getCurrentTime();
    var playheadPosition = self2._view.timeToPixels(time2);
    if (playheadPosition !== lastPlayheadPosition) {
      self2._syncPlayhead(time2);
      lastPlayheadPosition = playheadPosition;
    }
  }, self2._playheadLayer);
  self2._playheadLineAnimation.start();
};
PlayheadLayer.prototype.stop = function(time2) {
  if (this._playheadLineAnimation) {
    this._playheadLineAnimation.stop();
    this._playheadLineAnimation = null;
  }
  this._syncPlayhead(time2);
};
PlayheadLayer.prototype.getPlayheadPixel = function() {
  return this._playheadPixel;
};
PlayheadLayer.prototype.showPlayheadTime = function(show) {
  if (show) {
    if (!this._playheadText) {
      this._createPlayheadText(this._playheadTextColor, this._playheadBackgroundColor, this._playheadPadding);
      this.fitToView();
    }
  } else {
    if (this._playheadText) {
      this._playheadText.remove();
      this._playheadText.destroy();
      this._playheadText = null;
    }
  }
};
PlayheadLayer.prototype.updatePlayheadText = function() {
  if (this._playheadText) {
    var time2 = this._player.getCurrentTime();
    var text = this._view.formatTime(time2);
    this._playheadText.setText(text);
  }
};
PlayheadLayer.prototype.destroy = function() {
  if (this._playheadLineAnimation) {
    this._playheadLineAnimation.stop();
    this._playheadLineAnimation = null;
  }
};
function OverlaySegmentMarker(options) {
  this._options = options;
}
OverlaySegmentMarker.prototype.init = function(group) {
  var handleWidth = 10;
  var handleHeight = 20;
  var handleX = -5 + 0.5;
  var xPosition = this._options.startMarker ? -24 : 24;
  var time2 = this._options.startMarker ? this._options.segment.startTime : this._options.segment.endTime;
  this._label = new Text({
    x: xPosition,
    y: 0,
    text: this._options.layer.formatTime(time2),
    fontFamily: this._options.fontFamily,
    fontSize: this._options.fontSize,
    fontStyle: this._options.fontStyle,
    fill: "#000",
    textAlign: "center",
    visible: false
  });
  this._handle = new Rect({
    x: handleX,
    y: 0,
    width: handleWidth,
    height: handleHeight
  });
  group.add(this._label);
  group.add(this._handle);
  this.fitToView();
  this.bindEventHandlers(group);
};
OverlaySegmentMarker.prototype.bindEventHandlers = function(group) {
  var self2 = this;
  var xPosition = self2._options.startMarker ? -24 : 24;
  group.on("dragstart", function() {
    if (self2._options.startMarker) {
      self2._label.setX(xPosition - self2._label.getWidth());
    }
    self2._label.show();
  });
  group.on("dragend", function() {
    self2._label.hide();
  });
  self2._handle.on("mouseover touchstart", function() {
    if (self2._options.startMarker) {
      self2._label.setX(xPosition - self2._label.getWidth());
    }
    self2._label.show();
    document.body.style.cursor = "ew-resize";
  });
  self2._handle.on("mouseout touchend", function() {
    self2._label.hide();
    document.body.style.cursor = "default";
  });
};
OverlaySegmentMarker.prototype.fitToView = function() {
  var viewHeight = this._options.layer.getHeight();
  var overlayOffset = this._options.segmentOptions.overlayOffset;
  var overlayRectHeight = clamp(0, viewHeight - 2 * overlayOffset);
  this._label.y(viewHeight / 2 - 5);
  this._handle.y(overlayOffset);
  this._handle.height(overlayRectHeight);
};
OverlaySegmentMarker.prototype.update = function(options) {
  if (options.startTime !== void 0 && this._options.startMarker) {
    this._label.text(this._options.layer.formatTime(options.startTime));
  }
  if (options.endTime !== void 0 && !this._options.startMarker) {
    this._label.text(this._options.layer.formatTime(options.endTime));
  }
};
function SegmentMarker(options) {
  var self2 = this;
  self2._segment = options.segment;
  self2._marker = options.marker;
  self2._segmentShape = options.segmentShape;
  self2._editable = options.editable;
  self2._startMarker = options.startMarker;
  self2._onClick = options.onClick;
  self2._onDragStart = options.onDragStart;
  self2._onDragMove = options.onDragMove;
  self2._onDragEnd = options.onDragEnd;
  self2._group = new Core_default.Group({
    name: "segment-marker",
    segment: self2._segment,
    draggable: self2._editable,
    visible: self2._editable,
    dragBoundFunc: function dragBoundFunc(pos) {
      return options.dragBoundFunc(self2, pos);
    }
  });
  self2._bindDefaultEventHandlers();
  self2._marker.init(self2._group);
}
SegmentMarker.prototype._bindDefaultEventHandlers = function() {
  var self2 = this;
  self2._group.on("click", function(event) {
    self2._onClick(self2, event);
  });
  self2._group.on("dragstart", function(event) {
    self2._onDragStart(self2, event);
  });
  self2._group.on("dragmove", function(event) {
    self2._onDragMove(self2, event);
  });
  self2._group.on("dragend", function(event) {
    self2._onDragEnd(self2, event);
  });
};
SegmentMarker.prototype.addToLayer = function(layer) {
  layer.add(this._group);
};
SegmentMarker.prototype.moveToTop = function() {
  this._group.moveToTop();
};
SegmentMarker.prototype.fitToView = function() {
  this._marker.fitToView();
};
SegmentMarker.prototype.getSegment = function() {
  return this._segment;
};
SegmentMarker.prototype.getX = function() {
  return this._group.getX();
};
SegmentMarker.prototype.setX = function(x) {
  this._group.setX(x);
};
SegmentMarker.prototype.getWidth = function() {
  return this._group.getWidth();
};
SegmentMarker.prototype.getAbsolutePosition = function() {
  return this._group.getAbsolutePosition();
};
SegmentMarker.prototype.isStartMarker = function() {
  return this._startMarker;
};
SegmentMarker.prototype.update = function(options) {
  if (options.editable !== void 0) {
    this._group.visible(options.editable);
    this._group.draggable(options.editable);
  }
  if (this._marker.update) {
    this._marker.update(options);
  }
};
SegmentMarker.prototype.destroy = function() {
  if (this._marker.destroy) {
    this._marker.destroy();
  }
  this._group.destroyChildren();
  this._group.destroy();
};
SegmentMarker.prototype.startDrag = function() {
  this._group.startDrag();
};
SegmentMarker.prototype.stopDrag = function() {
  this._group.stopDrag();
};
function WaveformShape(options) {
  this._color = options.color;
  var shapeOptions = {};
  if (isString(options.color)) {
    shapeOptions.fill = options.color;
  } else if (isLinearGradientColor(options.color)) {
    var startY = options.view._height * (options.color.linearGradientStart / 100);
    var endY = options.view._height * (options.color.linearGradientEnd / 100);
    shapeOptions.fillLinearGradientStartPointY = startY;
    shapeOptions.fillLinearGradientEndPointY = endY;
    shapeOptions.fillLinearGradientColorStops = [0, options.color.linearGradientColorStops[0], 1, options.color.linearGradientColorStops[1]];
  } else {
    throw new TypeError("Unknown type for color property");
  }
  this._shape = new Core_default.Shape(shapeOptions);
  this._view = options.view;
  this._segment = options.segment;
  this._shape.sceneFunc(this._sceneFunc.bind(this));
}
WaveformShape.prototype.getX = function() {
  return this._shape.getX();
};
WaveformShape.prototype.setX = function(x) {
  return this._shape.setX(x);
};
WaveformShape.prototype.setSegment = function(segment) {
  this._segment = segment;
};
WaveformShape.prototype.setWaveformColor = function(color) {
  if (isString(color)) {
    this._shape.fill(color);
    this._shape.fillLinearGradientStartPointY(null);
    this._shape.fillLinearGradientEndPointY(null);
    this._shape.fillLinearGradientColorStops(null);
  } else if (isLinearGradientColor(color)) {
    this._shape.fill(null);
    var startY = this._view._height * (color.linearGradientStart / 100);
    var endY = this._view._height * (color.linearGradientEnd / 100);
    this._shape.fillLinearGradientStartPointY(startY);
    this._shape.fillLinearGradientEndPointY(endY);
    this._shape.fillLinearGradientColorStops([0, color.linearGradientColorStops[0], 1, color.linearGradientColorStops[1]]);
  } else {
    throw new TypeError("Unknown type for color property");
  }
};
WaveformShape.prototype.fitToView = function() {
  this.setWaveformColor(this._color);
};
WaveformShape.prototype._sceneFunc = function(context) {
  var frameOffset = this._view.getFrameOffset();
  var width = this._view.getWidth();
  var height = this._view.getHeight();
  this._drawWaveform(context, this._view.getWaveformData(), frameOffset, this._segment ? this._view.timeToPixels(this._segment.startTime) : frameOffset, this._segment ? this._view.timeToPixels(this._segment.endTime) : frameOffset + width, width, height);
};
WaveformShape.prototype._drawWaveform = function(context, waveformData, frameOffset, startPixels, endPixels, width, height) {
  if (startPixels < frameOffset) {
    startPixels = frameOffset;
  }
  var limit = frameOffset + width;
  if (endPixels > limit) {
    endPixels = limit;
  }
  if (endPixels > waveformData.length - 1) {
    endPixels = waveformData.length - 1;
  }
  var channels = waveformData.channels;
  var waveformTop = 0;
  var waveformHeight = Math.floor(height / channels);
  for (var i = 0; i < channels; i++) {
    if (i === channels - 1) {
      waveformHeight = height - (channels - 1) * waveformHeight;
    }
    this._drawChannel(context, waveformData.channel(i), frameOffset, startPixels, endPixels, waveformTop, waveformHeight);
    waveformTop += waveformHeight;
  }
};
WaveformShape.prototype._drawChannel = function(context, channel2, frameOffset, startPixels, endPixels, top, height) {
  var x, amplitude;
  var amplitudeScale = this._view.getAmplitudeScale();
  var lineX, lineY;
  context.beginPath();
  for (x = startPixels; x <= endPixels; x++) {
    amplitude = channel2.min_sample(x);
    lineX = x - frameOffset + 0.5;
    lineY = top + WaveformShape.scaleY(amplitude, height, amplitudeScale) + 0.5;
    context.lineTo(lineX, lineY);
  }
  for (x = endPixels; x >= startPixels; x--) {
    amplitude = channel2.max_sample(x);
    lineX = x - frameOffset + 0.5;
    lineY = top + WaveformShape.scaleY(amplitude, height, amplitudeScale) + 1;
    context.lineTo(lineX, lineY);
  }
  context.closePath();
  context.fillShape(this._shape);
};
WaveformShape.prototype.addToLayer = function(layer) {
  layer.add(this._shape);
};
WaveformShape.prototype.destroy = function() {
  this._shape.destroy();
  this._shape = null;
};
WaveformShape.prototype.on = function(event, handler) {
  this._shape.on(event, handler);
};
WaveformShape.prototype.off = function(event, handler) {
  this._shape.off(event, handler);
};
WaveformShape.scaleY = function(amplitude, height, scale) {
  var y = -(height - 1) * (amplitude * scale + 128) / 255 + (height - 1);
  return clamp(Math.floor(y), 0, height - 1);
};
function SegmentShape(segment, peaks, layer, view) {
  this._segment = segment;
  this._peaks = peaks;
  this._layer = layer;
  this._view = view;
  this._label = null;
  this._startMarker = null;
  this._endMarker = null;
  this._color = segment.color;
  this._borderColor = segment.borderColor;
  this._draggable = this._segment.editable && this._view.isSegmentDraggingEnabled();
  this._dragging = false;
  var viewOptions = view.getViewOptions();
  var segmentOptions2 = viewOptions.segmentOptions;
  this._overlayOffset = segmentOptions2.overlayOffset;
  if (!segment.overlay) {
    this._waveformShape = new WaveformShape({
      color: segment.color,
      view,
      segment
    });
  }
  this._onMouseEnter = this._onMouseEnter.bind(this);
  this._onMouseLeave = this._onMouseLeave.bind(this);
  this._onMouseDown = this._onMouseDown.bind(this);
  this._onMouseUp = this._onMouseUp.bind(this);
  this._dragBoundFunc = this._dragBoundFunc.bind(this);
  this._onSegmentDragStart = this._onSegmentDragStart.bind(this);
  this._onSegmentDragMove = this._onSegmentDragMove.bind(this);
  this._onSegmentDragEnd = this._onSegmentDragEnd.bind(this);
  this._onSegmentMarkerClick = this._onSegmentMarkerClick.bind(this);
  this._onSegmentMarkerDragStart = this._onSegmentMarkerDragStart.bind(this);
  this._onSegmentMarkerDragMove = this._onSegmentMarkerDragMove.bind(this);
  this._onSegmentMarkerDragEnd = this._onSegmentMarkerDragEnd.bind(this);
  this._segmentMarkerDragBoundFunc = this._segmentMarkerDragBoundFunc.bind(this);
  this._label = this._peaks.options.createSegmentLabel({
    segment,
    view: this._view.getName(),
    layer: this._layer,
    fontFamily: viewOptions.fontFamily,
    fontSize: viewOptions.fontSize,
    fontStyle: viewOptions.fontStyle
  });
  if (this._label) {
    this._label.hide();
  }
  var segmentStartOffset = this._view.timeToPixelOffset(this._segment.startTime);
  var segmentEndOffset = this._view.timeToPixelOffset(this._segment.endTime);
  var overlayRectHeight = clamp(0, this._view.getHeight() - 2 * this._overlayOffset);
  this._overlay = new Core_default.Group({
    name: "segment-overlay",
    segment: this._segment,
    x: segmentStartOffset,
    y: 0,
    width: segmentEndOffset - segmentStartOffset,
    height: this._view.getHeight(),
    clipX: 0,
    clipY: this._overlayOffset,
    clipWidth: segmentEndOffset - segmentStartOffset,
    clipHeight: overlayRectHeight,
    draggable: this._draggable,
    dragBoundFunc: this._dragBoundFunc
  });
  var overlayBorderColor, overlayBorderWidth, overlayColor, overlayOpacity, overlayCornerRadius;
  if (segment.overlay) {
    overlayBorderColor = this._borderColor || segmentOptions2.overlayBorderColor;
    overlayBorderWidth = segmentOptions2.overlayBorderWidth;
    overlayColor = this._color || segmentOptions2.overlayColor;
    overlayOpacity = segmentOptions2.overlayOpacity;
    overlayCornerRadius = segmentOptions2.overlayCornerRadius;
  }
  this._overlayRect = new Core_default.Rect({
    x: 0,
    y: this._overlayOffset,
    width: segmentEndOffset - segmentStartOffset,
    stroke: overlayBorderColor,
    strokeWidth: overlayBorderWidth,
    height: overlayRectHeight,
    fill: overlayColor,
    opacity: overlayOpacity,
    cornerRadius: overlayCornerRadius
  });
  this._overlay.add(this._overlayRect);
  if (segment.overlay) {
    this._overlayText = new Core_default.Text({
      x: 0,
      y: this._overlayOffset,
      text: this._segment.labelText,
      fontFamily: segmentOptions2.overlayFontFamily,
      fontSize: segmentOptions2.overlayFontSize,
      fontStyle: segmentOptions2.overlayFontStyle,
      fill: segmentOptions2.overlayLabelColor,
      listening: false,
      align: segmentOptions2.overlayLabelAlign,
      width: segmentEndOffset - segmentStartOffset,
      verticalAlign: segmentOptions2.overlayLabelVerticalAlign,
      height: overlayRectHeight,
      padding: segmentOptions2.overlayLabelPadding
    });
    this._overlay.add(this._overlayText);
  }
  this._overlay.on("mouseenter", this._onMouseEnter);
  this._overlay.on("mouseleave", this._onMouseLeave);
  this._overlay.on("mousedown", this._onMouseDown);
  this._overlay.on("mouseup", this._onMouseUp);
  if (this._draggable) {
    this._overlay.on("dragstart", this._onSegmentDragStart);
    this._overlay.on("dragmove", this._onSegmentDragMove);
    this._overlay.on("dragend", this._onSegmentDragEnd);
  }
  this._createMarkers();
}
function createOverlayMarker(options) {
  return new OverlaySegmentMarker(options);
}
SegmentShape.prototype._createMarkers = function() {
  var editable = this._layer.isEditingEnabled() && this._segment.editable;
  var viewOptions = this._view.getViewOptions();
  var segmentOptions2 = viewOptions.segmentOptions;
  var createSegmentMarker2, startMarker, endMarker;
  if (this._segment.markers) {
    createSegmentMarker2 = this._peaks.options.createSegmentMarker;
  } else if (this._segment.overlay) {
    createSegmentMarker2 = createOverlayMarker;
  }
  if (createSegmentMarker2) {
    startMarker = createSegmentMarker2({
      segment: this._segment,
      editable,
      startMarker: true,
      color: segmentOptions2.startMarkerColor,
      fontFamily: viewOptions.fontFamily,
      fontSize: viewOptions.fontSize,
      fontStyle: viewOptions.fontStyle,
      layer: this._layer,
      view: this._view.getName(),
      segmentOptions: this._view.getViewOptions().segmentOptions
    });
  }
  if (startMarker) {
    this._startMarker = new SegmentMarker({
      segment: this._segment,
      segmentShape: this,
      editable,
      startMarker: true,
      marker: startMarker,
      onClick: this._onSegmentMarkerClick,
      onDragStart: this._onSegmentMarkerDragStart,
      onDragMove: this._onSegmentMarkerDragMove,
      onDragEnd: this._onSegmentMarkerDragEnd,
      dragBoundFunc: this._segmentMarkerDragBoundFunc
    });
  }
  if (createSegmentMarker2) {
    endMarker = createSegmentMarker2({
      segment: this._segment,
      editable,
      startMarker: false,
      color: segmentOptions2.endMarkerColor,
      fontFamily: viewOptions.fontFamily,
      fontSize: viewOptions.fontSize,
      fontStyle: viewOptions.fontStyle,
      layer: this._layer,
      view: this._view.getName(),
      segmentOptions: this._view.getViewOptions().segmentOptions
    });
  }
  if (endMarker) {
    this._endMarker = new SegmentMarker({
      segment: this._segment,
      segmentShape: this,
      editable,
      startMarker: false,
      marker: endMarker,
      onClick: this._onSegmentMarkerClick,
      onDragStart: this._onSegmentMarkerDragStart,
      onDragMove: this._onSegmentMarkerDragMove,
      onDragEnd: this._onSegmentMarkerDragEnd,
      dragBoundFunc: this._segmentMarkerDragBoundFunc
    });
  }
};
SegmentShape.prototype._dragBoundFunc = function(pos) {
  return {
    x: pos.x,
    y: 0
  };
};
SegmentShape.prototype.update = function(options) {
  var segmentStartOffset = this._view.timeToPixelOffset(this._segment.startTime);
  var segmentEndOffset = this._view.timeToPixelOffset(this._segment.endTime);
  var width = segmentEndOffset - segmentStartOffset;
  var marker;
  if (marker = this.getStartMarker()) {
    marker.setX(segmentStartOffset - marker.getWidth());
    if (options) {
      marker.update(options);
    }
  }
  if (marker = this.getEndMarker()) {
    marker.setX(segmentEndOffset);
    if (options) {
      marker.update(options);
    }
  }
  this._color = this._segment.color;
  this._borderColor = this._segment.bordercolor;
  if (this._label) {
    this._label.text(this._segment.labelText);
  }
  if (this._overlayText) {
    this._overlayText.text(this._segment.labelText);
  }
  if (this._segment.overlay) {
    if (this._color) {
      this._overlayRect.fill(this._color);
    }
    if (this._borderColor) {
      this._overlayRect.stroke(this._borderColor);
    }
  } else {
    this._waveformShape.setWaveformColor(this._segment.color);
  }
  if (!this._dragging) {
    if (this._overlay) {
      this._overlay.setAttrs({
        x: segmentStartOffset,
        width,
        clipWidth: width < 1 ? 1 : width
      });
      this._overlayRect.setAttrs({
        x: 0,
        width
      });
      if (this._overlayText) {
        this._overlayText.setAttrs({
          width
        });
      }
    }
  }
};
SegmentShape.prototype.getSegment = function() {
  return this._segment;
};
SegmentShape.prototype.getStartMarker = function() {
  return this._startMarker;
};
SegmentShape.prototype.getEndMarker = function() {
  return this._endMarker;
};
SegmentShape.prototype.addToLayer = function(layer) {
  if (this._waveformShape) {
    this._waveformShape.addToLayer(layer);
  }
  if (this._label) {
    layer.add(this._label);
  }
  if (this._overlay) {
    layer.add(this._overlay);
  }
  if (this._startMarker) {
    this._startMarker.addToLayer(layer);
  }
  if (this._endMarker) {
    this._endMarker.addToLayer(layer);
  }
};
SegmentShape.prototype.isDragging = function() {
  return this._dragging;
};
SegmentShape.prototype._onMouseEnter = function(event) {
  if (this._label) {
    this._label.moveToTop();
    this._label.show();
  }
  this._peaks.emit("segments.mouseenter", {
    segment: this._segment,
    evt: event.evt
  });
};
SegmentShape.prototype._onMouseLeave = function(event) {
  if (this._label) {
    this._label.hide();
  }
  this._peaks.emit("segments.mouseleave", {
    segment: this._segment,
    evt: event.evt
  });
};
SegmentShape.prototype._onMouseDown = function(event) {
  this._peaks.emit("segments.mousedown", {
    segment: this._segment,
    evt: event.evt
  });
};
SegmentShape.prototype._onMouseUp = function(event) {
  this._peaks.emit("segments.mouseup", {
    segment: this._segment,
    evt: event.evt
  });
};
SegmentShape.prototype.segmentClicked = function(eventName, event) {
  this._moveToTop();
  this._peaks.emit("segments." + eventName, event);
};
SegmentShape.prototype._moveToTop = function() {
  this._overlay.moveToTop();
  this._layer.moveSegmentMarkersToTop();
};
SegmentShape.prototype.enableSegmentDragging = function(enable) {
  if (!this._segment.editable) {
    return;
  }
  if (!this._draggable && enable) {
    this._overlay.on("dragstart", this._onSegmentDragStart);
    this._overlay.on("dragmove", this._onSegmentDragMove);
    this._overlay.on("dragend", this._onSegmentDragEnd);
  } else if (this._draggable && !enable) {
    this._overlay.off("dragstart", this._onSegmentDragStart);
    this._overlay.off("dragmove", this._onSegmentDragMove);
    this._overlay.off("dragend", this._onSegmentDragEnd);
  }
  this._overlay.draggable(enable);
  this._draggable = enable;
};
SegmentShape.prototype._setPreviousAndNextSegments = function() {
  if (this._view.getSegmentDragMode() !== "overlap") {
    this._nextSegment = this._peaks.segments.findNextSegment(this._segment);
    this._previousSegment = this._peaks.segments.findPreviousSegment(this._segment);
  } else {
    this._nextSegment = null;
    this._previousSegment = null;
  }
};
SegmentShape.prototype._onSegmentDragStart = function(event) {
  this._setPreviousAndNextSegments();
  this._dragging = true;
  this._dragStartX = this._overlay.getX();
  this._dragStartTime = this._segment.startTime;
  this._dragEndTime = this._segment.endTime;
  this._peaks.emit("segments.dragstart", {
    segment: this._segment,
    marker: false,
    startMarker: false,
    evt: event.evt
  });
};
SegmentShape.prototype._onSegmentDragMove = function(event) {
  var x = this._overlay.getX();
  var offsetX = x - this._dragStartX;
  var timeOffset = this._view.pixelsToTime(offsetX);
  var startTime = this._dragStartTime + timeOffset;
  var endTime = this._dragEndTime + timeOffset;
  var segmentDuration = this._segment.endTime - this._segment.startTime;
  var dragMode;
  var minSegmentWidth = this._view.getMinSegmentDragWidth();
  var minSegmentDuration = this._view.pixelsToTime(minSegmentWidth);
  var previousSegmentUpdated = false;
  var nextSegmentUpdated = false;
  if (startTime < 0) {
    startTime = 0;
    endTime = segmentDuration;
    this._overlay.setX(this._view.timeToPixelOffset(startTime));
  }
  if (this._previousSegment) {
    var previousSegmentEndX = this._view.timeToPixelOffset(this._previousSegment.endTime);
    if (startTime < this._previousSegment.endTime) {
      dragMode = this._view.getSegmentDragMode();
      if (dragMode === "no-overlap" || dragMode === "compress" && !this._previousSegment.editable) {
        startTime = this._previousSegment.endTime;
        endTime = startTime + segmentDuration;
        this._overlay.setX(previousSegmentEndX);
      } else if (dragMode === "compress") {
        var previousSegmentEndTime = startTime;
        var minPreviousSegmentEndTime = this._previousSegment.startTime + minSegmentDuration;
        if (previousSegmentEndTime < minPreviousSegmentEndTime) {
          previousSegmentEndTime = minPreviousSegmentEndTime;
          previousSegmentEndX = this._view.timeToPixelOffset(previousSegmentEndTime);
          this._overlay.setX(previousSegmentEndX);
          startTime = previousSegmentEndTime;
          endTime = startTime + segmentDuration;
        }
        this._previousSegment.update({
          endTime: previousSegmentEndTime
        });
        previousSegmentUpdated = true;
      }
    }
  }
  if (this._nextSegment) {
    var nextSegmentStartX = this._view.timeToPixelOffset(this._nextSegment.startTime);
    if (endTime > this._nextSegment.startTime) {
      dragMode = this._view.getSegmentDragMode();
      if (dragMode === "no-overlap" || dragMode === "compress" && !this._nextSegment.editable) {
        endTime = this._nextSegment.startTime;
        startTime = endTime - segmentDuration;
        this._overlay.setX(nextSegmentStartX - this._overlay.getWidth());
      } else if (dragMode === "compress") {
        var nextSegmentStartTime = endTime;
        var maxNextSegmentStartTime = this._nextSegment.endTime - minSegmentDuration;
        if (nextSegmentStartTime > maxNextSegmentStartTime) {
          nextSegmentStartTime = maxNextSegmentStartTime;
          nextSegmentStartX = this._view.timeToPixelOffset(nextSegmentStartTime);
          this._overlay.setX(nextSegmentStartX - this._overlay.getWidth());
          endTime = nextSegmentStartTime;
          startTime = endTime - segmentDuration;
        }
        this._nextSegment.update({
          startTime: nextSegmentStartTime
        });
        nextSegmentUpdated = true;
      }
    }
  }
  this._segment._setStartTime(startTime);
  this._segment._setEndTime(endTime);
  this._peaks.emit("segments.dragged", {
    segment: this._segment,
    marker: false,
    startMarker: false,
    evt: event.evt
  });
  if (previousSegmentUpdated) {
    this._peaks.emit("segments.dragged", {
      segment: this._previousSegment,
      marker: false,
      startMarker: false,
      evt: event.evt
    });
  } else if (nextSegmentUpdated) {
    this._peaks.emit("segments.dragged", {
      segment: this._nextSegment,
      marker: false,
      startMarker: false,
      evt: event.evt
    });
  }
};
SegmentShape.prototype._onSegmentDragEnd = function(event) {
  this._dragging = false;
  this._peaks.emit("segments.dragend", {
    segment: this._segment,
    marker: false,
    startMarker: false,
    evt: event.evt
  });
};
SegmentShape.prototype.moveMarkersToTop = function() {
  if (this._startMarker) {
    this._startMarker.moveToTop();
  }
  if (this._endMarker) {
    this._endMarker.moveToTop();
  }
};
SegmentShape.prototype.startDrag = function() {
  if (this._endMarker) {
    this._endMarker.startDrag();
  }
};
SegmentShape.prototype.stopDrag = function() {
  if (this._endMarker) {
    this._endMarker.stopDrag();
  }
};
SegmentShape.prototype._onSegmentMarkerDragStart = function(segmentMarker, event) {
  this._setPreviousAndNextSegments();
  this._moveToTop();
  this._startMarkerX = this._startMarker.getX();
  this._endMarkerX = this._endMarker.getX();
  this._peaks.emit("segments.dragstart", {
    segment: this._segment,
    marker: true,
    startMarker: segmentMarker.isStartMarker(),
    evt: event.evt
  });
};
SegmentShape.prototype._onSegmentMarkerDragMove = function(segmentMarker, event) {
  if (segmentMarker.isStartMarker()) {
    this._segmentStartMarkerDragMove(segmentMarker, event);
    segmentMarker.update({
      startTime: this._segment.startTime
    });
  } else {
    this._segmentEndMarkerDragMove(segmentMarker, event);
    segmentMarker.update({
      endTime: this._segment.endTime
    });
  }
};
function getDuration(segment) {
  return segment.endTime - segment.startTime;
}
SegmentShape.prototype._segmentStartMarkerDragMove = function(segmentMarker, event) {
  var width = this._view.getWidth();
  var startMarkerX = this._startMarker.getX();
  var endMarkerX = this._endMarker.getX();
  var minSegmentDuration = this._view.pixelsToTime(50);
  var minSegmentWidth = this._view.getMinSegmentDragWidth();
  var upperLimit = this._endMarker.getX() - minSegmentWidth;
  if (upperLimit > width) {
    upperLimit = width;
  }
  var previousSegmentVisible = false;
  var previousSegmentUpdated = false;
  var previousSegmentEndX;
  if (this._previousSegment) {
    previousSegmentEndX = this._view.timeToPixelOffset(this._previousSegment.endTime);
    previousSegmentVisible = previousSegmentEndX >= 0;
  }
  if (startMarkerX > upperLimit) {
    segmentMarker.setX(upperLimit);
    this._overlay.clipWidth(upperLimit - endMarkerX);
    if (minSegmentWidth === 0 && upperLimit < width) {
      this._segment._setStartTime(this._segment.endTime);
    } else {
      this._segment._setStartTime(this._view.pixelOffsetToTime(upperLimit));
    }
  } else if (this._previousSegment && previousSegmentVisible) {
    var dragMode = this._view.getSegmentDragMode();
    var fixedPreviousSegment = dragMode === "no-overlap" || dragMode === "compress" && !this._previousSegment.editable;
    var compressPreviousSegment = dragMode === "compress" && this._previousSegment.editable;
    if (startMarkerX <= previousSegmentEndX) {
      if (fixedPreviousSegment) {
        segmentMarker.setX(previousSegmentEndX);
        this._overlay.clipWidth(previousSegmentEndX - endMarkerX);
        this._segment._setStartTime(this._previousSegment.endTime);
      } else if (compressPreviousSegment) {
        var previousSegmentDuration = getDuration(this._previousSegment);
        if (previousSegmentDuration < minSegmentDuration) {
          minSegmentDuration = previousSegmentDuration;
        }
        var lowerLimit = this._view.timeToPixelOffset(this._previousSegment.startTime + minSegmentDuration);
        if (startMarkerX < lowerLimit) {
          startMarkerX = lowerLimit;
        }
        segmentMarker.setX(startMarkerX);
        this._overlay.clipWidth(endMarkerX - startMarkerX);
        this._segment._setStartTime(this._view.pixelOffsetToTime(startMarkerX));
        this._previousSegment.update({
          endTime: this._view.pixelOffsetToTime(startMarkerX)
        });
        previousSegmentUpdated = true;
      }
    } else {
      if (startMarkerX < 0) {
        startMarkerX = 0;
      }
      segmentMarker.setX(startMarkerX);
      this._overlay.clipWidth(endMarkerX - startMarkerX);
      this._segment._setStartTime(this._view.pixelOffsetToTime(startMarkerX));
    }
  } else {
    if (startMarkerX < 0) {
      startMarkerX = 0;
    }
    segmentMarker.setX(startMarkerX);
    this._overlay.clipWidth(endMarkerX - startMarkerX);
    this._segment._setStartTime(this._view.pixelOffsetToTime(startMarkerX));
  }
  this._peaks.emit("segments.dragged", {
    segment: this._segment,
    marker: true,
    startMarker: true,
    evt: event.evt
  });
  if (previousSegmentUpdated) {
    this._peaks.emit("segments.dragged", {
      segment: this._previousSegment,
      marker: true,
      startMarker: false,
      evt: event.evt
    });
  }
};
SegmentShape.prototype._segmentEndMarkerDragMove = function(segmentMarker, event) {
  var width = this._view.getWidth();
  var startMarkerX = this._startMarker.getX();
  var endMarkerX = this._endMarker.getX();
  var minSegmentDuration = this._view.pixelsToTime(50);
  var minSegmentWidth = this._view.getMinSegmentDragWidth();
  var lowerLimit = this._startMarker.getX() + minSegmentWidth;
  if (lowerLimit < 0) {
    lowerLimit = 0;
  }
  var nextSegmentVisible = false;
  var nextSegmentUpdated = false;
  var nextSegmentStartX;
  if (this._nextSegment) {
    nextSegmentStartX = this._view.timeToPixelOffset(this._nextSegment.startTime);
    nextSegmentVisible = nextSegmentStartX < width;
  }
  if (endMarkerX < lowerLimit) {
    segmentMarker.setX(lowerLimit);
    this._overlay.clipWidth(lowerLimit - startMarkerX);
    if (minSegmentWidth === 0 && lowerLimit > 0) {
      this._segment._setEndTime(this._segment.startTime);
    } else {
      this._segment._setEndTime(this._view.pixelOffsetToTime(lowerLimit));
    }
  } else if (this._nextSegment && nextSegmentVisible) {
    var dragMode = this._view.getSegmentDragMode();
    var fixedNextSegment = dragMode === "no-overlap" || dragMode === "compress" && !this._nextSegment.editable;
    var compressNextSegment = dragMode === "compress" && this._nextSegment.editable;
    if (endMarkerX >= nextSegmentStartX) {
      if (fixedNextSegment) {
        segmentMarker.setX(nextSegmentStartX);
        this._overlay.clipWidth(nextSegmentStartX - startMarkerX);
        this._segment._setEndTime(this._nextSegment.startTime);
      } else if (compressNextSegment) {
        var nextSegmentDuration = getDuration(this._nextSegment);
        if (nextSegmentDuration < minSegmentDuration) {
          minSegmentDuration = nextSegmentDuration;
        }
        var upperLimit = this._view.timeToPixelOffset(this._nextSegment.endTime - minSegmentDuration);
        if (endMarkerX > upperLimit) {
          endMarkerX = upperLimit;
        }
        segmentMarker.setX(endMarkerX);
        this._overlay.clipWidth(endMarkerX - startMarkerX);
        this._segment._setEndTime(this._view.pixelOffsetToTime(endMarkerX));
        this._nextSegment.update({
          startTime: this._view.pixelOffsetToTime(endMarkerX)
        });
        nextSegmentUpdated = true;
      }
    } else {
      if (endMarkerX > width) {
        endMarkerX = width;
      }
      segmentMarker.setX(endMarkerX);
      this._overlay.clipWidth(endMarkerX - startMarkerX);
      this._segment._setEndTime(this._view.pixelOffsetToTime(endMarkerX));
    }
  } else {
    if (endMarkerX > width) {
      endMarkerX = width;
    }
    segmentMarker.setX(endMarkerX);
    this._overlay.clipWidth(endMarkerX - startMarkerX);
    this._segment._setEndTime(this._view.pixelOffsetToTime(endMarkerX));
  }
  this._peaks.emit("segments.dragged", {
    segment: this._segment,
    marker: true,
    startMarker: false,
    evt: event.evt
  });
  if (nextSegmentUpdated) {
    this._peaks.emit("segments.dragged", {
      segment: this._nextSegment,
      marker: true,
      startMarker: true,
      evt: event.evt
    });
  }
};
SegmentShape.prototype._onSegmentMarkerDragEnd = function(segmentMarker, event) {
  this._nextSegment = null;
  this._previousSegment = null;
  var startMarker = segmentMarker.isStartMarker();
  this._peaks.emit("segments.dragend", {
    segment: this._segment,
    marker: true,
    startMarker,
    evt: event.evt
  });
};
SegmentShape.prototype._segmentMarkerDragBoundFunc = function(segmentMarker, pos) {
  return {
    x: pos.x,
    y: segmentMarker.getAbsolutePosition().y
  };
};
SegmentShape.prototype._onSegmentMarkerClick = function() {
  this._moveToTop();
};
SegmentShape.prototype.fitToView = function() {
  if (this._startMarker) {
    this._startMarker.fitToView();
  }
  if (this._endMarker) {
    this._endMarker.fitToView();
  }
  if (this._overlay) {
    var height = this._view.getHeight();
    var overlayRectHeight = clamp(0, height - this._overlayOffset * 2);
    this._overlay.setAttrs({
      y: 0,
      height,
      clipY: this._overlayOffset,
      clipHeight: overlayRectHeight
    });
    this._overlayRect.setAttrs({
      y: this._overlayOffset,
      height: overlayRectHeight
    });
    if (this._overlayText) {
      this._overlayText.setAttrs({
        y: this._overlayOffset,
        height: overlayRectHeight
      });
    }
  }
};
SegmentShape.prototype.destroy = function() {
  if (this._waveformShape) {
    this._waveformShape.destroy();
  }
  if (this._label) {
    this._label.destroy();
  }
  if (this._startMarker) {
    this._startMarker.destroy();
  }
  if (this._endMarker) {
    this._endMarker.destroy();
  }
  if (this._overlay) {
    this._overlay.destroy();
  }
};
function SegmentsLayer(peaks, view, enableEditing) {
  this._peaks = peaks;
  this._view = view;
  this._enableEditing = enableEditing;
  this._segmentShapes = {};
  this._layer = new Core_default.Layer();
  this._onSegmentsUpdate = this._onSegmentsUpdate.bind(this);
  this._onSegmentsAdd = this._onSegmentsAdd.bind(this);
  this._onSegmentsRemove = this._onSegmentsRemove.bind(this);
  this._onSegmentsRemoveAll = this._onSegmentsRemoveAll.bind(this);
  this._onSegmentsDragged = this._onSegmentsDragged.bind(this);
  this._peaks.on("segments.update", this._onSegmentsUpdate);
  this._peaks.on("segments.add", this._onSegmentsAdd);
  this._peaks.on("segments.remove", this._onSegmentsRemove);
  this._peaks.on("segments.remove_all", this._onSegmentsRemoveAll);
  this._peaks.on("segments.dragged", this._onSegmentsDragged);
}
SegmentsLayer.prototype.addToStage = function(stage) {
  stage.add(this._layer);
};
SegmentsLayer.prototype.setListening = function(listening) {
  this._layer.listening(listening);
};
SegmentsLayer.prototype.enableEditing = function(enable) {
  this._enableEditing = enable;
};
SegmentsLayer.prototype.isEditingEnabled = function() {
  return this._enableEditing;
};
SegmentsLayer.prototype.enableSegmentDragging = function(enable) {
  for (var segmentPid in this._segmentShapes) {
    if (objectHasProperty(this._segmentShapes, segmentPid)) {
      this._segmentShapes[segmentPid].enableSegmentDragging(enable);
    }
  }
};
SegmentsLayer.prototype.getSegmentShape = function(segment) {
  return this._segmentShapes[segment.pid];
};
SegmentsLayer.prototype.formatTime = function(time2) {
  return this._view.formatTime(time2);
};
SegmentsLayer.prototype._onSegmentsUpdate = function(segment, options) {
  var frameStartTime = this._view.getStartTime();
  var frameEndTime = this._view.getEndTime();
  var segmentShape = this.getSegmentShape(segment);
  var isVisible = segment.isVisible(frameStartTime, frameEndTime);
  if (segmentShape && !isVisible) {
    if (!segmentShape.isDragging()) {
      this._removeSegment(segment);
    }
  } else if (!segmentShape && isVisible) {
    segmentShape = this._updateSegment(segment);
  } else if (segmentShape && isVisible) {
    segmentShape.update(options);
  }
};
SegmentsLayer.prototype._onSegmentsAdd = function(event) {
  var self2 = this;
  var frameStartTime = self2._view.getStartTime();
  var frameEndTime = self2._view.getEndTime();
  event.segments.forEach(function(segment) {
    if (segment.isVisible(frameStartTime, frameEndTime)) {
      var segmentShape = self2._addSegmentShape(segment);
      segmentShape.update();
    }
  });
  this.moveSegmentMarkersToTop();
};
SegmentsLayer.prototype._onSegmentsRemove = function(event) {
  var self2 = this;
  event.segments.forEach(function(segment) {
    self2._removeSegment(segment);
  });
};
SegmentsLayer.prototype._onSegmentsRemoveAll = function() {
  this._layer.removeChildren();
  this._segmentShapes = {};
};
SegmentsLayer.prototype._onSegmentsDragged = function(event) {
  this._updateSegment(event.segment);
};
SegmentsLayer.prototype._createSegmentShape = function(segment) {
  return new SegmentShape(segment, this._peaks, this, this._view);
};
SegmentsLayer.prototype._addSegmentShape = function(segment) {
  var segmentShape = this._createSegmentShape(segment);
  segmentShape.addToLayer(this._layer);
  this._segmentShapes[segment.pid] = segmentShape;
  return segmentShape;
};
SegmentsLayer.prototype.updateSegments = function(startTime, endTime) {
  var segments = this._peaks.segments.find(startTime, endTime);
  segments.forEach(this._updateSegment.bind(this));
  this._removeInvisibleSegments(startTime, endTime);
};
SegmentsLayer.prototype._updateSegment = function(segment) {
  var segmentShape = this.getSegmentShape(segment);
  if (!segmentShape) {
    segmentShape = this._addSegmentShape(segment);
  }
  segmentShape.update();
};
SegmentsLayer.prototype._removeInvisibleSegments = function(startTime, endTime) {
  for (var segmentPid in this._segmentShapes) {
    if (objectHasProperty(this._segmentShapes, segmentPid)) {
      var segment = this._segmentShapes[segmentPid].getSegment();
      if (!segment.isVisible(startTime, endTime)) {
        this._removeSegment(segment);
      }
    }
  }
};
SegmentsLayer.prototype._removeSegment = function(segment) {
  var segmentShape = this._segmentShapes[segment.pid];
  if (segmentShape) {
    segmentShape.destroy();
    delete this._segmentShapes[segment.pid];
  }
};
SegmentsLayer.prototype.moveSegmentMarkersToTop = function() {
  for (var segmentPid in this._segmentShapes) {
    if (objectHasProperty(this._segmentShapes, segmentPid)) {
      this._segmentShapes[segmentPid].moveMarkersToTop();
    }
  }
};
SegmentsLayer.prototype.setVisible = function(visible) {
  this._layer.setVisible(visible);
};
SegmentsLayer.prototype.segmentClicked = function(eventName, event) {
  var segmentShape = this._segmentShapes[event.segment.pid];
  if (segmentShape) {
    segmentShape.segmentClicked(eventName, event);
  }
};
SegmentsLayer.prototype.destroy = function() {
  this._peaks.off("segments.update", this._onSegmentsUpdate);
  this._peaks.off("segments.add", this._onSegmentsAdd);
  this._peaks.off("segments.remove", this._onSegmentsRemove);
  this._peaks.off("segments.remove_all", this._onSegmentsRemoveAll);
  this._peaks.off("segments.dragged", this._onSegmentsDragged);
};
SegmentsLayer.prototype.fitToView = function() {
  for (var segmentPid in this._segmentShapes) {
    if (objectHasProperty(this._segmentShapes, segmentPid)) {
      var segmentShape = this._segmentShapes[segmentPid];
      segmentShape.fitToView();
    }
  }
};
SegmentsLayer.prototype.draw = function() {
  this._layer.draw();
};
SegmentsLayer.prototype.getHeight = function() {
  return this._layer.getHeight();
};
function WaveformAxis(view, options) {
  var self2 = this;
  self2._axisGridlineColor = options.axisGridlineColor;
  self2._axisLabelColor = options.axisLabelColor;
  self2._showAxisLabels = options.showAxisLabels;
  self2._axisTopMarkerHeight = options.axisTopMarkerHeight;
  self2._axisBottomMarkerHeight = options.axisBottomMarkerHeight;
  if (options.formatAxisTime) {
    self2._formatAxisTime = options.formatAxisTime;
  } else {
    self2._formatAxisTime = function(time2) {
      return formatTime(time2, 0);
    };
  }
  self2._axisLabelFont = WaveformAxis._buildFontString(options.fontFamily, options.fontSize, options.fontStyle);
  self2._axisShape = new Core_default.Shape({
    sceneFunc: function sceneFunc(context) {
      self2._drawAxis(context, view);
    }
  });
}
WaveformAxis._buildFontString = function(fontFamily, fontSize, fontStyle) {
  if (!fontSize) {
    fontSize = 11;
  }
  if (!fontFamily) {
    fontFamily = "sans-serif";
  }
  if (!fontStyle) {
    fontStyle = "normal";
  }
  return fontStyle + " " + fontSize + "px " + fontFamily;
};
WaveformAxis.prototype.addToLayer = function(layer) {
  layer.add(this._axisShape);
};
WaveformAxis.prototype.showAxisLabels = function(show, options) {
  this._showAxisLabels = show;
  if (options) {
    if (objectHasProperty(options, "topMarkerHeight")) {
      this._axisTopMarkerHeight = options.topMarkerHeight;
    }
    if (objectHasProperty(options, "bottomMarkerHeight")) {
      this._axisBottomMarkerHeight = options.bottomMarkerHeight;
    }
  }
};
WaveformAxis.prototype.setAxisLabelColor = function(color) {
  this._axisLabelColor = color;
};
WaveformAxis.prototype.setAxisGridlineColor = function(color) {
  this._axisGridlineColor = color;
};
WaveformAxis.prototype._getAxisLabelScale = function(view) {
  var baseSecs = 1;
  var steps = [1, 2, 5, 10, 20, 30];
  var minSpacing = 60;
  var index = 0;
  var secs;
  for (; ; ) {
    secs = baseSecs * steps[index];
    var pixels = view.timeToPixels(secs);
    if (pixels < minSpacing) {
      if (++index === steps.length) {
        baseSecs *= 60;
        index = 0;
      }
    } else {
      break;
    }
  }
  return secs;
};
WaveformAxis.prototype._drawAxis = function(context, view) {
  var currentFrameStartTime = view.getStartTime();
  var axisLabelIntervalSecs = this._getAxisLabelScale(view);
  var firstAxisLabelSecs = roundUpToNearest(currentFrameStartTime, axisLabelIntervalSecs);
  var axisLabelOffsetSecs = firstAxisLabelSecs - currentFrameStartTime;
  var axisLabelOffsetPixels = view.timeToPixels(axisLabelOffsetSecs);
  context.setAttr("strokeStyle", this._axisGridlineColor);
  context.setAttr("lineWidth", 1);
  context.setAttr("font", this._axisLabelFont);
  context.setAttr("fillStyle", this._axisLabelColor);
  context.setAttr("textAlign", "left");
  context.setAttr("textBaseline", "bottom");
  var width = view.getWidth();
  var height = view.getHeight();
  var secs = firstAxisLabelSecs;
  for (; ; ) {
    var x = axisLabelOffsetPixels + view.timeToPixels(secs - firstAxisLabelSecs);
    if (x >= width) {
      break;
    }
    if (this._axisTopMarkerHeight > 0) {
      context.beginPath();
      context.moveTo(x + 0.5, 0);
      context.lineTo(x + 0.5, 0 + this._axisTopMarkerHeight);
      context.stroke();
    }
    if (this._axisBottomMarkerHeight > 0) {
      context.beginPath();
      context.moveTo(x + 0.5, height);
      context.lineTo(x + 0.5, height - this._axisBottomMarkerHeight);
      context.stroke();
    }
    if (this._showAxisLabels) {
      var label = this._formatAxisTime(secs);
      var labelWidth = context.measureText(label).width;
      var labelX = x - labelWidth / 2;
      var labelY = height - 1 - this._axisBottomMarkerHeight;
      if (labelX >= 0) {
        context.fillText(label, labelX, labelY);
      }
    }
    secs += axisLabelIntervalSecs;
  }
};
function WaveformView(waveformData, container, peaks, viewOptions) {
  var self2 = this;
  self2._container = container;
  self2._peaks = peaks;
  self2._options = peaks.options;
  self2._viewOptions = viewOptions;
  self2._originalWaveformData = waveformData;
  self2._data = waveformData;
  self2._frameOffset = 0;
  self2._width = container.clientWidth;
  self2._height = container.clientHeight;
  self2._amplitudeScale = 1;
  self2._waveformColor = self2._viewOptions.waveformColor;
  self2._playedWaveformColor = self2._viewOptions.playedWaveformColor;
  self2._timeLabelPrecision = self2._viewOptions.timeLabelPrecision;
  if (self2._viewOptions.formatPlayheadTime) {
    self2._formatPlayheadTime = self2._viewOptions.formatPlayheadTime;
  } else {
    self2._formatPlayheadTime = function(time2) {
      return formatTime(time2, self2._timeLabelPrecision);
    };
  }
  self2._enableSeek = true;
  self2.initWaveformData();
  Core_default.showWarnings = false;
  self2._stage = new Core_default.Stage({
    container,
    width: self2._width,
    height: self2._height
  });
  self2._createWaveform();
  if (self2._viewOptions.enableSegments) {
    self2._segmentsLayer = new SegmentsLayer(peaks, self2, self2._viewOptions.enableEditing);
    self2._segmentsLayer.addToStage(self2._stage);
  }
  if (self2._viewOptions.enablePoints) {
    self2._pointsLayer = new PointsLayer(peaks, self2, self2._viewOptions.enableEditing);
    self2._pointsLayer.addToStage(self2._stage);
  }
  self2.initHighlightLayer();
  self2._createAxisLabels();
  self2._playheadLayer = new PlayheadLayer(self2._peaks.player, self2, self2._viewOptions);
  self2._playheadLayer.addToStage(self2._stage);
  self2._onClick = self2._onClick.bind(self2);
  self2._onDblClick = self2._onDblClick.bind(self2);
  self2._onContextMenu = self2._onContextMenu.bind(self2);
  self2._stage.on("click", self2._onClick);
  self2._stage.on("dblclick", self2._onDblClick);
  self2._stage.on("contextmenu", self2._onContextMenu);
}
WaveformView.prototype.getViewOptions = function() {
  return this._viewOptions;
};
WaveformView.prototype.getWaveformData = function() {
  return this._data;
};
WaveformView.prototype.setWaveformData = function(waveformData) {
  this._data = waveformData;
};
WaveformView.prototype.timeToPixels = function(time2) {
  return Math.floor(time2 * this._data.sample_rate / this._data.scale);
};
WaveformView.prototype.pixelsToTime = function(pixels) {
  return pixels * this._data.scale / this._data.sample_rate;
};
WaveformView.prototype.pixelOffsetToTime = function(offset) {
  var pixels = this._frameOffset + offset;
  return pixels * this._data.scale / this._data.sample_rate;
};
WaveformView.prototype.timeToPixelOffset = function(time2) {
  return Math.floor(time2 * this._data.sample_rate / this._data.scale) - this._frameOffset;
};
WaveformView.prototype.getFrameOffset = function() {
  return this._frameOffset;
};
WaveformView.prototype.getWidth = function() {
  return this._width;
};
WaveformView.prototype.getHeight = function() {
  return this._height;
};
WaveformView.prototype.getStartTime = function() {
  return this.pixelOffsetToTime(0);
};
WaveformView.prototype.getEndTime = function() {
  return this.pixelOffsetToTime(this._width);
};
WaveformView.prototype._getDuration = function() {
  return this._peaks.player.getDuration();
};
WaveformView.prototype._createWaveform = function() {
  this._waveformLayer = new Core_default.Layer({
    listening: false
  });
  this._createWaveformShapes();
  this._stage.add(this._waveformLayer);
};
WaveformView.prototype._createWaveformShapes = function() {
  if (!this._waveformShape) {
    this._waveformShape = new WaveformShape({
      color: this._waveformColor,
      view: this
    });
    this._waveformShape.addToLayer(this._waveformLayer);
  }
  if (this._playedWaveformColor && !this._playedWaveformShape) {
    var time2 = this._peaks.player.getCurrentTime();
    this._playedSegment = {
      startTime: 0,
      endTime: time2
    };
    this._unplayedSegment = {
      startTime: time2,
      endTime: this._getDuration()
    };
    this._waveformShape.setSegment(this._unplayedSegment);
    this._playedWaveformShape = new WaveformShape({
      color: this._playedWaveformColor,
      view: this,
      segment: this._playedSegment
    });
    this._playedWaveformShape.addToLayer(this._waveformLayer);
  }
};
WaveformView.prototype.setWaveformColor = function(color) {
  this._waveformColor = color;
  this._waveformShape.setWaveformColor(color);
};
WaveformView.prototype.setPlayedWaveformColor = function(color) {
  this._playedWaveformColor = color;
  if (color) {
    if (!this._playedWaveformShape) {
      this._createWaveformShapes();
    }
    this._playedWaveformShape.setWaveformColor(color);
  } else {
    if (this._playedWaveformShape) {
      this._destroyPlayedWaveformShape();
    }
  }
};
WaveformView.prototype._destroyPlayedWaveformShape = function() {
  this._waveformShape.setSegment(null);
  this._playedWaveformShape.destroy();
  this._playedWaveformShape = null;
  this._playedSegment = null;
  this._unplayedSegment = null;
};
WaveformView.prototype._createAxisLabels = function() {
  this._axisLayer = new Core_default.Layer({
    listening: false
  });
  this._axis = new WaveformAxis(this, this._viewOptions);
  this._axis.addToLayer(this._axisLayer);
  this._stage.add(this._axisLayer);
};
WaveformView.prototype.showAxisLabels = function(show, options) {
  this._axis.showAxisLabels(show, options);
  this._axisLayer.draw();
};
WaveformView.prototype.setAxisLabelColor = function(color) {
  this._axis.setAxisLabelColor(color);
  this._axisLayer.draw();
};
WaveformView.prototype.setAxisGridlineColor = function(color) {
  this._axis.setAxisGridlineColor(color);
  this._axisLayer.draw();
};
WaveformView.prototype.showPlayheadTime = function(show) {
  this._playheadLayer.showPlayheadTime(show);
};
WaveformView.prototype.setTimeLabelPrecision = function(precision) {
  this._timeLabelPrecision = precision;
  this._playheadLayer.updatePlayheadText();
};
WaveformView.prototype.formatTime = function(time2) {
  return this._formatPlayheadTime(time2);
};
WaveformView.prototype.setAmplitudeScale = function(scale) {
  if (!isNumber(scale) || !isFinite2(scale)) {
    throw new Error("view.setAmplitudeScale(): Scale must be a valid number");
  }
  this._amplitudeScale = scale;
  this.drawWaveformLayer();
  if (this._segmentsLayer) {
    this._segmentsLayer.draw();
  }
};
WaveformView.prototype.getAmplitudeScale = function() {
  return this._amplitudeScale;
};
WaveformView.prototype.enableSeek = function(enable) {
  this._enableSeek = enable;
};
WaveformView.prototype.isSeekEnabled = function() {
  return this._enableSeek;
};
WaveformView.prototype._onClick = function(event) {
  this._clickHandler(event, "click");
};
WaveformView.prototype._onDblClick = function(event) {
  this._clickHandler(event, "dblclick");
};
WaveformView.prototype._onContextMenu = function(event) {
  this._clickHandler(event, "contextmenu");
};
WaveformView.prototype._clickHandler = function(event, eventName) {
  var offsetX = event.evt.offsetX;
  if (offsetX < 0) {
    offsetX = 0;
  }
  var emitViewEvent = true;
  if (event.target !== this._stage) {
    var marker = getMarkerObject(event.target);
    if (marker) {
      if (marker.attrs.name === "point-marker") {
        var point = marker.getAttr("point");
        if (point) {
          this._peaks.emit("points." + eventName, {
            point,
            evt: event.evt,
            preventViewEvent: function preventViewEvent() {
              emitViewEvent = false;
            }
          });
        }
      } else if (marker.attrs.name === "segment-overlay") {
        var segment = marker.getAttr("segment");
        if (segment) {
          var clickEvent = {
            segment,
            evt: event.evt,
            preventViewEvent: function preventViewEvent() {
              emitViewEvent = false;
            }
          };
          if (this._segmentsLayer) {
            this._segmentsLayer.segmentClicked(eventName, clickEvent);
          }
        }
      }
    }
  }
  if (emitViewEvent) {
    var time2 = this.pixelOffsetToTime(offsetX);
    var viewName = this.getName();
    this._peaks.emit(viewName + "." + eventName, {
      time: time2,
      evt: event.evt
    });
  }
};
WaveformView.prototype.updatePlayheadTime = function(time2) {
  this._playheadLayer.updatePlayheadTime(time2);
};
WaveformView.prototype.playheadPosChanged = function(time2) {
  if (this._playedWaveformShape) {
    this._playedSegment.endTime = time2;
    this._unplayedSegment.startTime = time2;
    this.drawWaveformLayer();
  }
};
WaveformView.prototype.drawWaveformLayer = function() {
  this._waveformLayer.draw();
};
WaveformView.prototype.enableMarkerEditing = function(enable) {
  if (this._segmentsLayer) {
    this._segmentsLayer.enableEditing(enable);
  }
  if (this._pointsLayer) {
    this._pointsLayer.enableEditing(enable);
  }
};
WaveformView.prototype.dragSeek = function(dragging) {
  if (this._segmentsLayer) {
    this._segmentsLayer.setListening(!dragging);
  }
  if (this._pointsLayer) {
    this._pointsLayer.setListening(!dragging);
  }
};
WaveformView.prototype.fitToContainer = function() {
  if (this._container.clientWidth === 0 && this._container.clientHeight === 0) {
    return;
  }
  var updateWaveform = false;
  if (this._container.clientWidth !== this._width) {
    this._width = this._container.clientWidth;
    this._stage.setWidth(this._width);
    updateWaveform = this.containerWidthChange();
  }
  var heightChanged = false;
  if (this._container.clientHeight !== this._height) {
    this._height = this._container.clientHeight;
    this._stage.setHeight(this._height);
    this._waveformShape.fitToView();
    this._playheadLayer.fitToView();
    this.containerHeightChange();
    heightChanged = true;
  }
  if (updateWaveform) {
    this.updateWaveform(this._frameOffset, true);
  } else if (heightChanged) {
    if (this._segmentsLayer) {
      this._segmentsLayer.fitToView();
    }
    if (this._pointsLayer) {
      this._pointsLayer.fitToView();
    }
  }
};
WaveformView.prototype.destroy = function() {
  this._playheadLayer.destroy();
  if (this._segmentsLayer) {
    this._segmentsLayer.destroy();
  }
  if (this._pointsLayer) {
    this._pointsLayer.destroy();
  }
  if (this._stage) {
    this._stage.destroy();
    this._stage = null;
  }
};
function MouseDragHandler(stage, handlers) {
  this._stage = stage;
  this._handlers = handlers;
  this._dragging = false;
  this._mouseDown = this._mouseDown.bind(this);
  this._mouseUp = this._mouseUp.bind(this);
  this._mouseMove = this._mouseMove.bind(this);
  this._stage.on("mousedown", this._mouseDown);
  this._stage.on("touchstart", this._mouseDown);
  this._lastMouseClientX = null;
}
MouseDragHandler.prototype._mouseDown = function(event) {
  var segment = null;
  if (event.type === "mousedown" && event.evt.button !== 0) {
    return;
  }
  var marker = getMarkerObject(event.target);
  if (marker) {
    if (marker.attrs.name === "point-marker" || marker.attrs.name === "segment-marker") {
      return;
    }
    if (marker.attrs.name === "segment-overlay") {
      segment = marker;
    }
  }
  this._lastMouseClientX = Math.floor(event.type === "touchstart" ? event.evt.touches[0].clientX : event.evt.clientX);
  if (this._handlers.onMouseDown) {
    var mouseDownPosX = this._getMousePosX(this._lastMouseClientX);
    this._handlers.onMouseDown(mouseDownPosX, segment);
  }
  window.addEventListener("mousemove", this._mouseMove, {
    capture: false,
    passive: true
  });
  window.addEventListener("touchmove", this._mouseMove, {
    capture: false,
    passive: true
  });
  window.addEventListener("mouseup", this._mouseUp, {
    capture: false,
    passive: true
  });
  window.addEventListener("touchend", this._mouseUp, {
    capture: false
    /* , passive: true */
  });
  window.addEventListener("blur", this._mouseUp, {
    capture: false,
    passive: true
  });
};
MouseDragHandler.prototype._mouseMove = function(event) {
  var clientX = Math.floor(event.type === "touchmove" ? event.changedTouches[0].clientX : event.clientX);
  if (clientX === this._lastMouseClientX) {
    return;
  }
  this._lastMouseClientX = clientX;
  this._dragging = true;
  if (this._handlers.onMouseMove) {
    var mousePosX = this._getMousePosX(clientX);
    this._handlers.onMouseMove(mousePosX);
  }
};
MouseDragHandler.prototype._mouseUp = function(event) {
  var clientX;
  if (event.type === "touchend") {
    clientX = Math.floor(event.changedTouches[0].clientX);
    if (event.cancelable) {
      event.preventDefault();
    }
  } else {
    clientX = Math.floor(event.clientX);
  }
  if (this._handlers.onMouseUp) {
    var mousePosX = this._getMousePosX(clientX);
    this._handlers.onMouseUp(mousePosX);
  }
  window.removeEventListener("mousemove", this._mouseMove, {
    capture: false
  });
  window.removeEventListener("touchmove", this._mouseMove, {
    capture: false
  });
  window.removeEventListener("mouseup", this._mouseUp, {
    capture: false
  });
  window.removeEventListener("touchend", this._mouseUp, {
    capture: false
  });
  window.removeEventListener("blur", this._mouseUp, {
    capture: false
  });
  this._dragging = false;
};
MouseDragHandler.prototype._getMousePosX = function(clientX) {
  var containerPos = this._stage.getContainer().getBoundingClientRect();
  return Math.floor(clientX - containerPos.left);
};
MouseDragHandler.prototype.isDragging = function() {
  return this._dragging;
};
MouseDragHandler.prototype.destroy = function() {
  this._stage.off("mousedown", this._mouseDown);
  this._stage.off("touchstart", this._mouseDown);
};
function SeekMouseDragHandler(peaks, view) {
  this._peaks = peaks;
  this._view = view;
  this._firstMove = false;
  this._onMouseDown = this._onMouseDown.bind(this);
  this._onMouseMove = this._onMouseMove.bind(this);
  this._onMouseUp = this._onMouseUp.bind(this);
  this._mouseDragHandler = new MouseDragHandler(view._stage, {
    onMouseDown: this._onMouseDown,
    onMouseMove: this._onMouseMove,
    onMouseUp: this._onMouseUp
  });
}
SeekMouseDragHandler.prototype._onMouseDown = function(mousePosX) {
  this._firstMove = true;
  this._seek(mousePosX);
};
SeekMouseDragHandler.prototype._onMouseMove = function(mousePosX) {
  if (this._firstMove) {
    this._view.dragSeek(true);
    this._firstMove = false;
  }
  this._seek(mousePosX);
};
SeekMouseDragHandler.prototype._onMouseUp = function() {
  this._view.dragSeek(false);
};
SeekMouseDragHandler.prototype._seek = function(mousePosX) {
  if (!this._view.isSeekEnabled()) {
    return;
  }
  mousePosX = clamp(mousePosX, 0, this._width);
  var time2 = this._view.pixelsToTime(mousePosX);
  var duration = this._peaks.player.getDuration();
  if (time2 > duration) {
    time2 = duration;
  }
  this._view.updatePlayheadTime(time2);
  this._peaks.player.seek(time2);
};
SeekMouseDragHandler.prototype.destroy = function() {
  this._mouseDragHandler.destroy();
};
function WaveformOverview(waveformData, container, peaks) {
  var self2 = this;
  WaveformView.call(self2, waveformData, container, peaks, peaks.options.overview);
  self2._onTimeUpdate = self2._onTimeUpdate.bind(self2);
  self2._onPlaying = self2._onPlaying.bind(self2);
  self2._onPause = self2._onPause.bind(self2);
  self2._onZoomviewUpdate = self2._onZoomviewUpdate.bind(self2);
  peaks.on("player.timeupdate", self2._onTimeUpdate);
  peaks.on("player.playing", self2._onPlaying);
  peaks.on("player.pause", self2._onPause);
  peaks.on("zoomview.update", self2._onZoomviewUpdate);
  var time2 = self2._peaks.player.getCurrentTime();
  self2._playheadLayer.updatePlayheadTime(time2);
  self2._mouseDragHandler = new SeekMouseDragHandler(peaks, self2);
  var zoomview = peaks.views.getView("zoomview");
  if (zoomview) {
    self2._highlightLayer.showHighlight(zoomview.getStartTime(), zoomview.getEndTime());
  }
}
WaveformOverview.prototype = Object.create(WaveformView.prototype);
WaveformOverview.prototype.initWaveformData = function() {
  if (this._width !== 0) {
    this._resampleAndSetWaveformData(this._originalWaveformData, this._width);
  }
};
WaveformOverview.prototype.initHighlightLayer = function() {
  this._highlightLayer = new HighlightLayer(this, this._viewOptions);
  this._highlightLayer.addToStage(this._stage);
};
WaveformOverview.prototype.isSegmentDraggingEnabled = function() {
  return false;
};
WaveformOverview.prototype.getName = function() {
  return "overview";
};
WaveformOverview.prototype._onTimeUpdate = function(time2) {
  this._playheadLayer.updatePlayheadTime(time2);
};
WaveformOverview.prototype._onPlaying = function(time2) {
  this._playheadLayer.updatePlayheadTime(time2);
};
WaveformOverview.prototype._onPause = function(time2) {
  this._playheadLayer.stop(time2);
};
WaveformOverview.prototype._onZoomviewUpdate = function(event) {
  this.showHighlight(event.startTime, event.endTime);
};
WaveformOverview.prototype.showHighlight = function(startTime, endTime) {
  this._highlightLayer.showHighlight(startTime, endTime);
};
WaveformOverview.prototype.setWaveformData = function(waveformData) {
  this._originalWaveformData = waveformData;
  if (this._width !== 0) {
    this._resampleAndSetWaveformData(waveformData, this._width);
  } else {
    this._data = waveformData;
  }
  this.updateWaveform();
};
WaveformOverview.prototype._resampleAndSetWaveformData = function(waveformData, width) {
  try {
    this._data = waveformData.resample({
      width
    });
    return true;
  } catch (error) {
    this._data = waveformData;
    return false;
  }
};
WaveformOverview.prototype.removeHighlightRect = function() {
  this._highlightLayer.removeHighlight();
};
WaveformOverview.prototype.updateWaveform = function() {
  this._waveformLayer.draw();
  this._axisLayer.draw();
  var playheadTime = this._peaks.player.getCurrentTime();
  this._playheadLayer.updatePlayheadTime(playheadTime);
  this._highlightLayer.updateHighlight();
  var frameStartTime = 0;
  var frameEndTime = this.pixelsToTime(this._width);
  if (this._pointsLayer) {
    this._pointsLayer.updatePoints(frameStartTime, frameEndTime);
  }
  if (this._segmentsLayer) {
    this._segmentsLayer.updateSegments(frameStartTime, frameEndTime);
  }
};
WaveformOverview.prototype.containerWidthChange = function() {
  return this._resampleAndSetWaveformData(this._originalWaveformData, this._width);
};
WaveformOverview.prototype.containerHeightChange = function() {
  this._highlightLayer.fitToView();
};
WaveformOverview.prototype.destroy = function() {
  this._peaks.off("player.playing", this._onPlaying);
  this._peaks.off("player.pause", this._onPause);
  this._peaks.off("player.timeupdate", this._onTimeUpdate);
  this._peaks.off("zoomview.update", this._onZoomviewUpdate);
  this._mouseDragHandler.destroy();
  WaveformView.prototype.destroy.call(this);
};
function InsertSegmentMouseDragHandler(peaks, view) {
  this._peaks = peaks;
  this._view = view;
  this._onMouseDown = this._onMouseDown.bind(this);
  this._onMouseMove = this._onMouseMove.bind(this);
  this._onMouseUp = this._onMouseUp.bind(this);
  this._mouseDragHandler = new MouseDragHandler(view._stage, {
    onMouseDown: this._onMouseDown,
    onMouseMove: this._onMouseMove,
    onMouseUp: this._onMouseUp
  });
}
InsertSegmentMouseDragHandler.prototype.isDragging = function() {
  return this._mouseDragHandler.isDragging();
};
InsertSegmentMouseDragHandler.prototype._reset = function() {
  this._insertSegment = null;
  this._insertSegmentShape = null;
  this._segmentIsDraggable = false;
  this._peaks.segments.setInserting(false);
};
InsertSegmentMouseDragHandler.prototype._onMouseDown = function(mousePosX, segment) {
  this._reset();
  this._segment = segment;
  if (this._segment) {
    if (this._view.getSegmentDragMode() !== "overlap") {
      return;
    } else {
      this._segmentIsDraggable = this._segment.draggable();
      this._segment.draggable(false);
    }
  }
  var time2 = this._view.pixelsToTime(mousePosX + this._view.getFrameOffset());
  this._peaks.segments.setInserting(true);
  this._insertSegment = this._peaks.segments.add({
    startTime: time2,
    endTime: time2,
    editable: true
  });
  this._insertSegmentShape = this._view._segmentsLayer.getSegmentShape(this._insertSegment);
  if (this._insertSegmentShape) {
    this._insertSegmentShape.moveMarkersToTop();
    this._insertSegmentShape.startDrag();
  }
};
InsertSegmentMouseDragHandler.prototype._onMouseMove = function() {
};
InsertSegmentMouseDragHandler.prototype._onMouseUp = function() {
  if (!this._insertSegment) {
    return;
  }
  if (this._insertSegmentShape) {
    this._insertSegmentShape.stopDrag();
    this._insertSegmentShape = null;
  }
  if (this._segment && this._segmentIsDraggable) {
    this._segment.draggable(true);
  }
  this._peaks.emit("segments.insert", {
    segment: this._insertSegment
  });
  this._peaks.segments.setInserting(false);
};
InsertSegmentMouseDragHandler.prototype.destroy = function() {
  this._mouseDragHandler.destroy();
};
function ScrollMouseDragHandler(peaks, view) {
  this._peaks = peaks;
  this._view = view;
  this._seeking = false;
  this._firstMove = false;
  this._segment = null;
  this._segmentIsDraggable = false;
  this._initialFrameOffset = 0;
  this._mouseDownX = 0;
  this._onMouseDown = this._onMouseDown.bind(this);
  this._onMouseMove = this._onMouseMove.bind(this);
  this._onMouseUp = this._onMouseUp.bind(this);
  this._mouseDragHandler = new MouseDragHandler(view._stage, {
    onMouseDown: this._onMouseDown,
    onMouseMove: this._onMouseMove,
    onMouseUp: this._onMouseUp
  });
}
ScrollMouseDragHandler.prototype.isDragging = function() {
  return this._mouseDragHandler.isDragging();
};
ScrollMouseDragHandler.prototype._onMouseDown = function(mousePosX, segment) {
  this._seeking = false;
  this._firstMove = true;
  if (segment && !segment.attrs.draggable) {
    this._segment = null;
  } else {
    this._segment = segment;
  }
  var playheadOffset = this._view.getPlayheadOffset();
  if (this._view.isSeekEnabled() && Math.abs(mousePosX - playheadOffset) <= this._view.getPlayheadClickTolerance()) {
    this._seeking = true;
    if (this._segment) {
      this._segmentIsDraggable = this._segment.draggable();
      this._segment.draggable(false);
    }
  }
  if (this._seeking) {
    mousePosX = clamp(mousePosX, 0, this._view.getWidth());
    var time2 = this._view.pixelsToTime(mousePosX + this._view.getFrameOffset());
    this._seek(time2);
  } else {
    this._initialFrameOffset = this._view.getFrameOffset();
    this._mouseDownX = mousePosX;
  }
};
ScrollMouseDragHandler.prototype._onMouseMove = function(mousePosX) {
  if (this._segment && !this._seeking) {
    return;
  }
  if (this._seeking) {
    if (this._firstMove) {
      this._view.dragSeek(true);
      this._firstMove = false;
    }
    mousePosX = clamp(mousePosX, 0, this._view.getWidth());
    var time2 = this._view.pixelsToTime(mousePosX + this._view.getFrameOffset());
    this._seek(time2);
  } else {
    if (!this._view.isAutoZoom()) {
      var diff = this._mouseDownX - mousePosX;
      var newFrameOffset = this._initialFrameOffset + diff;
      if (newFrameOffset !== this._initialFrameOffset) {
        this._view.updateWaveform(newFrameOffset);
      }
    }
  }
};
ScrollMouseDragHandler.prototype._onMouseUp = function() {
  if (this._seeking) {
    this._view.dragSeek(false);
  } else {
    if (this._view._enableSeek && !this._mouseDragHandler.isDragging()) {
      var time2 = this._view.pixelOffsetToTime(this._mouseDownX);
      this._seek(time2);
    }
  }
  if (this._segment && this._seeking) {
    if (this._segmentIsDraggable) {
      this._segment.draggable(true);
    }
  }
};
ScrollMouseDragHandler.prototype._seek = function(time2) {
  var duration = this._peaks.player.getDuration();
  if (time2 > duration) {
    time2 = duration;
  }
  this._view.updatePlayheadTime(time2);
  this._peaks.player.seek(time2);
};
ScrollMouseDragHandler.prototype.destroy = function() {
  this._mouseDragHandler.destroy();
};
function WaveformZoomView(waveformData, container, peaks) {
  var self2 = this;
  WaveformView.call(self2, waveformData, container, peaks, peaks.options.zoomview);
  self2._onTimeUpdate = self2._onTimeUpdate.bind(self2);
  self2._onPlaying = self2._onPlaying.bind(self2);
  self2._onPause = self2._onPause.bind(self2);
  self2._onKeyboardLeft = self2._onKeyboardLeft.bind(self2);
  self2._onKeyboardRight = self2._onKeyboardRight.bind(self2);
  self2._onKeyboardShiftLeft = self2._onKeyboardShiftLeft.bind(self2);
  self2._onKeyboardShiftRight = self2._onKeyboardShiftRight.bind(self2);
  self2._peaks.on("player.timeupdate", self2._onTimeUpdate);
  self2._peaks.on("player.playing", self2._onPlaying);
  self2._peaks.on("player.pause", self2._onPause);
  self2._peaks.on("keyboard.left", self2._onKeyboardLeft);
  self2._peaks.on("keyboard.right", self2._onKeyboardRight);
  self2._peaks.on("keyboard.shift_left", self2._onKeyboardShiftLeft);
  self2._peaks.on("keyboard.shift_right", self2._onKeyboardShiftRight);
  self2._autoScroll = self2._viewOptions.autoScroll;
  self2._autoScrollOffset = self2._viewOptions.autoScrollOffset;
  self2._enableSegmentDragging = false;
  self2._segmentDragMode = "overlap";
  self2._minSegmentDragWidth = 0;
  self2._insertSegmentShape = null;
  self2._playheadClickTolerance = self2._viewOptions.playheadClickTolerance;
  self2._zoomLevelAuto = false;
  self2._zoomLevelSeconds = null;
  var time2 = self2._peaks.player.getCurrentTime();
  self2._syncPlayhead(time2);
  self2._mouseDragHandler = new ScrollMouseDragHandler(peaks, self2);
  self2._onWheel = self2._onWheel.bind(self2);
  self2._onWheelCaptureVerticalScroll = self2._onWheelCaptureVerticalScroll.bind(self2);
  self2.setWheelMode(self2._viewOptions.wheelMode);
  self2._peaks.emit("zoomview.update", {
    startTime: 0,
    endTime: self2.getEndTime()
  });
}
WaveformZoomView.prototype = Object.create(WaveformView.prototype);
WaveformZoomView.prototype.initWaveformData = function() {
  this._enableWaveformCache = this._options.waveformCache;
  this._initWaveformCache();
  var initialZoomLevel = this._peaks.zoom.getZoomLevel();
  this._resampleData({
    scale: initialZoomLevel
  });
};
WaveformZoomView.prototype._initWaveformCache = function() {
  if (this._enableWaveformCache) {
    this._waveformData = /* @__PURE__ */ new Map();
    this._waveformData.set(this._originalWaveformData.scale, this._originalWaveformData);
    this._waveformScales = [this._originalWaveformData.scale];
  }
};
WaveformZoomView.prototype.initHighlightLayer = function() {
};
WaveformZoomView.prototype.setWheelMode = function(mode, options) {
  if (!options) {
    options = {};
  }
  if (mode !== this._wheelMode || options.captureVerticalScroll !== this._captureVerticalScroll) {
    this._stage.off("wheel");
    this._wheelMode = mode;
    this._captureVerticalScroll = options.captureVerticalScroll;
    switch (mode) {
      case "scroll":
        if (options.captureVerticalScroll) {
          this._stage.on("wheel", this._onWheelCaptureVerticalScroll);
        } else {
          this._stage.on("wheel", this._onWheel);
        }
        break;
    }
  }
};
WaveformZoomView.prototype._onWheel = function(event) {
  var wheelEvent = event.evt;
  var delta;
  if (wheelEvent.shiftKey) {
    if (wheelEvent.deltaY !== 0) {
      delta = wheelEvent.deltaY;
    } else if (wheelEvent.deltaX !== 0) {
      delta = wheelEvent.deltaX;
    } else {
      return;
    }
  } else {
    if (Math.abs(wheelEvent.deltaX) < Math.abs(wheelEvent.deltaY)) {
      return;
    }
    delta = wheelEvent.deltaX;
  }
  if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
    delta *= this._width;
  }
  wheelEvent.preventDefault();
  var frameOffset = clamp(this._frameOffset + Math.floor(delta), 0, this._pixelLength - this._width);
  this.updateWaveform(frameOffset, false);
};
WaveformZoomView.prototype._onWheelCaptureVerticalScroll = function(event) {
  var wheelEvent = event.evt;
  var delta = Math.abs(wheelEvent.deltaX) < Math.abs(wheelEvent.deltaY) ? wheelEvent.deltaY : wheelEvent.deltaX;
  wheelEvent.preventDefault();
  var frameOffset = clamp(this._frameOffset + Math.floor(delta), 0, this._pixelLength - this._width);
  this.updateWaveform(frameOffset, false);
};
WaveformZoomView.prototype.setWaveformDragMode = function(mode) {
  if (this._segmentsLayer) {
    this._mouseDragHandler.destroy();
    this.dragSeek(false);
    if (mode === "insert-segment") {
      this._mouseDragHandler = new InsertSegmentMouseDragHandler(this._peaks, this);
    } else {
      this._mouseDragHandler = new ScrollMouseDragHandler(this._peaks, this);
    }
  }
};
WaveformZoomView.prototype.enableSegmentDragging = function(enable) {
  this._enableSegmentDragging = enable;
  if (this._segmentsLayer) {
    this._segmentsLayer.enableSegmentDragging(enable);
  }
};
WaveformZoomView.prototype.isSegmentDraggingEnabled = function() {
  return this._enableSegmentDragging;
};
WaveformZoomView.prototype.setSegmentDragMode = function(mode) {
  this._segmentDragMode = mode;
};
WaveformZoomView.prototype.getSegmentDragMode = function() {
  return this._segmentDragMode;
};
WaveformZoomView.prototype.getName = function() {
  return "zoomview";
};
WaveformZoomView.prototype._onTimeUpdate = function(time2) {
  if (this._mouseDragHandler.isDragging()) {
    return;
  }
  this._syncPlayhead(time2);
};
WaveformZoomView.prototype._onPlaying = function(time2) {
  this._playheadLayer.updatePlayheadTime(time2);
};
WaveformZoomView.prototype._onPause = function(time2) {
  this._playheadLayer.stop(time2);
};
WaveformZoomView.prototype._onKeyboardLeft = function() {
  this._keyboardScroll(-1, false);
};
WaveformZoomView.prototype._onKeyboardRight = function() {
  this._keyboardScroll(1, false);
};
WaveformZoomView.prototype._onKeyboardShiftLeft = function() {
  this._keyboardScroll(-1, true);
};
WaveformZoomView.prototype._onKeyboardShiftRight = function() {
  this._keyboardScroll(1, true);
};
WaveformZoomView.prototype._keyboardScroll = function(direction, large) {
  var increment;
  if (large) {
    increment = direction * this._width;
  } else {
    increment = direction * this.timeToPixels(this._options.nudgeIncrement);
  }
  this.scrollWaveform({
    pixels: increment
  });
};
WaveformZoomView.prototype.setWaveformData = function(waveformData) {
  this._originalWaveformData = waveformData;
  this._initWaveformCache();
};
WaveformZoomView.prototype.getPlayheadOffset = function() {
  return this._playheadLayer.getPlayheadPixel() - this._frameOffset;
};
WaveformZoomView.prototype.getPlayheadClickTolerance = function() {
  return this._playheadClickTolerance;
};
WaveformZoomView.prototype._syncPlayhead = function(time2) {
  this._playheadLayer.updatePlayheadTime(time2);
  if (this._autoScroll && !this._zoomLevelAuto) {
    var pixelIndex = this.timeToPixels(time2);
    var endThreshold = this._frameOffset + this._width - this._autoScrollOffset;
    var frameOffset = this._frameOffset;
    if (pixelIndex >= endThreshold || pixelIndex < frameOffset) {
      frameOffset = pixelIndex - this._autoScrollOffset;
      if (frameOffset < 0) {
        frameOffset = 0;
      }
      this.updateWaveform(frameOffset, false);
    }
  }
};
WaveformZoomView.prototype._getScale = function(duration) {
  return Math.floor(duration * this._data.sample_rate / this._width);
};
function isAutoScale(options) {
  return objectHasProperty(options, "scale") && options.scale === "auto" || objectHasProperty(options, "seconds") && options.seconds === "auto";
}
WaveformZoomView.prototype.setZoom = function(options) {
  var scale;
  if (isAutoScale(options)) {
    var seconds = this._originalWaveformData.duration;
    this._zoomLevelAuto = true;
    this._zoomLevelSeconds = null;
    scale = this._getScale(seconds);
  } else {
    if (objectHasProperty(options, "scale")) {
      this._zoomLevelSeconds = null;
      scale = Math.floor(options.scale);
    } else if (objectHasProperty(options, "seconds")) {
      if (!isValidTime(options.seconds)) {
        return false;
      }
      this._zoomLevelSeconds = options.seconds;
      scale = this._getScale(options.seconds);
    }
    this._zoomLevelAuto = false;
  }
  if (scale < this._originalWaveformData.scale) {
    this._peaks._logger("peaks.zoomview.setZoom(): zoom level must be at least " + this._originalWaveformData.scale);
    scale = this._originalWaveformData.scale;
  }
  var currentTime = this._peaks.player.getCurrentTime();
  var apexTime;
  var playheadOffsetPixels = this.getPlayheadOffset();
  if (playheadOffsetPixels >= 0 && playheadOffsetPixels < this._width) {
    apexTime = currentTime;
  } else {
    playheadOffsetPixels = Math.floor(this._width / 2);
    apexTime = this.pixelOffsetToTime(playheadOffsetPixels);
  }
  var prevScale = this._scale;
  this._resampleData({
    scale
  });
  var apexPixel = this.timeToPixels(apexTime);
  var frameOffset = apexPixel - playheadOffsetPixels;
  this.updateWaveform(frameOffset, true);
  this._playheadLayer.zoomLevelChanged();
  this._playheadLayer.updatePlayheadTime(currentTime);
  this._peaks.emit("zoom.update", {
    currentZoom: scale,
    previousZoom: prevScale
  });
  return true;
};
WaveformZoomView.prototype._resampleData = function(options) {
  var scale = options.scale;
  if (this._enableWaveformCache) {
    if (!this._waveformData.has(scale)) {
      var sourceWaveform = this._originalWaveformData;
      for (var i = 0; i < this._waveformScales.length; i++) {
        if (this._waveformScales[i] < scale) {
          sourceWaveform = this._waveformData.get(this._waveformScales[i]);
        } else {
          break;
        }
      }
      this._waveformData.set(scale, sourceWaveform.resample(options));
      this._waveformScales.push(scale);
      this._waveformScales.sort(function(a, b) {
        return a - b;
      });
    }
    this._data = this._waveformData.get(scale);
  } else {
    this._data = this._originalWaveformData.resample(options);
  }
  this._scale = this._data.scale;
  this._pixelLength = this._data.length;
};
WaveformZoomView.prototype.isAutoZoom = function() {
  return this._zoomLevelAuto;
};
WaveformZoomView.prototype.setStartTime = function(time2) {
  if (time2 < 0) {
    time2 = 0;
  }
  if (this._zoomLevelAuto) {
    time2 = 0;
  }
  this.updateWaveform(this.timeToPixels(time2), false);
};
WaveformZoomView.prototype.getPixelLength = function() {
  return this._pixelLength;
};
WaveformZoomView.prototype.scrollWaveform = function(options) {
  var scrollAmount;
  if (objectHasProperty(options, "pixels")) {
    scrollAmount = Math.floor(options.pixels);
  } else if (objectHasProperty(options, "seconds")) {
    scrollAmount = this.timeToPixels(options.seconds);
  } else {
    throw new TypeError("view.scrollWaveform(): Missing umber of pixels or seconds");
  }
  this.updateWaveform(this._frameOffset + scrollAmount, false);
};
WaveformZoomView.prototype.updateWaveform = function(frameOffset, forceUpdate) {
  var upperLimit;
  if (this._pixelLength < this._width) {
    frameOffset = 0;
    upperLimit = this._width;
  } else {
    upperLimit = this._pixelLength - this._width;
  }
  frameOffset = clamp(frameOffset, 0, upperLimit);
  if (!forceUpdate && frameOffset === this._frameOffset) {
    return;
  }
  this._frameOffset = frameOffset;
  var playheadPixel = this._playheadLayer.getPlayheadPixel();
  this._playheadLayer.updatePlayheadTime(this.pixelsToTime(playheadPixel));
  this.drawWaveformLayer();
  this._axisLayer.draw();
  var frameStartTime = this.getStartTime();
  var frameEndTime = this.getEndTime();
  if (this._pointsLayer) {
    this._pointsLayer.updatePoints(frameStartTime, frameEndTime);
  }
  if (this._segmentsLayer) {
    this._segmentsLayer.updateSegments(frameStartTime, frameEndTime);
  }
  this._peaks.emit("zoomview.update", {
    startTime: frameStartTime,
    endTime: frameEndTime
  });
};
WaveformZoomView.prototype.enableAutoScroll = function(enable, options) {
  if (!options) {
    options = {};
  }
  this._autoScroll = enable;
  if (objectHasProperty(options, "offset")) {
    this._autoScrollOffset = options.offset;
  }
};
WaveformZoomView.prototype.getMinSegmentDragWidth = function() {
  return this._insertSegmentShape ? 0 : this._minSegmentDragWidth;
};
WaveformZoomView.prototype.setMinSegmentDragWidth = function(width) {
  this._minSegmentDragWidth = width;
};
WaveformZoomView.prototype.containerWidthChange = function() {
  var resample2 = false;
  var resampleOptions;
  if (this._zoomLevelAuto) {
    resample2 = true;
    resampleOptions = {
      width: this._width
    };
  } else if (this._zoomLevelSeconds !== null) {
    resample2 = true;
    resampleOptions = {
      scale: this._getScale(this._zoomLevelSeconds)
    };
  }
  if (resample2) {
    try {
      this._resampleData(resampleOptions);
    } catch (error) {
    }
  }
  return true;
};
WaveformZoomView.prototype.containerHeightChange = function() {
};
WaveformZoomView.prototype.getStage = function() {
  return this._stage;
};
WaveformZoomView.prototype.getSegmentsLayer = function() {
  return this._segmentsLayer;
};
WaveformZoomView.prototype.destroy = function() {
  this._peaks.off("player.playing", this._onPlaying);
  this._peaks.off("player.pause", this._onPause);
  this._peaks.off("player.timeupdate", this._onTimeUpdate);
  this._peaks.off("keyboard.left", this._onKeyboardLeft);
  this._peaks.off("keyboard.right", this._onKeyboardRight);
  this._peaks.off("keyboard.shift_left", this._onKeyboardShiftLeft);
  this._peaks.off("keyboard.shift_right", this._onKeyboardShiftRight);
  if (this._enableWaveformCache) {
    this._waveformData.clear();
    delete this._waveformData;
    delete this._waveformScales;
  } else {
    delete this._data;
  }
  this._mouseDragHandler.destroy();
  WaveformView.prototype.destroy.call(this);
};
function Scrollbar(container, peaks) {
  this._container = container;
  this._peaks = peaks;
  this._options = peaks.options.scrollbar;
  this._zoomview = peaks.views.getView("zoomview");
  this._dragBoundFunc = this._dragBoundFunc.bind(this);
  this._onScrollboxDragStart = this._onScrollboxDragStart.bind(this);
  this._onScrollboxDragMove = this._onScrollboxDragMove.bind(this);
  this._onScrollboxDragEnd = this._onScrollboxDragEnd.bind(this);
  this._onZoomviewUpdate = this._onZoomviewUpdate.bind(this);
  this._onScrollbarClick = this._onScrollbarClick.bind(this);
  this._peaks.on("zoomview.update", this._onZoomviewUpdate);
  this._width = container.clientWidth;
  this._height = container.clientHeight;
  this._stage = new Core_default.Stage({
    container,
    width: this._width,
    height: this._height
  });
  this._layer = new Core_default.Layer();
  this._stage.on("click", this._onScrollbarClick);
  this._stage.add(this._layer);
  this._color = this._options.color;
  this._scrollboxX = 0;
  this._minScrollboxWidth = this._options.minWidth;
  this._offsetY = 0;
  this._scrollbox = new Core_default.Group({
    draggable: true,
    dragBoundFunc: this._dragBoundFunc
  });
  this._scrollboxRect = new Rect({
    x: this._scrollboxX,
    y: this._offsetY,
    width: 0,
    height: this._height,
    fill: this._color
  });
  this._scrollbox.add(this._scrollboxRect);
  this._setScrollboxWidth();
  this._scrollbox.on("dragstart", this._onScrollboxDragStart);
  this._scrollbox.on("dragmove", this._onScrollboxDragMove);
  this._scrollbox.on("dragend", this._onScrollboxDragEnd);
  this._layer.add(this._scrollbox);
  this._updateScrollbarWidthAndPosition();
}
Scrollbar.prototype.setZoomview = function(zoomview) {
  this._zoomview = zoomview;
  this._updateScrollbarWidthAndPosition();
};
Scrollbar.prototype._setScrollboxWidth = function() {
  if (this._zoomview) {
    this._scrollboxWidth = Math.floor(this._width * this._zoomview.pixelsToTime(this._zoomview.getWidth()) / this._peaks.player.getDuration());
    if (this._scrollboxWidth < this._minScrollboxWidth) {
      this._scrollboxWidth = this._minScrollboxWidth;
    }
  } else {
    this._scrollboxWidth = this._width;
  }
  this._scrollboxRect.width(this._scrollboxWidth);
};
Scrollbar.prototype._getScrollbarRange = function() {
  return this._width - this._scrollboxWidth;
};
Scrollbar.prototype._dragBoundFunc = function(pos) {
  return {
    x: pos.x,
    y: 0
  };
};
Scrollbar.prototype._onScrollboxDragStart = function() {
  this._dragging = true;
};
Scrollbar.prototype._onScrollboxDragEnd = function() {
  this._dragging = false;
};
Scrollbar.prototype._onScrollboxDragMove = function() {
  var range = this._getScrollbarRange();
  var x = clamp(this._scrollbox.x(), 0, range);
  this._scrollbox.x(x);
  if (x !== this._scrollboxX) {
    this._scrollboxX = x;
    if (this._zoomview) {
      this._updateWaveform(x);
    }
  }
};
Scrollbar.prototype._onZoomviewUpdate = function() {
  if (!this._dragging) {
    this._updateScrollbarWidthAndPosition();
  }
};
Scrollbar.prototype._updateScrollbarWidthAndPosition = function() {
  this._setScrollboxWidth();
  if (this._zoomview) {
    var startTime = this._zoomview.getStartTime();
    var zoomviewRange = this._zoomview.getPixelLength() - this._zoomview.getWidth();
    var scrollBoxPos = Math.floor(this._zoomview.timeToPixels(startTime) * this._getScrollbarRange() / zoomviewRange);
    this._scrollbox.x(scrollBoxPos);
    this._layer.draw();
  }
};
Scrollbar.prototype._onScrollbarClick = function(event) {
  if (event.target === this._stage) {
    if (this._zoomview) {
      var x = Math.floor(event.evt.offsetX - this._scrollboxWidth / 2);
      if (x < 0) {
        x = 0;
      }
      this._updateWaveform(x);
    }
  }
};
Scrollbar.prototype._updateWaveform = function(x) {
  var offset = Math.floor((this._zoomview.getPixelLength() - this._zoomview.getWidth()) * x / this._getScrollbarRange());
  this._zoomview.updateWaveform(offset);
};
Scrollbar.prototype.fitToContainer = function() {
  if (this._container.clientWidth === 0 && this._container.clientHeight === 0) {
    return;
  }
  if (this._container.clientWidth !== this._width) {
    this._width = this._container.clientWidth;
    this._stage.width(this._width);
    this._updateScrollbarWidthAndPosition();
  }
  this._height = this._container.clientHeight;
  this._stage.height(this._height);
};
Scrollbar.prototype.destroy = function() {
  this._peaks.off("zoomview.update", this._onZoomviewUpdate);
  this._layer.destroy();
  this._stage.destroy();
  this._stage = null;
};
function ViewController(peaks) {
  this._peaks = peaks;
  this._overview = null;
  this._zoomview = null;
  this._scrollbar = null;
}
ViewController.prototype.createOverview = function(container) {
  if (this._overview) {
    return this._overview;
  }
  var waveformData = this._peaks.getWaveformData();
  this._overview = new WaveformOverview(waveformData, container, this._peaks);
  if (this._zoomview) {
    this._overview.showHighlight(this._zoomview.getStartTime(), this._zoomview.getEndTime());
  }
  return this._overview;
};
ViewController.prototype.createZoomview = function(container) {
  if (this._zoomview) {
    return this._zoomview;
  }
  var waveformData = this._peaks.getWaveformData();
  this._zoomview = new WaveformZoomView(waveformData, container, this._peaks);
  if (this._scrollbar) {
    this._scrollbar.setZoomview(this._zoomview);
  }
  return this._zoomview;
};
ViewController.prototype.createScrollbar = function(container) {
  this._scrollbar = new Scrollbar(container, this._peaks);
  return this._scrollbar;
};
ViewController.prototype.destroyOverview = function() {
  if (!this._overview) {
    return;
  }
  if (!this._zoomview) {
    return;
  }
  this._overview.destroy();
  this._overview = null;
};
ViewController.prototype.destroyZoomview = function() {
  if (!this._zoomview) {
    return;
  }
  if (!this._overview) {
    return;
  }
  this._zoomview.destroy();
  this._zoomview = null;
  this._overview.removeHighlightRect();
};
ViewController.prototype.destroy = function() {
  if (this._overview) {
    this._overview.destroy();
    this._overview = null;
  }
  if (this._zoomview) {
    this._zoomview.destroy();
    this._zoomview = null;
  }
  if (this._scrollbar) {
    this._scrollbar.destroy();
    this._scrollbar = null;
  }
};
ViewController.prototype.getView = function(name) {
  if (isNullOrUndefined2(name)) {
    if (this._overview && this._zoomview) {
      return null;
    } else if (this._overview) {
      return this._overview;
    } else if (this._zoomview) {
      return this._zoomview;
    } else {
      return null;
    }
  } else {
    switch (name) {
      case "overview":
        return this._overview;
      case "zoomview":
        return this._zoomview;
      default:
        return null;
    }
  }
};
ViewController.prototype.getScrollbar = function() {
  return this._scrollbar;
};
function ZoomController(peaks, zoomLevels) {
  this._peaks = peaks;
  this._zoomLevels = zoomLevels;
  this._zoomLevelIndex = 0;
}
ZoomController.prototype.setZoomLevels = function(zoomLevels) {
  this._zoomLevels = zoomLevels;
  this.setZoom(0, true);
};
ZoomController.prototype.zoomIn = function() {
  this.setZoom(this._zoomLevelIndex - 1, false);
};
ZoomController.prototype.zoomOut = function() {
  this.setZoom(this._zoomLevelIndex + 1, false);
};
ZoomController.prototype.setZoom = function(zoomLevelIndex, forceUpdate) {
  if (zoomLevelIndex >= this._zoomLevels.length) {
    zoomLevelIndex = this._zoomLevels.length - 1;
  }
  if (zoomLevelIndex < 0) {
    zoomLevelIndex = 0;
  }
  if (!forceUpdate && zoomLevelIndex === this._zoomLevelIndex) {
    return;
  }
  this._zoomLevelIndex = zoomLevelIndex;
  var zoomview = this._peaks.views.getView("zoomview");
  if (!zoomview) {
    return;
  }
  zoomview.setZoom({
    scale: this._zoomLevels[zoomLevelIndex]
  });
};
ZoomController.prototype.getZoom = function() {
  return this._zoomLevelIndex;
};
ZoomController.prototype.getZoomLevel = function() {
  return this._zoomLevels[this._zoomLevelIndex];
};
var isXhr2 = "withCredentials" in new XMLHttpRequest();
function WaveformBuilder(peaks) {
  this._peaks = peaks;
}
WaveformBuilder.prototype.init = function(options, callback) {
  if (options.dataUri && (options.webAudio || options.audioContext) || options.waveformData && (options.webAudio || options.audioContext) || options.dataUri && options.waveformData) {
    callback(new TypeError("Peaks.init(): You may only pass one source (webAudio, dataUri, or waveformData) to render waveform data."));
    return;
  }
  if (options.audioContext) {
    this._peaks._logger("Peaks.init(): The audioContext option is deprecated, please pass a webAudio object instead");
    options.webAudio = {
      audioContext: options.audioContext
    };
  }
  if (options.dataUri) {
    return this._getRemoteWaveformData(options, callback);
  } else if (options.waveformData) {
    return this._buildWaveformFromLocalData(options, callback);
  } else if (options.webAudio) {
    if (options.webAudio.audioBuffer) {
      return this._buildWaveformDataFromAudioBuffer(options, callback);
    } else {
      return this._buildWaveformDataUsingWebAudio(options, callback);
    }
  } else {
    callback(new Error("Peaks.init(): You must pass an audioContext, or dataUri, or waveformData to render waveform data"));
  }
};
function hasValidContentRangeHeader(xhr) {
  var contentRange = xhr.getResponseHeader("content-range");
  if (!contentRange) {
    return false;
  }
  var matches = contentRange.match(/^bytes (\d+)-(\d+)\/(\d+)$/);
  if (matches && matches.length === 4) {
    var firstPos = parseInt(matches[1], 10);
    var lastPos = parseInt(matches[2], 10);
    var length = parseInt(matches[3], 10);
    if (firstPos === 0 && lastPos + 1 === length) {
      return true;
    }
    return false;
  }
  return false;
}
WaveformBuilder.prototype._getRemoteWaveformData = function(options, callback) {
  var self2 = this;
  var dataUri = null;
  var requestType = null;
  var url;
  if (isObject(options.dataUri)) {
    dataUri = options.dataUri;
  } else {
    callback(new TypeError("Peaks.init(): The dataUri option must be an object"));
    return;
  }
  ["ArrayBuffer", "JSON"].some(function(connector) {
    if (window[connector]) {
      requestType = connector.toLowerCase();
      url = dataUri[requestType];
      return Boolean(url);
    }
  });
  if (!url) {
    callback(new Error("Peaks.init(): Unable to determine a compatible dataUri format for this browser"));
    return;
  }
  self2._xhr = self2._createXHR(url, requestType, options.withCredentials, function(event) {
    if (this.readyState !== 4) {
      return;
    }
    if (this.status !== 200 && !(this.status === 206 && hasValidContentRangeHeader(this))) {
      callback(new Error("Unable to fetch remote data. HTTP status " + this.status));
      return;
    }
    self2._xhr = null;
    var waveformData = WaveformData.create(event.target.response);
    if (waveformData.channels !== 1 && waveformData.channels !== 2) {
      callback(new Error("Peaks.init(): Only mono or stereo waveforms are currently supported"));
      return;
    } else if (waveformData.bits !== 8) {
      callback(new Error("Peaks.init(): 16-bit waveform data is not supported"));
      return;
    }
    callback(void 0, waveformData);
  }, function() {
    callback(new Error("XHR failed"));
  }, function() {
    callback(new Error("XHR aborted"));
  });
  self2._xhr.send();
};
WaveformBuilder.prototype._buildWaveformFromLocalData = function(options, callback) {
  var waveformData = null;
  var data = null;
  if (isObject(options.waveformData)) {
    waveformData = options.waveformData;
  } else {
    callback(new Error("Peaks.init(): The waveformData option must be an object"));
    return;
  }
  if (isObject(waveformData.json)) {
    data = waveformData.json;
  } else if (isArrayBuffer(waveformData.arraybuffer)) {
    data = waveformData.arraybuffer;
  }
  if (!data) {
    callback(new Error("Peaks.init(): Unable to determine a compatible waveformData format"));
    return;
  }
  try {
    var createdWaveformData = WaveformData.create(data);
    if (createdWaveformData.channels !== 1 && createdWaveformData.channels !== 2) {
      callback(new Error("Peaks.init(): Only mono or stereo waveforms are currently supported"));
      return;
    } else if (createdWaveformData.bits !== 8) {
      callback(new Error("Peaks.init(): 16-bit waveform data is not supported"));
      return;
    }
    callback(void 0, createdWaveformData);
  } catch (err) {
    callback(err);
  }
};
WaveformBuilder.prototype._buildWaveformDataUsingWebAudio = function(options, callback) {
  var self2 = this;
  var audioContext = window.AudioContext || window.webkitAudioContext;
  if (!(options.webAudio.audioContext instanceof audioContext)) {
    callback(new TypeError("Peaks.init(): The webAudio.audioContext option must be a valid AudioContext"));
    return;
  }
  var webAudioOptions = options.webAudio;
  if (webAudioOptions.scale !== options.zoomLevels[0]) {
    webAudioOptions.scale = options.zoomLevels[0];
  }
  var mediaSourceUrl = self2._peaks.options.mediaElement.currentSrc;
  if (mediaSourceUrl) {
    self2._requestAudioAndBuildWaveformData(mediaSourceUrl, webAudioOptions, options.withCredentials, callback);
  } else {
    self2._peaks.once("player.canplay", function() {
      self2._requestAudioAndBuildWaveformData(self2._peaks.options.mediaElement.currentSrc, webAudioOptions, options.withCredentials, callback);
    });
  }
};
WaveformBuilder.prototype._buildWaveformDataFromAudioBuffer = function(options, callback) {
  var webAudioOptions = options.webAudio;
  if (webAudioOptions.scale !== options.zoomLevels[0]) {
    webAudioOptions.scale = options.zoomLevels[0];
  }
  var webAudioBuilderOptions = {
    audio_buffer: webAudioOptions.audioBuffer,
    split_channels: webAudioOptions.multiChannel,
    scale: webAudioOptions.scale,
    disable_worker: true
  };
  WaveformData.createFromAudio(webAudioBuilderOptions, callback);
};
WaveformBuilder.prototype._requestAudioAndBuildWaveformData = function(url, webAudio, withCredentials, callback) {
  var self2 = this;
  if (!url) {
    self2._peaks._logger("Peaks.init(): The mediaElement src is invalid");
    return;
  }
  self2._xhr = self2._createXHR(url, "arraybuffer", withCredentials, function(event) {
    if (this.readyState !== 4) {
      return;
    }
    if (this.status !== 200 && !(this.status === 206 && hasValidContentRangeHeader(this))) {
      callback(new Error("Unable to fetch remote data. HTTP status " + this.status));
      return;
    }
    self2._xhr = null;
    var webAudioBuilderOptions = {
      audio_context: webAudio.audioContext,
      array_buffer: event.target.response,
      split_channels: webAudio.multiChannel,
      scale: webAudio.scale
    };
    WaveformData.createFromAudio(webAudioBuilderOptions, callback);
  }, function() {
    callback(new Error("XHR failed"));
  }, function() {
    callback(new Error("XHR aborted"));
  });
  self2._xhr.send();
};
WaveformBuilder.prototype.abort = function() {
  if (this._xhr) {
    this._xhr.abort();
  }
};
WaveformBuilder.prototype._createXHR = function(url, requestType, withCredentials, onLoad, onError, onAbort) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url, true);
  if (isXhr2) {
    try {
      xhr.responseType = requestType;
    } catch (error) {
    }
  }
  xhr.onload = onLoad;
  xhr.onerror = onError;
  if (isXhr2 && withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.addEventListener("abort", onAbort);
  return xhr;
};
function Peaks() {
  EventEmitter.call(this);
  this.options = {
    zoomLevels: [512, 1024, 2048, 4096],
    waveformCache: true,
    mediaElement: null,
    mediaUrl: null,
    dataUri: null,
    withCredentials: false,
    waveformData: null,
    webAudio: null,
    nudgeIncrement: 1,
    pointMarkerColor: "#39cccc",
    createSegmentMarker,
    createSegmentLabel,
    createPointMarker,
    // eslint-disable-next-line no-console
    logger: console.error.bind(console)
  };
  return this;
}
Peaks.prototype = Object.create(EventEmitter.prototype);
var defaultViewOptions = {
  playheadColor: "#111111",
  playheadTextColor: "#aaaaaa",
  playheadBackgroundColor: "transparent",
  playheadPadding: 2,
  playheadWidth: 1,
  axisGridlineColor: "#cccccc",
  showAxisLabels: true,
  axisTopMarkerHeight: 10,
  axisBottomMarkerHeight: 10,
  axisLabelColor: "#aaaaaa",
  fontFamily: "sans-serif",
  fontSize: 11,
  fontStyle: "normal",
  timeLabelPrecision: 2,
  enablePoints: true,
  enableSegments: true
};
var defaultZoomviewOptions = {
  // showPlayheadTime:    true,
  playheadClickTolerance: 3,
  waveformColor: "rgba(0, 225, 128, 1)",
  wheelMode: "none",
  autoScroll: true,
  autoScrollOffset: 100,
  enableEditing: true
};
var defaultOverviewOptions = {
  // showPlayheadTime:    false,
  waveformColor: "rgba(0, 0, 0, 0.2)",
  highlightColor: "#aaaaaa",
  highlightStrokeColor: "transparent",
  highlightOpacity: 0.3,
  highlightOffset: 11,
  highlightCornerRadius: 2,
  enableEditing: false
};
var defaultSegmentOptions = {
  overlay: false,
  markers: true,
  startMarkerColor: "#aaaaaa",
  endMarkerColor: "#aaaaaa",
  waveformColor: "#0074d9",
  overlayColor: "#ff0000",
  overlayOpacity: 0.3,
  overlayBorderColor: "#ff0000",
  overlayBorderWidth: 2,
  overlayCornerRadius: 5,
  overlayOffset: 25,
  overlayLabelAlign: "left",
  overlayLabelVerticalAlign: "top",
  overlayLabelPadding: 8,
  overlayLabelColor: "#000000",
  overlayFontFamily: "sans-serif",
  overlayFontSize: 12,
  overlayFontStyle: "normal"
};
var defaultScrollbarOptions = {
  color: "#888888",
  minWidth: 50
};
function getOverviewOptions(opts) {
  var overviewOptions = {};
  if (opts.overview && opts.overview.showPlayheadTime) {
    overviewOptions.showPlayheadTime = opts.overview.showPlayheadTime;
  }
  var optNames = ["container", "waveformColor", "playedWaveformColor", "playheadColor", "playheadTextColor", "playheadBackgroundColor", "playheadPadding", "playheadWidth", "formatPlayheadTime", "timeLabelPrecision", "axisGridlineColor", "showAxisLabels", "axisTopMarkerHeight", "axisBottomMarkerHeight", "axisLabelColor", "formatAxisTime", "fontFamily", "fontSize", "fontStyle", "highlightColor", "highlightStrokeColor", "highlightOpacity", "highlightCornerRadius", "highlightOffset", "enablePoints", "enableSegments", "enableEditing"];
  optNames.forEach(function(optName) {
    if (opts.overview && objectHasProperty(opts.overview, optName)) {
      overviewOptions[optName] = opts.overview[optName];
    } else if (objectHasProperty(opts, optName)) {
      overviewOptions[optName] = opts[optName];
    } else if (!objectHasProperty(overviewOptions, optName)) {
      if (objectHasProperty(defaultOverviewOptions, optName)) {
        overviewOptions[optName] = defaultOverviewOptions[optName];
      } else if (objectHasProperty(defaultViewOptions, optName)) {
        overviewOptions[optName] = defaultViewOptions[optName];
      }
    }
  });
  return overviewOptions;
}
function getZoomviewOptions(opts) {
  var zoomviewOptions = {};
  if (opts.showPlayheadTime) {
    zoomviewOptions.showPlayheadTime = opts.showPlayheadTime;
  } else if (opts.zoomview && opts.zoomview.showPlayheadTime) {
    zoomviewOptions.showPlayheadTime = opts.zoomview.showPlayheadTime;
  }
  var optNames = ["container", "waveformColor", "playedWaveformColor", "playheadColor", "playheadTextColor", "playheadBackgroundColor", "playheadPadding", "playheadWidth", "formatPlayheadTime", "playheadClickTolerance", "timeLabelPrecision", "axisGridlineColor", "showAxisLabels", "axisTopMarkerHeight", "axisBottomMarkerHeight", "axisLabelColor", "formatAxisTime", "fontFamily", "fontSize", "fontStyle", "wheelMode", "autoScroll", "autoScrollOffset", "enablePoints", "enableSegments", "enableEditing"];
  optNames.forEach(function(optName) {
    if (opts.zoomview && objectHasProperty(opts.zoomview, optName)) {
      zoomviewOptions[optName] = opts.zoomview[optName];
    } else if (objectHasProperty(opts, optName)) {
      zoomviewOptions[optName] = opts[optName];
    } else if (!objectHasProperty(zoomviewOptions, optName)) {
      if (objectHasProperty(defaultZoomviewOptions, optName)) {
        zoomviewOptions[optName] = defaultZoomviewOptions[optName];
      } else if (objectHasProperty(defaultViewOptions, optName)) {
        zoomviewOptions[optName] = defaultViewOptions[optName];
      }
    }
  });
  return zoomviewOptions;
}
function getScrollbarOptions(opts) {
  if (!objectHasProperty(opts, "scrollbar")) {
    return null;
  }
  var scrollbarOptions = {};
  var optNames = ["container", "color", "minWidth"];
  optNames.forEach(function(optName) {
    if (objectHasProperty(opts.scrollbar, optName)) {
      scrollbarOptions[optName] = opts.scrollbar[optName];
    } else {
      scrollbarOptions[optName] = defaultScrollbarOptions[optName];
    }
  });
  return scrollbarOptions;
}
function extendOptions(to, from) {
  for (var key in from) {
    if (objectHasProperty(from, key) && objectHasProperty(to, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function addSegmentOptions(options, opts) {
  options.segmentOptions = {};
  extend(options.segmentOptions, defaultSegmentOptions);
  if (opts.segmentOptions) {
    extendOptions(options.segmentOptions, opts.segmentOptions);
  }
  options.zoomview.segmentOptions = {};
  extend(options.zoomview.segmentOptions, options.segmentOptions);
  if (opts.zoomview && opts.zoomview.segmentOptions) {
    extendOptions(options.zoomview.segmentOptions, opts.zoomview.segmentOptions);
  }
  options.overview.segmentOptions = {};
  extend(options.overview.segmentOptions, options.segmentOptions);
  if (opts.overview && opts.overview.segmentOptions) {
    extendOptions(options.overview.segmentOptions, opts.overview.segmentOptions);
  }
}
function checkContainerElements(options) {
  var zoomviewContainer = options.zoomview.container;
  var overviewContainer = options.overview.container;
  if (!isHTMLElement(zoomviewContainer) && !isHTMLElement(overviewContainer)) {
    return new TypeError("Peaks.init(): The zoomview and/or overview container options must be valid HTML elements");
  }
  if (zoomviewContainer && (zoomviewContainer.clientWidth <= 0 || zoomviewContainer.clientHeight <= 0)) {
    return new Error("Peaks.init(): The zoomview container must be visible and have non-zero width and height");
  }
  if (overviewContainer && (overviewContainer.clientWidth <= 0 || overviewContainer.clientHeight <= 0)) {
    return new Error("Peaks.init(): The overview container must be visible and have non-zero width and height");
  }
}
Peaks.init = function(opts, callback) {
  if (!callback) {
    throw new Error("Peaks.init(): Missing callback function");
  }
  var instance = new Peaks();
  var err = instance._setOptions(opts);
  if (!err) {
    err = checkContainerElements(instance.options);
  }
  if (err) {
    callback(err);
    return;
  }
  var scrollbarContainer = null;
  if (instance.options.scrollbar) {
    scrollbarContainer = instance.options.scrollbar.container;
    if (!isHTMLElement(scrollbarContainer)) {
      callback(new TypeError("Peaks.init(): The scrollbar container option must be a valid HTML element"));
      return;
    }
    if (scrollbarContainer.clientWidth <= 0) {
      callback(new TypeError("Peaks.init(): The scrollbar container must be visible and have non-zero width"));
      return;
    }
  }
  if (opts.keyboard) {
    instance._keyboardHandler = new KeyboardHandler(instance);
  }
  var player = opts.player ? opts.player : new MediaElementPlayer(instance.options.mediaElement);
  instance.player = new Player(instance, player);
  instance.segments = new WaveformSegments(instance);
  instance.points = new WaveformPoints(instance);
  instance.zoom = new ZoomController(instance, instance.options.zoomLevels);
  instance.views = new ViewController(instance);
  instance._waveformBuilder = new WaveformBuilder(instance);
  instance.player.init(instance).then(function() {
    instance._waveformBuilder.init(instance.options, function(err2, waveformData) {
      if (err2) {
        callback(err2);
        return;
      }
      err2 = checkContainerElements(instance.options);
      if (err2) {
        callback(err2);
        return;
      }
      instance._waveformBuilder = null;
      instance._waveformData = waveformData;
      var zoomviewContainer = instance.options.zoomview.container;
      var overviewContainer = instance.options.overview.container;
      if (zoomviewContainer) {
        instance.views.createZoomview(zoomviewContainer);
      }
      if (overviewContainer) {
        instance.views.createOverview(overviewContainer);
      }
      if (scrollbarContainer) {
        instance.views.createScrollbar(scrollbarContainer);
      }
      if (opts.segments) {
        instance.segments.add(opts.segments);
      }
      if (opts.points) {
        instance.points.add(opts.points);
      }
      if (opts.emitCueEvents) {
        instance._cueEmitter = new CueEmitter(instance);
      }
      callback(null, instance);
    });
  }).catch(function(err2) {
    callback(err2);
  });
};
Peaks.prototype._setOptions = function(opts) {
  if (!isObject(opts)) {
    return new TypeError("Peaks.init(): The options parameter should be an object");
  }
  if (!opts.player) {
    if (!opts.mediaElement) {
      return new Error("Peaks.init(): Missing mediaElement option");
    }
    if (!(opts.mediaElement instanceof HTMLMediaElement)) {
      return new TypeError("Peaks.init(): The mediaElement option should be an HTMLMediaElement");
    }
  }
  if (opts.logger && !isFunction(opts.logger)) {
    return new TypeError("Peaks.init(): The logger option should be a function");
  }
  if (opts.segments && !Array.isArray(opts.segments)) {
    return new TypeError("Peaks.init(): options.segments must be an array of segment objects");
  }
  if (opts.points && !Array.isArray(opts.points)) {
    return new TypeError("Peaks.init(): options.points must be an array of point objects");
  }
  extendOptions(this.options, opts);
  this.options.overview = getOverviewOptions(opts);
  this.options.zoomview = getZoomviewOptions(opts);
  this.options.scrollbar = getScrollbarOptions(opts);
  addSegmentOptions(this.options, opts);
  if (!Array.isArray(this.options.zoomLevels)) {
    return new TypeError("Peaks.init(): The zoomLevels option should be an array");
  } else if (this.options.zoomLevels.length === 0) {
    return new Error("Peaks.init(): The zoomLevels array must not be empty");
  } else {
    if (!isInAscendingOrder(this.options.zoomLevels)) {
      return new Error("Peaks.init(): The zoomLevels array must be sorted in ascending order");
    }
  }
  this._logger = this.options.logger;
};
Peaks.prototype.setSource = function(options, callback) {
  var self2 = this;
  self2.player._setSource(options).then(function() {
    if (!options.zoomLevels) {
      options.zoomLevels = self2.options.zoomLevels;
    }
    self2._waveformBuilder = new WaveformBuilder(self2);
    self2._waveformBuilder.init(options, function(err, waveformData) {
      if (err) {
        callback(err);
        return;
      }
      self2._waveformBuilder = null;
      self2._waveformData = waveformData;
      ["overview", "zoomview"].forEach(function(viewName) {
        var view = self2.views.getView(viewName);
        if (view) {
          view.setWaveformData(waveformData);
        }
      });
      self2.zoom.setZoomLevels(options.zoomLevels);
      callback();
    });
  }).catch(function(err) {
    callback(err);
  });
};
Peaks.prototype.getWaveformData = function() {
  return this._waveformData;
};
Peaks.prototype.destroy = function() {
  if (this._waveformBuilder) {
    this._waveformBuilder.abort();
  }
  if (this._keyboardHandler) {
    this._keyboardHandler.destroy();
  }
  if (this.views) {
    this.views.destroy();
  }
  if (this.player) {
    this.player.destroy();
  }
  if (this._cueEmitter) {
    this._cueEmitter.destroy();
  }
};
export {
  Peaks as default
};
//# sourceMappingURL=peaks__js.js.map
